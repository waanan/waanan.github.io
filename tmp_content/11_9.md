---
title: "函数重载简介"
date: 2023-11-01T20:12:31+08:00
---

考虑以下函数：

```C++
int add(int x, int y)
{
    return x + y;
}
```

这个平凡的函数将两个整数相加，并返回一个整数结果。然而，如果我们还需要一个可以添加两个浮点数的函数，该怎么办？此add（）函数不适用，因为任何浮点参数都将转换为整数，从而导致浮点参数丢失其小数。

解决此问题的一种方法是使用稍微不同的名称定义多个函数：

```C++
int addInteger(int x, int y)
{
    return x + y;
}

double addDouble(double x, double y)
{
    return x + y;
}
```

然而，为了获得最佳效果，这需要为具有不同类型参数的类似函数定义一致的函数命名标准，记住这些函数的名称，并实际调用正确的函数。

然后，当我们想要一个类似的函数，将3个整数而不是2相加时，会发生什么？管理每个函数的唯一名称很快就会变得繁琐。

***
## 函数重载简介

幸运的是，C++有一个优雅的解决方案来处理这种情况。函数重载允许我们创建具有相同名称的多个函数，只要每个同名函数具有不同的参数类型（或者可以以其他方式区分函数）。每个共享名称（在同一范围内）的函数都被称为重载函数（有时简称为重载）。

要重载我们的add（）函数，我们可以简单地声明另一个采用双参数的ad（）函数：

```C++
double add(double x, double y)
{
    return x + y;
}
```

现在，在同一范围内有两个版本的add（）：

```C++
int add(int x, int y) // integer version
{
    return x + y;
}

double add(double x, double y) // floating point version
{
    return x + y;
}

int main()
{
    return 0;
}
```

将编译上述程序。尽管您可能期望这些函数会导致命名冲突，但这里并不是这样。由于这些函数的参数类型不同，编译器能够区分这些函数，并将它们视为碰巧共享名称的单独函数。

{{< alert success >}}
**关键洞察力**

只要编译器可以区分每个重载函数，就可以重载函数。如果无法区分重载函数，则将导致编译错误。

{{< /alert >}}

{{< alert success >}}
**相关内容**

运算符也可以以类似的方式重载。我们将在21.1——操作符重载简介中讨论操作符重载。

{{< /alert >}}

***
## 过载解决方法简介

此外，当对已重载的函数进行函数调用时，编译器将基于函数调用中使用的参数，尝试将函数调用与适当的重载相匹配。这称为重载解析。

下面是一个简单的示例来演示这一点：

```C++
#include <iostream>

int add(int x, int y)
{
    return x + y;
}

double add(double x, double y)
{
    return x + y;
}

int main()
{
    std::cout << add(1, 2); // calls add(int, int)
    std::cout << '\n';
    std::cout << add(1.2, 3.4); // calls add(double, double)

    return 0;
}
```

上述程序编译并产生结果：

当我们在add（1，2）的调用中提供整数参数时，编译器将确定我们正在尝试调用add（int，int）。当我们在add（1.2，3.4）的调用中提供浮点参数时，编译器将确定我们正在尝试调用add（double，double）。

***
## 使其可编译

为了编译使用重载函数的程序，必须满足两个条件：

如果重载函数未区分，或者对重载函数的函数调用无法解析为重载函数，则将导致编译错误。

在下一课中，我们将探索如何区分重载函数。然后，在下一课中，我们将探索编译器如何将函数调用解析为重载函数。

***
## 结论

函数重载通过减少需要记住的函数名的数量，提供了一种减少程序复杂性的好方法。它可以而且应该自由使用。

{{< alert success >}}
**最佳做法**

使用函数重载使程序更简单。

{{< /alert >}}

