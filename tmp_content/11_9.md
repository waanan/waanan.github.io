---
title: "第10章总结和测验"
date: 2024-01-31T13:21:38+08:00
---

干得漂亮，走了这么远。标准转换规则相当复杂——如果您不理解每个细微差别，请不要担心。

***
## 章节回顾

将值从一种数据类型转换为另一种数据形式的过程称为类型转换。

只要需要一种数据类型，但提供了不同的数据类型，就执行隐式类型转换（也称为自动类型转换或强制）。如果编译器能够找出如何在这两种类型之间进行转换，它就会知道。如果它不知道如何操作，那么它将失败，并出现编译错误。

C++语言在其基本类型之间定义了许多内置转换（以及一些用于更高级类型的转换），称为标准转换。这些包括数字提升、数字转换和算术转换。

数值提升是将某些较小的数值类型转换为某些较大的数值类型（通常为int或double），以便CPU可以对与处理器的自然数据大小匹配的数据进行操作。数字促销包括积分促销和浮点促销。数字促销是保持价值的，这意味着不会损失价值或精度。并非所有扩大的转换都是促销。

数值转换是不是数值提升的基本类型之间的类型转换。窄化转换是可能导致值或精度丢失的数字转换。

在C++中，某些二进制运算符要求其操作数具有相同的类型。如果提供了不同类型的操作数，则使用一组称为常用算术转换的规则将其中一个或两个操作数隐式转换为匹配类型。

当程序员通过强制转换显式请求转换时，执行显式类型转换。强制转换表示程序员执行显式类型转换的请求。C++支持5种类型的转换：C样式转换、静态转换、常量转换、动态转换和重新解释转换。通常，应避免C样式转换、常量转换和重新解释转换。static_cast用于将值从一种类型转换为另一种类型的值，并且是迄今为止C++中使用最多的转换。

Typedef和类型别名允许程序员为数据类型创建别名。这些别名不是新类型，其行为与别名类型相同。Typedef和类型别名不提供任何类型的类型安全，需要注意不要假设别名与其别名的类型不同。

auto关键字有许多用法。首先，auto可以用于进行类型推导（也称为类型推理），这将从变量的初始值设定项中推导变量的类型。类型演绎会删除常量和引用，因此如果需要，请确保将它们添加回。

Auto也可以用作函数返回类型，以使编译器从函数的返回语句推断函数的返回类型，尽管对于普通函数应该避免这种情况。Auto用作尾部返回语法的一部分。

***
## 测验时间

问题#1

在以下每种情况下发生哪种类型的转换？有效的答案是：不需要转换，数值提升，数值转换，由于缩小转换而无法编译。假设int和long都是4个字节。

```C++
int main()
{
    int a { 5 }; // 1a
    int b { 'a' }; // 1b
    int c { 5.4 }; // 1c
    int d { true }; // 1d
    int e { static_cast<int>(5.4) }; // 1e

    double f { 5.0f }; // 1f
    double g { 5 }; // 1g

    // Extra credit section
    long h { 5 }; // 1h

    float i { f }; // 1i (uses previously defined variable f)
    float j { 5.0 }; // 1j

}
```

1a）展示解决方案

1b）展示解决方案

1c）展示解决方案

1d）展示解决方案

1e）展示解决方案

1f）展示解决方案

1g）展示解决方案

1h）展示解决方案

1i）展示解决方案

1j）展示解决方案

问题#2

2a）使用类型别名升级以下程序：

```C++
#include <iostream>

namespace constants
{
    inline constexpr double pi { 3.14159 };
}

double convertToRadians(double degrees)
{
    return degrees * constants::pi / 180;
}

int main()
{
    std::cout << "Enter a number of degrees: ";
    double degrees{};
    std::cin >> degrees;

    double radians { convertToRadians(degrees) };
    std::cout << degrees << " degrees is " << radians << " radians.\n";

    return 0;
}
```

显示解决方案

2b）给出上一个测验解决方案中度数和弧度的定义，解释为什么以下语句会编译或不会编译：

```C++
radians = degrees;
```

显示解决方案

