---
title: "作用域枚举（枚举类）"
date: 2024-03-08T13:20:57+08:00
---

尽管非范围枚举在C++中是不同的类型，但它们不是类型安全的，并且在某些情况下允许您做一些没有意义的事情。考虑以下情况：

```C++
#include <iostream>

int main()
{
    enum Color
    {
        red,
        blue,
    };

    enum Fruit
    {
        banana,
        apple,
    };
	
    Color color { red };
    Fruit fruit { banana };

    if (color == fruit) // The compiler will compare color and fruit as integers
        std::cout << "color and fruit are equal\n"; // and find they are equal!
    else
        std::cout << "color and fruit are not equal\n";

    return 0;
}
```

这将打印：

当比较颜色和水果时，编译器将查看它是否知道如何比较颜色和果实。它不会。接下来，它将尝试将Color和/或Fruit转换为整数，以查看是否可以找到匹配项。最终，编译器将确定，如果它将两者转换为整数，则可以进行比较。由于颜色和水果都被设置为枚举数，这些枚举数转换为整数值0，因此颜色将等于水果。

这在语义上没有意义，因为颜色和水果来自不同的枚举，并且不打算进行比较。有了标准的枚举器，就没有简单的方法来防止这种情况。

由于这样的挑战，以及命名空间污染问题（在全局范围中定义的非范围枚举将其枚举器放在全局命名空间中），C++设计者决定使用更干净的枚举解决方案。

***
## 作用域枚举

该解决方案是作用域枚举（在C++中通常称为枚举类，原因很快就会显而易见）。

作用域枚举的工作方式类似于非作用域枚举（13.2——未作用域枚举），但有两个主要区别：它们不会隐式转换为整数，并且枚举器仅放在枚举的作用域区域中（而不是放在定义枚举的作用区域中）。

为了进行作用域枚举，我们使用关键字enum类。范围枚举定义的其余部分与非范围枚举定义相同。下面是一个示例：

```C++
#include <iostream>
int main()
{
    enum class Color // "enum class" defines this as a scoped enumeration rather than an unscoped enumeration
    {
        red, // red is considered part of Color's scope region
        blue,
    };

    enum class Fruit
    {
        banana, // banana is considered part of Fruit's scope region
        apple,
    };

    Color color { Color::red }; // note: red is not directly accessible, we have to use Color::red
    Fruit fruit { Fruit::banana }; // note: banana is not directly accessible, we have to use Fruit::banana
	
    if (color == fruit) // compile error: the compiler doesn't know how to compare different types Color and Fruit
        std::cout << "color and fruit are equal\n";
    else
        std::cout << "color and fruit are not equal\n";

    return 0;
}
```

该程序在第19行产生编译错误，因为作用域枚举不会转换为任何可以与其他类型进行比较的类型。

{{< alert success >}}
**作为旁白…**

类关键字（与静态关键字一起）是C++语言中最重载的关键字之一，根据上下文的不同，可以有不同的含义。尽管作用域枚举使用class关键字，但它们不被认为是“类类型”（为结构、类和联合保留）。

枚举结构也在此上下文中工作，并且行为与枚举类相同。然而，枚举结构的使用是非惯用的，因此请避免使用它。

{{< /alert >}}

***
## 作用域枚举定义自己的作用域区域

非范围枚举将其枚举数放在与枚举本身相同的范围内，与此不同，范围枚举仅将其枚举器放在枚举的范围区域中。换句话说，作用域枚举充当其枚举器的命名空间。此内置命名空间有助于减少全局命名空间污染，以及在全局范围中使用范围枚举时发生名称冲突的可能性。

要访问作用域枚举器，我们这样做就像它位于与作用域枚举同名的命名空间中一样：

```C++
#include <iostream>

int main()
{
    enum class Color // "enum class" defines this as a scoped enum rather than an unscoped enum
    {
        red, // red is considered part of Color's scope region
        blue,
    };

    std::cout << red << '\n';        // compile error: red not defined in this scope region
    std::cout << Color::red << '\n'; // compile error: std::cout doesn't know how to print this (will not implicitly convert to int)

    Color color { Color::blue }; // okay

    return 0;
}
```

由于作用域枚举为枚举器提供了自己的隐式命名空间，因此没有必要将作用域枚举放在另一个作用域区域（如命名空间）中，除非有其他令人信服的理由这样做，因为这样做是多余的。

***
## 作用域枚举不隐式转换为整数

与非范围枚举器不同，范围枚举器不会隐式转换为整数。在大多数情况下，这是一件好事，因为这样做很少有意义，并且它有助于防止语义错误，例如比较来自不同枚举的枚举数或表达式（如red+5）。

请注意，您仍然可以比较同一范围枚举中的枚举器（因为它们属于同一类型）：

```C++
#include <iostream>
int main()
{
    enum class Color
    {
        red,
        blue,
    };

    Color shirt { Color::red };

    if (shirt == Color::red) // this Color to Color comparison is okay
        std::cout << "The shirt is red!\n";
    else if (shirt == Color::blue)
        std::cout << "The shirt is blue!\n";

    return 0;
}
```

有时，能够将作用域枚举器视为整数值是有用的。在这些情况下，可以使用static_cast将作用域枚举器显式转换为整数。C++23中更好的选择是使用std:：to_underlying（）（在<utility>头中定义），它将枚举器转换为枚举的底层类型的值。

```C++
#include <iostream>
#include <utility> // for std::to_underlying() (C++23)

int main()
{
    enum class Color
    {
        red,
        blue,
    };

    Color color { Color::blue };

    std::cout << color << '\n'; // won't work, because there's no implicit conversion to int
    std::cout << static_cast<int>(color) << '\n';   // explicit conversion to int, will print 1
    std::cout << std::to_underlying(color) << '\n'; // convert to underlying type, will print 1 (C++23)

    return 0;
}
```

相反，您也可以将整数static_cast为作用域枚举器，这在从用户进行输入时非常有用：

```C++
#include <iostream>

int main()
{
    enum class Pet
    {
        cat, // assigned 0
        dog, // assigned 1
        pig, // assigned 2
        whale, // assigned 3
    };

    std::cout << "Enter a pet (0=cat, 1=dog, 2=pig, 3=whale): ";

    int input{};
    std::cin >> input; // input an integer

    Pet pet{ static_cast<Pet>(input) }; // static_cast our integer to a Pet

    return 0;
}
```

从C++17开始，您可以使用不带static_cast的整数值来列出初始化作用域枚举（与非作用域枚举不同，您不需要指定基）。

尽管作用域枚举提供了好处，但在C++中仍然通常使用非作用域枚举，因为在某些情况下，我们希望隐式转换为int（执行大量static_casting会很烦人），并且我们不需要额外的命名空间。

{{< alert success >}}
**最佳做法**

支持范围枚举而不是非范围枚举，除非有令人信服的理由这样做。

{{< /alert >}}

***
## 简化范围枚举器到整数的转换（高级）

作用域枚举很好，但缺乏对整数的隐式转换有时可能是一个痛点。如果我们需要经常将作用域枚举转换为整数（例如，在我们希望使用作用域枚举器作为数组索引的情况下），则每次需要转换时都必须使用static_cast可能会显著地扰乱代码。

如果您发现自己处于这样一种情况，即更容易地将作用域枚举器转换为整数是有用的，那么一种有用的方法是重载一元运算符+来执行此转换。我们还没有解释这是如何工作的，所以现在认为它很神奇：

```C++
#include <iostream>
#include <type_traits> // for std::underlying_type_t

enum class Animals
{
    chicken, // 0
    dog, // 1
    cat, // 2
    elephant, // 3
    duck, // 4
    snake, // 5

    maxAnimals,
};

// Overload the unary + operator to convert Animals to the underlying type
// adapted from https://stackoverflow.com/a/42198760, thanks to Pixelchemist for the idea
constexpr auto operator+(Animals a) noexcept
{
    return static_cast<std::underlying_type_t<Animals>>(a);
}

int main()
{
    std::cout << +Animals::elephant << '\n'; // convert Animals::elephant to an integer using unary operator+

    return 0;
}
```

这将打印：

该方法可以防止意外的隐式转换为整数类型，但提供了一种根据需要显式请求此类转换的方便方法。

***
## 使用枚举语句C++20

在C++20中引入了using枚举语句，该语句将枚举中的所有枚举数导入到当前作用域中。与枚举类类型一起使用时，这允许我们访问枚举类枚举器，而不必为每个枚举类的名称添加前缀。

在我们将有许多相同、重复的前缀的情况下，例如在switch语句中，这可能很有用：

```C++
#include <iostream>
#include <string_view>

enum class Color
{
    black,
    red,
    blue,
};

constexpr std::string_view getColor(Color color)
{
    using enum Color; // bring all Color enumerators into current scope (C++20)
    // We can now access the enumerators of Color without using a Color:: prefix

    switch (color)
    {
    case black: return "black"; // note: black instead of Color::black
    case red:   return "red";
    case blue:  return "blue";
    default:    return "???";
    }
}

int main()
{
    Color shirt{ Color::blue };

    std::cout << "Your shirt is " << getColor(shirt) << '\n';

    return 0;
}
```

在上面的示例中，Color是一个枚举类，因此我们通常会使用完全限定的名称（例如，Color:：blue）来访问枚举器。然而，在函数getColor（）中，我们使用enum Color；添加了语句；，它允许我们在没有Color:：前缀的情况下访问这些枚举器。

这就避免了在switch语句中有多个冗余的明显前缀。

***
## 测验时间

问题#1

定义一个名为Animal的枚举类，该类包含以下动物：猪、鸡、山羊、猫、狗、鸭。编写一个名为getAnimalName（）的函数，该函数接受Animal参数，并使用switch语句以std:：string_view（如果您使用的是C++14，则返回该动物的名称）。编写另一个名为printNumberOfLegs（）的函数，该函数使用switch语句来打印每个动物行走的腿数。确保两个函数都具有打印错误消息的默认大小写。用猫和鸡从main（）调用printNumberOfLegs（）。您的输出应如下所示：

显示解决方案

