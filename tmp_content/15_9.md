---
title: "构造函数成员初始值设定项列表"
date: 2024-04-09T13:02:20+08:00
---

本课继续介绍第14.9课——构造函数简介中的构造函数。

***
## 通过成员初始化列表进行成员初始化

为了让构造函数初始化成员，我们使用成员初始值设定项列表（通常称为“成员初始化列表”）来进行初始化。不要将其与类似名称的“初始值设定项列表”混淆，该列表用于用值列表初始化聚合。

成员初始化列表是最好通过示例学习的东西。在下面的示例中，我们的Foo（int，int）构造函数已更新为使用成员初始值设定项列表来初始化m_x和m_y：

```C++
#include <iostream>

class Foo
{
private:
    int m_x {};
    int m_y {};

public:
    Foo(int x, int y)
        : m_x { x }, m_y { y } // here's our member initialization list
    {
        std::cout << "Foo(" << x << ", " << y << ") constructed\n";
    }

    void print() const
    {
        std::cout << "Foo(" << m_x << ", " << m_y << ")\n";
    }
};

int main()
{
    Foo foo{ 6, 7 };
    foo.print();

    return 0;
}
```

成员初始值设定项列表在构造函数参数之后定义。它以冒号（：）开头，然后列出要初始化的每个成员以及该变量的初始化值，用逗号分隔。这里必须使用直接形式的初始化（最好使用大括号，但括号也可以）——这里不能使用复制初始化（带等号）。还要注意，成员初始值设定项列表不会以分号结尾。

该程序产生以下输出：

实例化foo时，使用指定的初始化值初始化初始化列表中的成员。在这种情况下，成员初始值设定项列表将m_x初始化为x的值（6），将m_y初始化为y的值（7）。然后运行构造函数的主体。

当调用print（）成员函数时，可以看到m_x仍然具有值6，m_y仍然具有值7。

***
## 成员初始值设定项列表格式

C++提供了很大的自由来根据您的喜好格式化成员初始值设定项列表，因为它不关心冒号、逗号或空白的位置。

以下样式都有效（在实践中您可能会看到这三种样式）：

```C++
    Foo(int x, int y) : m_x { x }, m_y { y }
    {
    }
```

```C++
    Foo(int x, int y) :
        m_x { x },
        m_y { y }
    {
    }
```

```C++
    Foo(int x, int y)
        : m_x { x }
        , m_y { y }
    {
    }
```

我们建议使用上面的第三种样式：

1. 将冒号放在构造函数名称后面的行上，因为这将成员初始值设定项列表与函数原型清晰地分开。
2. 缩进成员初始值设定项列表，以便更容易看到函数名。


如果成员初始化列表简短/琐碎，则所有初始值设定项都可以放在一行上：

```C++
    Foo(int x, int y)
        : m_x { x }, m_y { y }
    {
    }
```

否则（或者如果愿意），每个成员和初始值设定项对可以放在单独的一行上（以逗号开头以保持对齐）：

```C++
    Foo(int x, int y)
        : m_x { x }
        , m_y { y }
    {
    }
```

***
## 成员初始化顺序

因为C++标准是这样说的，所以成员初始值设定项列表中的成员总是按照它们在类中定义的顺序进行初始化（而不是按照它们在成员初始值设置项列表中定义的次序）。

在上面的示例中，由于m_x在类定义中定义在m_y之前，因此m_x将首先初始化（即使它没有在成员初始值设定项列表中首先列出）。

因为我们直观地期望从左到右初始化变量，这可能会导致发生细微的错误。考虑以下示例：

```C++
#include <algorithm> // for std::max
#include <iostream>

class Foo
{
private:
    int m_x{};
    int m_y{};

public:
    Foo(int x, int y)
        : m_y{ std::max(x, y) }, m_x{ m_y } // issue on this line
    {
    }

    void print() const
    {
        std::cout << "Foo(" << m_x << ", " << m_y << ")\n";
    }
};

int main()
{
    Foo foo{ 6, 7 };
    foo.print();

    return 0;
}
```

在上面的示例中，我们的意图是计算传入的初始化值中较大的一个（通过std:：max（x，y）），然后使用该值初始化m_x和m_y。然而，在作者的计算机上，将打印以下结果：

```C++
Foo(-858993460, 7)
```

发生了什么事？尽管m_y在成员初始化列表中列在第一位，但由于m_x是在类中首先定义的，因此m_x首先被初始化。m_x被初始化为m_y的值，该值尚未初始化。最后，m_y被初始化为较大的初始化值。

为了帮助防止这种错误，成员初始值设定项列表中的成员应该按照它们在类中定义的顺序列出。如果成员的初始化顺序不正确，某些编译器将发出警告。

最好避免使用其他成员的值初始化成员（如果可能）。这样，即使您确实在初始化顺序中出错，也不重要，因为初始化值之间没有依赖关系。

{{< alert success >}}
**最佳做法**

应按在类中定义成员初始值设定项列表中的成员变量的顺序列出它们。

{{< /alert >}}

***
## 成员初始值设定项列表与默认成员初始值设置项

可以用几种不同的方法初始化成员：

1. 如果成员在成员初始值设定项列表中列出，则使用该初始化值
2. 否则，如果成员具有默认的成员初始值设定项，则使用该初始化值
3. 否则，该成员将默认初始化。


这意味着，如果成员既有默认成员初始值设定项，又列在构造函数的成员初始值设置项列表中，则成员初始值设项列表值优先。

下面是一个显示所有三种初始化方法的示例：

```C++
#include <iostream>

class Foo
{
private:
    int m_x{};    // default member initializer (will be ignored)
    int m_y{ 2 }; // default member initializer (will be used)
    int m_z;      // no initializer

public:
    Foo(int x)
        : m_x{ x } // member initializer list
    {
        std::cout << "Foo constructed\n";
    }

    void print() const
    {
        std::cout << "Foo(" << m_x << ", " << m_y << ", " << m_z << ")\n";
    }
};

int main()
{
    Foo foo{ 6 };
    foo.print();

    return 0;
}
```

在作者的机器上，此输出：

下面是正在发生的事情。构造foo时，成员初始值设定项列表中仅显示m_x，因此m_x首先初始化为6。my不在成员初始化列表中，但它具有默认的成员初始值设定项，因此它被初始化为2。mz既不在成员初始化列表中，也没有默认的成员初始值设定项，因此它是默认初始化的（对于基本类型，这意味着它未被初始化）。因此，当我们打印m_z的值时，我们得到未定义的行为。

***
## 构造函数功能体

构造函数函数的主体通常为空。这是因为我们主要使用构造函数进行初始化，这是通过成员初始值设定项列表完成的。如果这就是我们需要做的所有事情，那么我们不需要在构造函数的主体中使用任何语句。

然而，由于构造函数体中的语句在成员初始值设定项列表执行后执行，因此我们可以添加语句来执行所需的任何其他设置任务。在上面的示例中，我们将一些内容打印到控制台，以显示构造函数已执行，但我们可以执行其他操作，如打开文件或数据库、分配内存等…

新程序员有时使用构造函数的主体将值分配给成员：

```C++
#include <iostream>

class Foo
{
private:
    int m_x{};
    int m_y{};

public:
    Foo(int x, int y)
    {
        m_x = x; // incorrect: this is an assignment, not an initialization
        m_y = y; // incorrect: this is an assignment, not an initialization
    }

    void print() const
    {
        std::cout << "Foo(" << m_x << ", " << m_y << ")\n";
    }
};

int main()
{
    Foo foo{ 6, 7 };
    foo.print();

    return 0;
}
```

尽管在这种简单的情况下，这将产生预期的结果，但在需要初始化成员的情况下（例如，对于常量或引用的数据成员），分配将不起作用。

{{< alert success >}}
**最佳做法**

与在构造函数主体中分配值相比，更喜欢使用成员初始值设定项列表来初始化成员。

{{< /alert >}}

***
## 测验时间

问题#1

写一个名为Ball的类。球应该有两个私有成员变量，一个用于保存颜色，另一个用于保持半径。还要编写一个函数来打印球的颜色和半径。

应编译以下示例程序：

```C++
int main()
{
	Ball blue{ "blue", 10.0 };
	print(blue);

	Ball red{ "red", 12.0 };
	print(red);

	return 0;
}
```

并产生结果：

显示解决方案

问题#2

为什么我们使print（）成为非成员函数而不是成员函数？

显示解决方案

问题#3

为什么我们将m_color设置为std:：string而不是std::string_view？

显示解决方案

