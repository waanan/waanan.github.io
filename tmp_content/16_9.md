---
title: "引用限定符"
date: 2024-06-24T18:56:16+08:00
---

在第14.7课——返回对数据成员的引用的成员函数中，我们讨论了当隐式对象是右值时，调用返回对数据构件的引用的访问函数是如何危险的。下面简要回顾一下：

```C++
#include <iostream>
#include <string>
#include <string_view>

class Employee
{
private:
	std::string m_name{};

public:
	Employee(std::string_view name): m_name { name } {}
	const std::string& getName() const { return m_name; } //  getter returns by const reference
};

// createEmployee() returns an Employee by value (which means the returned value is an rvalue)
Employee createEmployee(std::string_view name)
{
	Employee e { name };
	return e;
}

int main()
{
	// Case 1: okay: use returned reference to member of rvalue class object in same expression
	std::cout << createEmployee("Frank").getName() << '\n';

	// Case 2: bad: save returned reference to member of rvalue class object for use later
	const std::string& ref { createEmployee("Garbo").getName() }; // reference becomes dangling when return value of createEmployee() is destroyed
	std::cout << ref << '\n'; // undefined behavior

	return 0;
}
```

在案例2中，从createEmployee（“Garbo”）返回的rvalue对象在初始化ref后被销毁，使ref引用刚被销毁的数据成员。ref的后续使用显示未定义的行为。

这有点棘手。

1. 如果我们的getName（）函数按值返回，则当隐式对象是右值时，这是安全的，但当我们的隐式对象为左值时（这是最常见的情况），会生成昂贵且不必要的副本。
2. 如果我们的getName（）函数通过常量引用返回，则这是有效的（因为没有生成std:：string的副本），但当隐式对象是右值时，可能会被误用（导致未定义的行为）。


由于成员函数通常在左值隐式对象上调用，因此传统的选择是通过常量引用返回，并在隐式对象是右值的情况下简单地避免误用返回的引用。

{{< alert success >}}
**作者注释**

这是一节选修课。我们建议您稍微通读一下，以熟悉材料，但不需要全面理解来继续学习未来的课程。

{{< /alert >}}

***
## 引用限定符

上述挑战的根源是，我们只希望一个函数服务于两种不同的情况（一种是隐式对象是左值，另一种是隐含对象是右值）。一种情况下的最佳方案对另一种情况并不理想。

为了帮助解决这些问题，C++11引入了一个鲜为人知的特性，称为ref限定符，它允许我们根据是在左值还是右值隐式对象上调用成员函数来重载它。使用这个特性，我们可以创建getName（）的两个版本——一个用于隐式对象是左值的情况，另一个用于我们的隐式对象为右值的情况。

首先，让我们从getName（）的非ref限定版本开始

```C++
std::string& getName() const { return m_name; } // callable with both lvalue and rvalue implicit objects
```

为了引用限定此函数，我们将一个&限定符添加到只匹配左值隐式对象的重载中，并将一个&&限定符加到只匹配右值隐式目标的重载中：

```C++
const std::string& getName() const &  { return m_name; } //  & qualifier overloads function to match only lvalue implicit objects, returns by reference
std::string        getName() const && { return m_name; } // && qualifier overloads function to match only rvalue implicit objects, returns by value
```

因为这些函数是不同的重载，所以它们可以有不同的返回类型！左值限定重载通过常量引用返回，而右值限定重载则通过值返回。

下面是上面的完整示例：

```C++
#include <iostream>
#include <string>
#include <string_view>

class Employee
{
private:
	std::string m_name{};

public:
	Employee(std::string_view name): m_name { name } {}

	const std::string& getName() const &  { return m_name; } //  & qualifier overloads function to match only lvalue implicit objects
	std::string        getName() const && { return m_name; } // && qualifier overloads function to match only rvalue implicit objects
};

// createEmployee() returns an Employee by value (which means the returned value is an rvalue)
Employee createEmployee(std::string_view name)
{
	Employee e { name };
	return e;
}

int main()
{
	Employee joe { "Joe" };
	std::cout << joe.getName() << '\n'; // Joe is an lvalue, so this calls std::string& getName() & (returns a reference)
    
	std::cout << createEmployee("Frank").getName() << '\n'; // Frank is an rvalue, so this calls std::string getName() && (makes a copy)

	return 0;
}
```

这允许我们在隐式对象是左值时做表现性的事情，而在隐式目标是右值时做安全的事情。

{{< alert success >}}
**对于高级读者**

当隐式对象是非常量临时对象时，从性能角度来看，上面的getName（）的上述rvalue重载可能是次优的。在这种情况下，隐式对象无论如何都将在表达式末尾死亡。因此，我们可以让它尝试移动成员（使用std:：move），而不是让rvalue getter返回成员的副本（可能很昂贵）。

这可以通过为非常量值添加以下重载getter来实现：

```C++
        // If the implicit object is a non-const rvalue, use std::move to try to move m_name
	std::string getName() && { return std::move(m_name); }
```

这既可以与const rvalue getter共存，也可以直接使用它（因为const rval相当少见）。

我们在第22.4课中介绍了std:：move——std:∶move。

{{< /alert >}}

***
## 关于ref限定成员函数的一些注释

首先，对于给定的函数，非ref限定重载和ref限定过载不能共存。使用一个或另一个。

其次，如果仅提供左值限定重载（即未定义右值限定版本），则对具有右值隐式对象的函数的任何调用都将导致编译错误。这提供了一种有用的方法，可以完全防止将函数与右值隐式对象一起使用。

***
## 那么，我们为什么不建议使用ref限定符呢？

虽然ref限定符很整洁，但以这种方式使用它们有一些缺点。

1. 向每个返回引用的getter添加rvalue重载会给类增加混乱，以减轻不常见的情况，并且通过良好的习惯很容易避免。
2. 通过值返回rvalue重载意味着我们必须支付复制（或移动）的成本，即使在我们可以安全使用引用的情况下（例如，在课程顶部的示例的情况1）。


此外：

1. 大多数C++开发人员都不知道该功能（这可能会导致错误或使用效率低下）。
2. 标准库通常不使用此功能。


基于以上所有内容，我们不建议将ref限定符用作最佳实践。相反，我们建议始终立即使用访问函数的结果，而不要保存返回的引用以供以后使用。

