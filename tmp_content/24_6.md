---
title: "标准：：initializer_list"
date: 2024-10-08T17:40:35+08:00
---

考虑C++中的固定整数数组：int array[5]；如果我们想用值初始化这个数组，可以通过初始化器列表语法直接这样做：#include<iostream>intmain（）{intarray[]{5，4，3，2，1}；//（auto-i:array）std:：cout<<i<<''的初始值设定项列表；返回0；}这会打印：5 4 3 2 1这也适用于动态分配的数组：#include<iostream>intmain（）{auto*array{newint[5]{5，4，3，2，1}}；//（int count{0}；count<5；++count）std:：cout<<array[count]<<''；的初始值设定项列表；删除[]数组；返回0；}在上一课中，我们介绍了容器类的概念，并展示了保存整数数组的IntArray类的示例：#include<cassert>//for assert（）#incluse<iostream>class IntArray{private:intm_length{}；整数*m_data{}；public:IntArray（）=默认值；IntArray（int length）：m_length{length}，m_data{new int[static_cast<std:：size_t>（length；intmain（）{//如果尝试将初始值设定项列表与该容器类一起使用会发生什么？IntArray数组{5，4，3，2，1}；//此行不为（int count{0}；count<5；++count）std:：cout<<array[count]<<''；返回0；}这段代码不会编译，因为IntArray类没有知道如何处理初始值设定项列表的构造函数。因此，我们需要单独初始化数组元素：int main（）{IntArray数组（5）；数组[0]=5；数组[1]=4；数组[2]=3；数组[3]=2；数组[4]=1；for（int count{0}；count<5；++count）std:：cout<<array[count]<<''；返回0；}那不太好。使用std:：initializer_list进行类初始化当编译器看到初始值设定项列表时，它会自动将其转换为类型为std::initialize_list的对象。因此，如果我们创建一个接受std:：initializer_list参数的构造函数，我们可以使用初始化器列表作为输入来创建对象。关于std:：initializer_list，有几点需要了解。与std:：array或std:∶vector很相似，您必须使用尖括号告诉std::initializer_list列表保存的数据类型，除非您立即初始化std:。因此，您几乎永远不会看到普通的std:：initializer_list。相反，您将看到类似于std:：initializer_list<int>或std:∶initialize_list<std::string>的内容。其次，std:：initializer_list有一个（命名错误）size（）函数，该函数返回列表中的元素数。当我们需要知道传入的列表的长度时，这很有用。第三，std:：initializer_list通常通过值传递。与std:：string_view很相似，std::initializer_list是一个视图。复制std:：initializer_list不会复制列表中的元素。让我们看看如何使用接受std:：initializer_list的构造函数更新IntArray类#include<algorithm>//对于std:：copy#include<cassert>//对于assert（）#incluse<initializer_list>//对于std:：initialize_list#incl包括<iostream>类IntArray{private:int m_length{}；整数*m_data{}；public:IntArray（）=默认值；IntArray（int length）：m_length{length}，m_data{new int[static_cast<std:：size_t>（length这里需要将m_data设置为null或将m_length设置为0，因为对象将在该函数之后立即销毁}IntArray（const IntArray&）=delete；//以避免浅层复制IntArray&operator=（const IntArrary&list）=delete；//为了避免浅层复制，int&operator[]（int索引）{assert（index>=0&&index<m_length）；return m_data[index]；}int getLength（）const{return m_length；}}；int main（）{IntArray数组{5，4，3，2，1}；//（int count{0}；count<array.getLength（）；的初始值设定项列表++count）标准：：cout<<array[count]<<''；返回0；}这产生了预期的结果：5 4 3 2 1它工作！现在，让我们更详细地探讨一下这一点。这是我们的IntArray构造函数，它接受std:：initializer_list<int>.IntArray（std::initialize_list<int>list）//允许通过列表初始化来初始化IntArray：IntArray（static_cast<int>（list.size（）））//使用委托构造函数来设置初始数组{//现在从列表std:∶copy：copy（list.begin（），list.end（），m_data）初始化数组；}在第1行：如上所述，我们必须使用尖括号来表示列表中预期的元素类型。在这种情况下，因为这是一个IntArray，所以我们希望用int填充列表。请注意，我们不会通过常量引用传递列表。与std:：string_view非常相似，std::initializer_list非常轻量级，并且复制往往比间接方法便宜。第2行：我们通过委托构造函数将IntArray的内存分配委托给另一个构造函数（以减少冗余代码）。另一个构造函数需要知道数组的长度，因此我们传递它list.size（），它包含列表中元素的数量。请注意，list.size（）返回一个size_t（无符号），因此我们需要在这里转换为有符号的int。构造函数的主体保留用于将元素从列表复制到IntArray类中。最简单的方法是使用std:：copy（），它位于<algorithm>头中。访问std:：initializer_list的元素在某些情况下，您可能希望在将std:initialize_list的每个元素复制到内部数组之前访问该元素（例如，检查健全性值，或以某种方式修改这些值）。由于某些无法解释的原因，std:：initializer_list不通过下标（运算符[]）提供对列表元素的访问。这一遗漏已多次向标准委员会提出，但从未得到解决。然而，有许多简单的解决方法：您可以使用基于范围的for循环来迭代列表的元素。另一种方法是使用begin（）成员函数获取std:：initializer_list的迭代器。由于此迭代器是随机访问迭代器，因此可以索引迭代器：IntArray（std:：initializer_list<int>list）//允许通过列表初始化初始化IntArray：IntArray（static_cast<int>（list.size（）））//使用委托构造函数设置初始数组{//现在从的列表初始化数组（std::：size_t count{}；count<list.size（）++count）{m_data[count]=list.begin（）[count]；}}列表初始化优先于列表构造函数而不是非列表构造函数非空初始值设定项列表将始终优先于匹配的initializer_list构造函数而不是其他可能匹配的构造函数。考虑：IntArray a1（5）；//使用IntArray（int），分配大小为5的数组IntArray a2{5}；//使用IntArray<std:：initializer_list<int>，分配大小为1的数组。a1情况使用直接初始化（不考虑列表构造函数），因此该定义将调用IntArray（int），分配大小5的数组。a2情况使用列表初始化（有利于列表构造函数）。在这里，IntArray（int）和IntArray（std:：initializer_list<int>）都是可能的匹配，但由于列表构造函数是受欢迎的，因此将调用IntArray，分配大小为1的数组（该元素的值为5）。这就是为什么我们上面的委托构造函数在委托时使用直接初始化：IntArray。如果我们使用列表初始化进行委托，构造函数将尝试委托给自己，这将导致编译错误。同样的情况也发生在std:：vector和其他容器类上，这些容器类同时具有列表构造函数和具有类似类型参数的构造函数td:：vector<int>array（5）；//调用std:：vector:：vector（std:∶vector:∶size_type），5个值初始化的元素：0 0 0 0 std::vector<int>array{5}；//调用std:：vector:：vector（std:：initializer_list<int>），1 element:5Key insightList初始化倾向于匹配列表构造函数，而不是匹配非列表构造函数。最佳实践当初始化具有列表构造函数的容器时：当打算调用列表构造函数时使用大括号初始化（例如，因为您的初始值设定项是元素值）当打算调用非列表构造函数时，使用直接初始化（例如因为您的初始值设定项不是元素值）。向现有类中添加列表构造函数是危险的，因为列表初始化倾向于列表构造函数，因此将列表构造函数添加到以前没有的现有类中可能会导致现有程序以静默方式更改行为。考虑以下程序：#include<initializer_list>//for std:：initialize_list#incluse<iostream>class Foo{public:Foo（int，int）{std::cout<<“Foo（in，int）”<<'\n'；}}；int main（）{Foo f1{1，2}；//调用Foo（int，int）返回0；}这会打印：Foo（int，int）现在，让我们向该类添加一个列表构造函数：#include<initializer_list>//for std:：initialize_list#incluse<iostream>class Foo{public:Foo（int，int）{std:∶cout<<“Foo（in，int）”<<'\n'；}//我们已经添加了一个列表构造器Foo（std:；int main（）{//注意，下面的语句没有更改Foo f1{1，2}；//现在调用Foo（std:：initializer_list<int>）返回0；}尽管我们没有对程序进行其他更改，但该程序现在打印：Foo（std:：initializer_list<int>）Warning将列表构造函数添加到没有列表构造函数的现有类中可能会破坏现有程序。使用std:：initializer_list进行类赋值您还可以使用std::initialize_list通过重载赋值运算符来获取std::initializer _list参数，从而将新值分配给类。这与上面的工作类似。我们将在下面的测试解决方案中展示如何做到这一点的示例。请注意，如果实现采用std:：initializer_list的构造函数，则应确保至少执行以下操作之一：提供重载的列表赋值运算符提供适当的深度复制复制赋值运算符删除复制赋值操作符原因如下：考虑以下类（它没有任何这些内容），以及列表赋值语句：#include<algorithm>//for std::copy（）#incluse<cassert>//for assert；整数*m_data{}；public:IntArray（）=默认值；IntArray（int length）：m_length{length}，m_data{new int[static_cast<std:：size_t>（length数组（const IntArray&）=删除；//以避免浅层复制//IntArray&operator=（const IntArrary&list）=delete；//为了避免浅层复制，int&operator[]（int索引）{assert（index>=0&&index<m_length）；return m_data[index]；}int getLength（）const{return m_length；}}；int main（）{IntArray数组{}；数组={1,3,5,7,9,11}；//下面是（intcount{0}；count<array.getLength（）；的列表赋值语句++count）标准：：cout<<array[count]<<''；//未定义的行为返回0；}首先，编译器将注意到采用std:：initializer_list的赋值函数不存在。接下来，它将查找它可以使用的其他赋值函数，并发现隐式提供的复制赋值运算符。然而，此函数只能在它可以将初始值设定项列表转换为IntArray时使用。由于{1,3,5,7,9,11}是std:：initializer_list，编译器将使用列表构造函数将初始值设定项列表转换为临时IntArray。然后它将调用隐式赋值操作符，该操作符将临时IntArray浅层复制到数组对象中。此时，临时IntArray的m_data和array->m_data都指向相同的地址（由于浅拷贝）。你已经知道这是怎么回事了。在赋值语句的末尾，临时IntArray被销毁。它调用析构函数，该析构函数删除临时IntArray的m_data。这将使array->m_data成为悬空指针。当您尝试将array->m_data用于任何目的时（包括当数组超出范围并且析构函数删除m_data.），您将得到未定义的行为。最佳实践如果您提供列表构造，最好也提供列表分配。Summary实现接受std:：initializer_list参数的构造函数允许我们对自定义类使用列表初始化。我们还可以使用std:：initializer_list实现需要使用初始值设定项列表的其他函数，如赋值运算符。测验timeQuestion#1使用上面的IntArray类，实现接受初始值设定项列表的重载赋值运算符。应该运行以下代码：intmain（）{IntArray数组{5，4，3，2，1}；//（int count{0}；count<array.getLength（）；的初始值设定项列表++count）标准：：cout<<array[count]<<''；标准：：cout<<'\n'；数组={1,3,5,7,9,11}；for（整数计数{0}；计数<array.getLength（）++count）标准：：cout<<array[count]<<''；标准：：cout<<'\n'；返回0；}这应该会打印：5 4 3 2 1 1 3 5 7 9 11显示解决方案#include<algorithm>//对于std:：copy（）#incluse<cassert>//对于assert（）#include<initializer_list>//对于std:：initializer _list#incl包括<iostream>class IntArray{private:int m_length{}；整数*m_data{}；public:IntArray（）=默认值；IntArray（int length）：m_length{length}，m_data{new int[static_cast<std:：size_t>（length这里需要将m_data设置为null或将m_length设置为0，因为对象将在该函数之后立即销毁}IntArray（const IntArray&）=delete；//以避免浅层复制IntArray&operator=（const IntArrary&list）=delete；//为了避免浅层复制，IntArray&operator=（std:：initializer_list<int>list）{//如果新列表的大小不同，请将其重新分配为int length{static_cast<int>（list.size（））}；if（长度！=m_length）{delete[]m_data；m_lendth=length；m_data=new int[list.size（）]{}；}//现在从列表std:：copy（list.begin（），list.end（），m_data）初始化数组；返回*this；}int&operator[]（int索引）{assert（索引>=0&&索引<m_length）；返回m_data[index]；}int getLength（）const{return m_length；}}；int main（）{IntArray数组{5，4，3，2，1}；//（int count{0}；count<array.getLength（）；的初始值设定项列表++count）标准：：cout<<array[count]<<''；标准：：cout<<'\n'；数组={1,3,5,7,9,11}；for（整数计数{0}；计数<array.getLength（）++count）标准：：cout<<array[count]<<''；标准：：cout<<'\n'；返回0；}下一课23.x第23章总结和测验返回目录上一课23.6容器类

