---
title: "协会"
date: 2024-10-08T17:40:35+08:00
---

在前两节课中，我们讨论了两种类型的对象组合，即组合和聚合。对象组合用于建模关系，其中复杂对象是由一个或多个简单对象（部分）构建的。在本课中，我们将研究两个原本不相关的对象之间的较弱类型的关系，称为关联。与对象组合关系不同，在关联中，没有隐含的整体/部分关系。关联要符合关联的条件，对象和另一个对象必须具有以下关系：关联的对象（成员）在其他方面与对象（类）无关关联的对象[成员]一次可以属于多个对象（类。就像聚合一样，关联的对象可以同时属于多个对象，并且不由这些对象管理。然而，与聚合（其中关系总是单向的）不同，在关联中，关系可以是单向的或双向的（其中两个对象相互感知）。医生和患者之间的关系是一个协会的伟大例子。医生显然与他的病人有关系，但从概念上讲，这不是一种部分/整体（对象构成）关系。医生一天可以看许多患者，患者可以看许多医生（也许他们需要第二种意见，或者他们正在拜访不同类型的医生）。对象的寿命都不与另一个绑定。我们可以说，关联模型是“使用”关系。医生“利用”病人（赚取收入）。患者使用医生（出于他们需要的任何健康目的）。实现关联由于关联是一种广泛类型的关系，因此可以用许多不同的方法来实现它们。然而，大多数情况下，关联是使用指针实现的，其中对象指向关联的对象。在本例中，我们将实现双向医生/患者关系，因为医生知道他们的患者是谁是有意义的，反之亦然#include<functional>//reference_wrapper#include<iostream>#incluse<string>#in包括<string_view>#inclaude<vector>//由于医生和患者具有循环依赖性，我们将向前声明患者类Patient；类Doctor{private:std:：string m_name{}；标准：：向量<std:：reference_wrapper<const患者>>m_pient{}；公共：医生（std:：string_view名称）：m_name{name}{}void addPatient（Patient&Patient）；//我们将在Patient下面实现此函数，因为我们需要在此时定义Patient friend std:：ostream&operator<<（std::ostream-out，const Doctor&Doctor）；常量标准：：string&getName（）const{return m_name；}}；类Patient{private:std:：string m_name{}；标准：：vector<std:：reference_wrapper<const Doctor>>m_Doctor{}；//因此，我们可以在这里使用它//我们将把addDoctor设置为私有的，因为我们不希望公众使用它。//他们应该使用Doctor:：addPatient（），它是公开的void addDoctors（const Doctor&Doctor）{m_Doctor.push_back（Doctor）；}public:Patient；const std:：string&getName（）const{return m_name；}//我们将成为Doctor:：addPatient（）的好友，因此它可以访问私有函数Patient:：addDoctor（）friend void Doctor::addPatient&Patient；}；void Doctor:：addPatient（Patient&Patient）{//我们的医生将添加此患者m_pient.push_back（Patient；for（const auto&patient:doctor.m_pient）out<<patient.get（）.getName（）<<''；返回；}std:：ostream&operator<<（std:：ostream&out，const Patient&Patient）{if（Patient.m_doctor.empty（））{out<<Patient.getName（）<<“目前没有医生”；return out；}out<<Patient.m_name<<“正在看医生：”；for（const auto&doctor:patient.m_doctor）out<<doctor.get（）.getName（）<<''；返回；}int main（）{//在医生-患者dave{“dave”}的范围之外创建患者；患者frank{“frank”}；患者betsy{“betsy”}；詹姆斯医生{“詹姆斯”}；斯科特医生{“斯科特”}；james.addPatient（戴夫）；scott.addPatient（戴夫）；scott.addPatient（betsy）；标准：：cout<<james<<'\n'；标准：：cout<<scott<<'\n'；标准：：cout<<dave<<'\n'；标准：：cout<<frank<<'\n'；标准：：cout<<betsy<<'\n'；返回0；}这张照片显示：詹姆斯正在看病人：戴夫·斯科特正在看病人；戴夫·贝特西·戴夫正在看医生：詹姆斯·斯科特·弗兰克现在没有医生，贝特西正在看医生。斯科特一般来说，如果单向关联会这样，你应该避免双向关联，因为它们增加了复杂性，并且往往很难在不出错的情况下编写。反射关联有时对象可能与相同类型的其他对象有关系。这被称为自反联想。自反关联的一个很好的例子是大学课程与其先决条件（也是大学课程）之间的关系。考虑一个简化的情况，一门课程只能有一个先决条件。我们可以这样做：#include<string>#incl包括<string_view>classCourse{private:std:：stringm_name{}；常量课程*m_先决条件{}；公共：课程（std:：string_view名称，const课程*先决条件=nullptr）：m_name{name}，m_prequirement{prequirement}{}}；这可能导致一系列关联（课程有一个前提，它有一个先决条件，等等……）关联可以是间接的。在前面的所有情况下，我们都使用了指针或引用来直接将对象链接在一起。然而，在协会中，这并不是严格要求的。允许您将两个对象链接在一起的任何类型的数据就足够了。在下面的示例中，我们展示了Driver类如何与Car具有单向关联，而不实际包括Car指针或引用成员：#include<iostream>#incluse<string>#In包括<string_view>class Car{private:std:：string m_name{}；整数mid{}；公共：汽车（std:：string_view名称，int id）：m_name{name}，m_id{id}{}常量std::string&getName（）const{return m_name；}int getId（）const{returns m_id；}}；//我们的CarLot本质上只是一个静态Cars数组和一个检索它们的查找函数。//因为它是静态的，我们不需要分配CarLot类型的对象来使用它的名称空间CarLot{CarCarLot[4]{{“Prius”，4}，{“花冠”，17}，}“雅阁”，84}，“矩阵”，62}}；Car*getCar（int id）{for（auto&Car:carLot）{if（Car.getId（）==id）{return&Car；}}return nullptr；}}；类驱动程序{private:std:：string m_name{}；整数m_carId{}；//我们与Car by ID关联，而不是指针public:Driver（std:：string_view name，int carId）：m_name{name}，m_carId{carId}{}const std::string&getName（）const{return m_name；}int getCarId（）const{return-m_carId；}}；int main（）{驱动程序d{“Franz”，17}；//Franz正在驾驶ID为17的汽车car*car{CarLot:：getCar（d.getCarId（））}；//如果（car）std:：cout<<d.getName（）<<“正在驾驶”<<car->getName（）<<'\n'；else std:：cout<<d.getName（）<<“找不到他的车\n”；返回0；}在上面的例子中，我们有一个CarLot存放我们的汽车。需要汽车的驾驶员没有指向他的汽车的指针——相反，他有汽车的ID，当我们需要时，我们可以使用它从CarLot中获取汽车。在这个特定的例子中，这样做有点傻，因为将汽车从CarLot中取出需要低效的查找（连接两者的指针要快得多）。然而，通过唯一的ID而不是指针引用事物是有好处的。例如，您可以引用当前不在内存中的内容（可能它们在文件或数据库中，并且可以按需加载）。此外，指针可以占用4或8个字节——如果空间很高，并且唯一对象的数量相当低，则通过8位或16位整数引用它们可以节省大量内存。组合vs聚合vs关联摘要这里有一个摘要表，帮助您记住组合、聚合和关联之间的区别：PropertyCompositionAggregationAssociationRelationship typeWhole/partWhole/Part否则未发布成员可以属于多个类NoYesYesMembers的存在由类YesNoDirectionalUnidirectionalUnidirection单向或双向关系verbPart of使用下一个lesson23.5依赖项返回目录上一个leson23.3聚合

