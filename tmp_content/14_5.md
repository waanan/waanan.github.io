---
title: "结构聚合初始化"
date: 2024-03-08T13:20:57+08:00
---

在上一课（13.5——结构、成员和成员选择简介）中，我们讨论了如何定义结构、实例化结构对象和访问其成员。在本课中，我们将讨论如何初始化结构。

***
## 默认情况下不初始化数据成员

与普通变量很相似，默认情况下不会初始化数据成员。考虑以下结构：

```C++
#include <iostream>

struct Employee
{
    int id; // note: no initializer here
    int age;
    double wage;
};

int main()
{
    Employee joe; // note: no initializer here either
    std::cout << joe.id << '\n';

    return 0;
}
```

因为我们没有提供任何初始化器，所以当joe被实例化时，joe.id、joe.age和joe.wage都将被取消初始化。然后，当我们尝试打印joe.id的值时，将获得未定义的行为。

然而，在我们展示如何初始化结构之前，让我们先绕开一小段路。

***
## 什么是聚合？

在一般编程中，聚合数据类型（也称为聚合）是可以包含多个数据成员的任何类型。某些类型的聚合允许成员具有不同的类型（例如结构），而其他类型的聚合则要求所有成员都必须是单个类型（例如数组）。

在C++中，聚合的定义更窄，也更复杂。

此时需要理解的关键问题是，只有数据成员的结构是聚合。

{{< alert success >}}
**作者注释**

在本教程系列中，当我们使用术语“聚合”（或“非聚合”）时，我们将指的是聚合的C++定义。

{{< /alert >}}

{{< alert success >}}
**对于高级读者**

为了简单起见，C++中的聚合要么是C样式数组（17.7--C样式数组简介），要么是具有以下特征的类类型（struct、class或union）：

1. 没有用户声明的构造函数（14.9--构造函数简介）
2. 没有私有或受保护的非静态数据成员（14.5——公共和私有成员以及访问说明符）
3. 无虚函数（25.2--虚函数和多态性）


流行的类型std:：array（17.1--std:∶array简介）也是一种聚合。

您可以在这里找到C++聚合的精确定义。

{{< /alert >}}

***
## 结构的聚合初始化

由于普通变量只能保存单个值，因此我们只需要提供单个初始值设定项：

```C++
int x { 5 };
```

然而，结构可以有多个成员：

```C++
struct Employee
{
    int id {};
    int age {};
    double wage {};
};
```

定义具有结构类型的对象时，需要某种方法在初始化时初始化多个成员：

```C++
Employee joe; // how do we initialize joe.id, joe.age, and joe.wage?
```

聚合使用一种称为聚合初始化的初始化形式，它允许我们直接初始化聚合的成员。为此，我们提供了一个初始化器列表作为初始化器，它只是一个逗号分隔值的大括号列表。

聚合初始化有两种主要形式：

```C++
struct Employee
{
    int id {};
    int age {};
    double wage {};
};

int main()
{
    Employee frank = { 1, 32, 60000.0 }; // copy-list initialization using braced list
    Employee joe { 2, 28, 45000.0 };     // list initialization using braced list (preferred)

    return 0;
}
```

这些初始化形式中的每一个都执行成员级初始化，这意味着结构中的每个成员都是按声明的顺序初始化的。因此，雇员乔{2,2845000.0}；首先用值2初始化joe.id，然后用值28初始化joe.age，最后用值45000.0初始化joe.wage。

在C++20中，我们还可以使用带括号的值列表来初始化（某些）聚合：

```C++
    Employee robert ( 3, 45, 62500.0 );  // direct initialization using parenthesized list (C++20)
```

我们建议尽可能避免最后一种形式，因为它目前不适用于使用大括号省略的聚合（特别是std:：array）。

{{< alert success >}}
**最佳做法**

初始化聚合时，首选（非副本）支持列表形式。

{{< /alert >}}

***
## 初始化器列表中缺少初始化器

如果聚合已初始化，但初始化值的数量小于成员的数量，则所有剩余的成员都将被值初始化。

```C++
struct Employee
{
    int id {};
    int age {};
    double wage {};
};

int main()
{
    Employee joe { 2, 28 }; // joe.wage will be value-initialized to 0.0

    return 0;
}
```

在上面的示例中，joe.id将用值2初始化，joe.age将用值28初始化，并且由于joe.wage没有被赋予显式初始值设定项，因此它的值将初始化为0.0。

这意味着我们可以使用空的初始化列表来对结构的所有成员进行值初始化：

```C++
Employee joe {}; // value-initialize all members
```

***
## Const结构

结构类型的变量可以是const（或constexpr），就像所有const变量一样，它们必须被初始化。

```C++
struct Rectangle
{
    double length {};
    double width {};
};

int main()
{
    const Rectangle unit { 1.0, 1.0 };
    const Rectangle zero { }; // value-initialize all members

    return 0;
}
```

***
## 指定的初始值设定项C++20

从值列表初始化结构时，初始值设定项按声明的顺序应用于成员。

```C++
struct Foo
{
    int a {};
    int c {};
};

int main()
{
    Foo f { 1, 3 }; // f.a = 1, f.c = 3

    return 0;
}
```

现在考虑一下，如果要更新此结构定义以添加不是最后一个成员的新成员，会发生什么情况：

```C++
struct Foo
{
    int a {};
    int b {}; // just added
    int c {};
};

int main()
{
    Foo f { 1, 3 }; // now, f.a = 1, f.b = 3, f.c = 0

    return 0;
}
```

现在，所有的初始化值都发生了偏移，更糟糕的是，编译器可能不会将其检测为错误（毕竟，语法仍然有效）。

为了帮助避免这种情况，C++20添加了一种新的方法来初始化结构成员，称为指定初始值设定项。指定的初始值设定项允许您显式定义哪些初始化值映射到哪些成员。成员可以使用列表或复制初始化进行初始化，并且必须以在结构中声明它们的相同顺序进行初始化，否则将导致警告或错误。未指定初始值设定项的成员将被初始化。

```C++
struct Foo
{
    int a{ };
    int b{ };
    int c{ };
};

int main()
{
    Foo f1{ .a{ 1 }, .c{ 3 } }; // ok: f1.a = 1, f1.b = 0 (value initialized), f1.c = 3
    Foo f2{ .a = 1, .c = 3 };   // ok: f2.a = 1, f2.b = 0 (value initialized), f2.c = 3
    Foo f3{ .b{ 2 }, .a{ 1 } }; // error: initialization order does not match order of declaration in struct

    return 0;
}
```

指定的初始值设定项很好，因为它们提供了某种程度的自我文档，并有助于确保您不会无意中混淆初始化值的顺序。然而，指定的初始值设定项也会显著地扰乱初始值设定器列表，因此我们不建议将其用作最佳实践。

此外，由于没有强制要求在初始化聚合的任何地方一致使用指定的初始值设定项，因此最好避免在现有聚合定义的中间添加新成员，以避免初始值设定值设定项移位的风险。

{{< alert success >}}
**对于Clang用户**

当使用大括号执行单个值的指定初始值设定项时，Clang不正确地发出“标量初始值设定器周围的大括号”警告。希望这将很快得到解决。

{{< /alert >}}

{{< alert success >}}
**最佳做法**

将新成员添加到聚合时，最安全的做法是将其添加到定义列表的底部，以便其他成员的初始值设定项不会移动。

{{< /alert >}}

***
## 具有初始值设定项列表的赋值

如前一课所示，我们可以单独为结构的成员指定值：

```C++
struct Employee
{
    int id {};
    int age {};
    double wage {};
};

int main()
{
    Employee joe { 1, 32, 60000.0 };

    joe.age  = 33;      // Joe had a birthday
    joe.wage = 66000.0; // and got a raise

    return 0;
}
```

这对于单个成员来说很好，但在我们想要更新多个成员时就不太好了。与使用初始值设定项列表初始化结构类似，您也可以使用初始值设置项列表将值分配给结构（该列表执行成员级赋值）：

```C++
struct Employee
{
    int id {};
    int age {};
    double wage {};
};

int main()
{
    Employee joe { 1, 32, 60000.0 };
    joe = { joe.id, 33, 66000.0 }; // Joe had a birthday and got a raise

    return 0;
}
```

注意，因为我们不想更改joe.id，所以需要在列表中提供joe.id的当前值作为占位符，以便成员分配可以将joe.id分配给joe.id。这有点难看。

***
## 使用指定的初始值设定项C++20进行赋值

指定的初始值设定项也可以在列表赋值中使用：

```C++
struct Employee
{
    int id {};
    int age {};
    double wage {};
};

int main()
{
    Employee joe { 1, 32, 60000.0 };
    joe = { .id = joe.id, .age = 33, .wage = 66000.0 }; // Joe had a birthday and got a raise

    return 0;
}
```

任何未在这种赋值中指定的成员都将被分配用于值初始化的值。如果我们没有为joe.id指定指定的初始值设定项，那么joe.id将被赋值为0。

***
## 使用相同类型的另一个结构初始化结构

也可以使用相同类型的另一个结构来初始化结构：

```C++
#include <iostream>

struct Foo
{
    int a{};
    int b{};
    int c{};
};

int main()
{
    Foo foo { 1, 2, 3 };
    
    Foo x = foo; // copy initialization
    Foo y(foo);  // direct initialization
    Foo z {foo}; // list initialization
    
    std::cout << x.a << ' ' << y.b << ' ' << z.c << '\n';

    return 0;
}
```

以上打印内容：

请注意，这使用了我们熟悉的标准形式的初始化（复制、直接或列表初始化），而不是聚合初始化。

这在使用返回相同类型结构的函数的返回值初始化结构时最常见。我们在第13.8课——传递和返回结构中更详细地讨论了这一点。

