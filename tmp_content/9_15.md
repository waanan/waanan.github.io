---
title: "检测和处理错误"
date: 2023-11-01T20:12:31+08:00
---

在第8.15课——C++中的常见语义错误中，我们介绍了新C++程序员在该语言中遇到的许多类型的常见C++语义错误。如果错误是误用的语言功能或逻辑错误的结果，则可以简单地更正错误。

但程序中的大多数错误并不是由于无意中误用语言功能而发生的——相反，大多数错误是由于程序员的错误假设和/或缺乏适当的错误检测/处理而发生的。

例如，在设计用于查找学生成绩的函数中，您可能假设：

1. 被查找的学生将存在。
2. 所有学生的姓名都是唯一的。
3. 该类使用字母评分（而不是及格/不及格）。


如果这些假设中的任何一个都不正确怎么办？如果程序员没有预料到这些情况，当出现这种情况时，程序可能会发生故障或崩溃（通常在未来的某个时间点，在编写函数之后）。

假设错误通常发生在三个关键位置：

1. 当函数返回时，程序员可能假设被调用的函数是成功的，而它不是。
2. 当程序接收到输入（来自用户或文件）时，程序员可能会假设输入的格式正确，并且在输入不正确时在语义上有效。
3. 调用函数时，程序员可能会假设参数在语义上是有效的，但实际上它们不是。


许多新程序员编写代码，然后只测试快乐的路径：仅在没有错误的情况下。但你也应该计划和测试你悲伤的道路，在那里事情可能会出错，也会出错。在第3.10课——在问题变成问题之前发现问题，我们将防御编程定义为尝试预测最终用户或开发人员（程序员自己或其他人）滥用软件的所有方式的实践。一旦你预料到（或发现）一些误用，下一步要做的就是处理它。

在本课中，我们将讨论函数内部的错误处理策略（出错时该怎么办）。在后面的课程中，我们将讨论验证用户输入，然后介绍一个有用的工具来帮助记录和验证假设。

***
## 处理函数中的错误

函数可能会由于许多原因而失败——调用方可能传入了一个具有无效值的参数，或者函数体中的某些内容可能会失败。例如，如果找不到文件，则打开文件进行读取的函数可能会失败。

当这种情况发生时，您有相当多的选项可供选择。没有最好的方法来处理错误——这实际上取决于问题的性质以及问题是否可以修复。

有4种通用策略可以使用：

1. 处理函数中的错误
2. 将错误传递回调用方以处理
3. 暂停程序
4. 引发异常


***
## 处理函数中的错误

如果可能，最好的策略是从发生错误的同一函数中的错误中恢复，以便可以在不影响函数外部的任何代码的情况下包含和更正错误。这里有两个选项：重试直到成功，或取消正在执行的操作。

如果错误是由于程序无法控制的原因而发生的，则程序可以重试，直到成功。例如，如果程序需要互联网连接，而用户已失去连接，则程序可以显示警告，然后使用循环定期重新检查互联网连接。或者，如果用户输入了无效的输入，程序可以要求用户重试，并循环，直到用户成功输入有效的输入。在下一课中，我们将展示处理无效输入和使用循环重试的示例（8.17---std:：cin和处理无效输入）。

另一种策略是忽略错误和/或取消操作。例如：

```C++
void printDivision(int x, int y)
{
    if (y != 0)
        std::cout << static_cast<double>(x) / y;
}
```

在上面的例子中，如果用户为y传递了无效的值，我们就忽略打印除法运算结果的请求。这样做的主要挑战是，调用方或用户无法识别出问题。在这种情况下，打印错误消息可能会有所帮助：

```C++
void printDivision(int x, int y)
{
    if (y != 0)
        std::cout << static_cast<double>(x) / y;
    else
        std::cout << "Error: Could not divide by zero\n";
}
```

然而，如果调用函数期望被调用函数产生返回值或一些有用的副作用，那么忽略错误可能不是一个选项。

***
## 将错误传回调用方

在许多情况下，错误不能在检测错误的函数中合理地处理。例如，考虑以下函数：

```C++
double doDivision(int x, int y)
{
    return static_cast<double>(x) / y;
}
```

如果y是0，我们应该怎么做？我们不能跳过程序逻辑，因为函数需要返回一些值。我们不应该要求用户输入y的新值，因为这是一个计算函数，并且在其中引入输入例程可能适合于调用该函数的程序，也可能不适合。

在这种情况下，最好的选择是将错误传递回调用方，希望调用方能够处理它。

我们如何才能做到这一点？

如果函数具有void返回类型，则可以将其更改为返回指示成功或失败的布尔值。例如，而不是：

```C++
void printDivision(int x, int y)
{
    if (y != 0)
        std::cout << static_cast<double>(x) / y;
    else
        std::cout << "Error: Could not divide by zero\n";
}
```

我们可以这样做：

```C++
bool printDivision(int x, int y)
{
    if (y == 0)
    {
        std::cout << "Error: could not divide by zero\n";
        return false;
    }
    
    std::cout << static_cast<double>(x) / y;

    return true;
}
```

这样，调用方可以检查返回值，以查看函数是否因某种原因而失败。

如果函数返回正常值，则情况会稍微复杂一些。在某些情况下，不使用完整的返回值范围。在这种情况下，我们可以使用通常不可能发生的返回值来指示错误。例如，考虑以下函数：

```C++
// The reciprocal of x is 1/x
double reciprocal(double x)
{
    return 1.0 / x;
}
```

某个数x的倒数定义为1/x，一个数乘以它的倒数等于1。

然而，如果用户将此函数调用为倒数（0.0），会发生什么情况？我们得到一个除以零的错误和一个程序崩溃，所以很明显，我们应该防止这种情况。但这个函数必须返回一个双精度值，所以我们应该返回什么值？结果表明，该函数永远不会产生0.0作为合法结果，因此我们可以返回0.0来指示错误情况。

```C++
// The reciprocal of x is 1/x, returns 0.0 if x=0
double reciprocal(double x)
{
    if (x == 0.0)
       return 0.0;

    return 1.0 / x;
}
```

然而，如果需要完整的返回值范围，则不可能使用返回值来指示错误（因为调用程序将无法区分返回值是有效值还是错误值）。

{{< alert success >}}
**作者注释**

在这种情况下，返回std:：optional将是一个不错的选择。我们目前不包括std:：optional，但打算在将来的更新中这样做。

{{< /alert >}}

***
## 致命错误

如果错误严重到程序无法继续正常运行，则这称为不可恢复错误（也称为致命错误）。在这种情况下，最好的做法是终止程序。如果您的代码在main（）中或直接从main（。然而，如果您深入到某个嵌套子函数中，将错误传播回main（）可能不方便或不可能。在这种情况下，可以使用halt语句（例如std:：exit（））。

例如：

```C++
double doDivision(int x, int y)
{
    if (y == 0)
    {
        std::cout << "Error: Could not divide by zero\n";
        std::exit(1);
    }
    return static_cast<double>(x) / y;
}
```

***
## 例外情况

由于将错误从函数返回给调用者是复杂的（许多不同的方法都会导致不一致，而不一致会导致错误），C++提供了一种完全独立的方法来将错误传递回调用者：异常。

基本思想是，当错误发生时，会“抛出”异常。如果当前函数没有“捕获”错误，则函数的调用方有机会捕获该错误。如果调用者没有捕获错误，则调用者的调用者有机会捕获错误。错误在调用堆栈中逐渐向上移动，直到捕获并处理它（此时执行正常继续），或者直到main（）无法处理错误（此时程序因异常错误而终止）。

我们在本教程系列的第27章中介绍了异常处理。

***
## 何时使用标准：：cout vs标准：：cerr vs日志记录

您可能想知道什么时候应该使用std:：cerr vs std:：cout vs logging到文本文件。

默认情况下，std:：cout和std:：cerr都将文本打印到控制台。然而，现代操作系统提供了一种将输出流重定向到文件的方法，以便可以捕获输出以供以后审查或自动处理。

对于此讨论，区分两种类型的应用程序是有用的：

1. 交互式应用程序是用户在运行后将与之交互的应用程序。大多数独立应用程序，如游戏和音乐应用程序，都属于这一类。
2. 非交互式应用程序是不需要用户交互才能运行的应用程序。这些程序的输出可以用作其他应用的输入


在非交互式应用程序中，有两种类型：

1. 工具是非交互式应用程序，通常是为了产生某些即时结果而启动，然后在产生这样的结果后终止。这方面的一个例子是Unix的grep命令，这是一个实用程序，用于搜索文本中与某种模式匹配的行。
2. 服务是非交互式应用程序，通常在后台静默运行以执行某些正在进行的功能。这方面的一个例子是病毒扫描程序。


这里有一些经验法则：

1. 对所有传统的面向用户的文本使用std:：cout。
2. 对于交互式程序，请将std:：cout用于普通的面向用户的错误消息（例如，“您的输入无效”）。使用std:：cerr或日志文件来获取状态和诊断信息，这些信息可能有助于诊断问题，但对于普通用户来说可能并不有趣。这可以包括技术警告和错误（例如，功能x的输入错误）、状态更新（例如，成功打开文件x，未能连接到互联网服务x）、长任务的完成百分比（例如，编码完成50%）等…
3. 对于非交互式程序（工具或服务），仅将std:：cerr用于错误输出（例如，无法打开文件x）。这允许错误与正常输出分开显示或分析。
4. 对于本质上是事务性的任何应用程序类型（例如，处理特定事件的应用程序类型，如交互式web浏览器或非交互式web服务器），使用日志文件生成事件的事务日志，这些事件可以在以后查看。


例如，输出当前正在处理的文件、完成百分比、开始计算的某个阶段的时间戳、警告和错误消息。

