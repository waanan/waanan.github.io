---
title: "Constexpr变量"
date: 2023-11-28T13:19:42+08:00
---

***
## constexpr关键字

当使用const关键字声明const变量时，编译器将隐式跟踪它是运行时常量还是编译时间常量。在大多数情况下，这对于优化以外的任何事情都无关紧要，但在一些情况下，C++需要常量表达式（我们将在稍后介绍这些主题时介绍这些情况）。并且在常量表达式中只能使用编译时常量变量。

由于编译时常量还允许更好的优化（并且没有什么缺点），因此我们通常希望尽可能使用编译时常量。

当使用const时，我们的变量可以作为编译时常量或运行时常量结束，这取决于初始值设定项是否是编译时表达式。在某些情况下，很难区分常量变量是编译时常量（在常量表达式中可用）还是运行时常量（不在常量表达式内可用）。

例如：

```C++
int x { 5 };       // not const at all
const int y { x }; // obviously a runtime const (since initializer is non-const)
const int z { 5 }; // obviously a compile-time const (since initializer is a constant expression)
const int w { getValue() }; // not obvious whether this is a runtime or compile-time const
```

在上面的示例中，w可以是运行时常量，也可以是编译时常量，具体取决于getValue（）的定义方式。一点也不清楚！

幸运的是，我们可以获得编译器的帮助，以确保在需要的地方获得编译时常量。为此，我们在变量的声明中使用constexpr关键字而不是const。constexpr（“常量表达式”的缩写）变量只能是编译时常量。如果constexpr变量的初始化值不是常量表达式，编译器将出错。

例如：

```C++
#include <iostream>

int five()
{
    return 5;
}

int main()
{
    constexpr double gravity { 9.8 }; // ok: 9.8 is a constant expression
    constexpr int sum { 4 + 5 };      // ok: 4 + 5 is a constant expression
    constexpr int something { sum };  // ok: sum is a constant expression

    std::cout << "Enter your age: ";
    int age{};
    std::cin >> age;

    constexpr int myAge { age };      // compile error: age is not a constant expression
    constexpr int f { five() };       // compile error: return value of five() is not a constant expression

    return 0;
}
```

{{< alert success >}}
**最佳做法**

任何在初始化后不应修改且其初始值设定项在编译时已知的变量都应声明为constexpr。任何在初始化后不应修改且其初始值设定项在编译时未知的变量都应声明为常量。

警告：在将来，我们将讨论当前与constexpr不兼容的一些类型（包括std:：string、std:∶vector和其他使用动态内存分配的类型）。对于这些类型的常量对象，请改用const。

{{< /alert >}}

{{< alert success >}}
**作者注释**

本站点上的许多示例都是在使用constexpr的最佳实践之前编写的——因此，您会注意到，许多示例没有遵循上述最佳实践。我们目前正在更新遇到的不符合示例。

{{< /alert >}}

***
## Const和constexpr函数参数

普通函数调用在运行时求值，提供的参数用于初始化函数的参数。这意味着常量函数参数被视为运行时常量，即使提供的参数是编译时常量。

由于constexpr对象必须用编译时常量（而不是运行时常量）初始化，因此不能将函数参数声明为constexpr。

{{< alert success >}}
**相关内容**

C++确实支持可以在编译时计算的函数（因此可以在常量表达式中使用）。我们在第5.8课——Constexpr和consteval函数中讨论了这些。

C++还支持将编译时常量传递给函数的方法。我们在第10.18课——非类型模板参数中讨论了这些。

{{< /alert >}}

***
## 何时实际计算常量表达式？

编译器仅需要在需要常量表达式的上下文（如编译时常量的初始值设定项）中的编译时计算常量表达式：

```C++
constexpr int x { 3 + 4 }; // 3 + 4 will always evaluate at compile time
const int x { 3 + 4 };     // 3 + 4 will always evaluate at compile time
```

在不需要常量表达式的上下文中，编译器可以选择是在编译时还是在运行时计算常量表达式。

```C++
int x { 3 + 4 }; // 3 + 4 may evaluate at compile-time or runtime
```

在上面的变量定义中，x不是constexpr变量，并且在编译时不需要知道初始化值。因此，编译器可以自由选择是在编译时还是在运行时计算3+4。

尽管它不是严格要求的，但现代编译器通常会在编译时计算常量表达式，因为这样做很容易优化，并且性能更高。

***
## 常量子表达式的常量折叠

考虑以下示例：

```C++
#include <iostream>

int main()
{
	constexpr int x { 3 + 4 }; // 3 + 4 is a constant expression
	std::cout << x << '\n';    // this is a runtime expression

	return 0;
}
```

3+4是一个常量表达式，因此编译器将在编译时计算3+4，并将其替换为值7。由于x是编译时间常数，编译器可能会完全优化上述程序中的x，将std:：cout<<x<<'\n'替换为std::cout<<7<<'\n'。输出表达式将在运行时执行。

然而，由于x仅使用一次，因此我们更有可能首先这样编写程序：

```C++
#include <iostream>

int main()
{
	std::cout << 3 + 4 << '\n'; // this is a runtime expression

	return 0;
}
```

由于完整表达式std:：cout<<3+4<<'\n'不是常量表达式，因此有理由怀疑常量子表达式3+4是否仍将在编译时优化。

答案通常是“是”。编译器早就能够优化常量子表达式，即使完整表达式是运行时表达式。这种优化过程称为“常数折叠”。

使变量constexpr确保在常量子表达式中使用这些变量时，它们符合常量折叠的条件。

{{< alert success >}}
**相关内容**

我们在第1.10课——表达式介绍中定义了术语“子表达式”。

{{< /alert >}}

