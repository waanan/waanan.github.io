---
title: "价值类别（左值和右值）"
date: 2024-02-19T14:35:47+08:00
---

在我们讨论我们的第一个复合类型（左值引用）之前，我们将绕道一点，讨论一下左值是什么。

在第1.10课——表达式简介中，我们将表达式定义为“可以执行以产生奇异值的文本、变量、运算符和函数调用的组合”。

例如：

```C++
#include <iostream>

int main()
{
    std::cout << 2 + 3 << '\n'; // The expression 2 + 3 produces the value 5

    return 0;
}
```

在上述程序中，表达式2+3求值以产生值5，然后将该值打印到控制台。

在第6.4课——增量/减量运算符和副作用中，我们还注意到表达式可以产生比表达式更持久的副作用：

```C++
#include <iostream>

int main()
{
    int x { 5 };
    ++x; // This expression statement has the side-effect of incrementing x
    std::cout << x << '\n'; // prints 6

    return 0;
}
```

在上面的程序中，表达式++x增加x的值，即使表达式完成求值，该值也保持更改。

除了产生值和副作用外，表达式还可以做一件事：它们可以对对象或函数求值。我们稍后将进一步探讨这一点。

***
## 表达式的属性

为了帮助确定表达式的计算方式和使用位置，C++中的所有表达式都有两个属性：类型和值类别。

***
## 表达式的类型

表达式的类型等效于由计算的表达式产生的值、对象或函数的类型。例如：

```C++
int main()
{
    auto v1 { 12 / 4 }; // int / int => int
    auto v2 { 12.0 / 4 }; // double / int => double

    return 0;
}
```

对于v1，编译器将（在编译时）确定具有两个int操作数的除法将产生int结果，因此int是该表达式的类型。通过类型推理，int将用作v1的类型。

对于v2，编译器将（在编译时）确定具有双操作数和int操作数的除法将产生双精度结果。请记住，算术运算符必须具有匹配类型的操作数，因此在这种情况下，int操作数被转换为double，并执行浮点除法。所以double是这个表达式的类型。

编译器可以使用表达式的类型来确定表达式在给定上下文中是否有效。例如：

```C++
#include <iostream>

void print(int x)
{
    std::cout << x << '\n';
}

int main()
{
    print("foo"); // error: print() was expecting an int argument, we tried to pass in a string literal

    return 0;
}
```

在上面的程序中，print（int）函数需要一个int参数。然而，我们传递的表达式的类型（字符串文本“foo”）不匹配，并且找不到转换。因此会产生编译错误。

请注意，表达式的类型必须在编译时可确定（否则类型检查和类型演绎将不起作用）——然而，表达式的值可以在编译时（如果表达式是constexpr）或运行时（如果该表达式不是constexpr.）确定。

***
## 表达式的值类别

现在考虑以下程序：

```C++
int main()
{
    int x{};

    x = 5; // valid: we can assign 5 to x
    5 = x; // error: can not assign value of x to literal value 5

    return 0;
}
```

其中一个赋值语句有效（将值5赋值给变量x），另一个无效（将x的值赋值给文本值5是什么意思？）。那么编译器如何知道哪些表达式可以合法地出现在赋值语句的两侧呢？

答案在于表达式的第二个属性：值类别。表达式（或子表达式）的值类别指示表达式是解析为值、函数还是某种类型的对象。

在C++11之前，只有两种可能的值类别：左值和右值。

在C++11中，添加了三个额外的值类别（glvalue、prvalue和xvalue）来支持名为移动语义的新功能。

{{< alert success >}}
**作者注释**

在本课中，我们将坚持使用C++11之前的价值类别视图，因为这有助于更温和地介绍价值类别（这是我们目前所需要的）。在未来的一章中，我们将讨论移动语义（以及额外的三个值类别）。

{{< /alert >}}

***
## L值和R值表达式

左值（发音为“ell-value”，是“左值”或“定位器值”的缩写，有时写为“l-value”）是计算为可识别对象或函数（或位字段）的表达式。

C++标准使用术语“标识”，但没有明确定义。具有标识的实体（例如对象或函数）可以与其他类似实体区分开来（通常通过比较实体的地址）。

具有标识的实体可以通过标识符、引用或指针访问，并且其生存期通常比单个表达式或语句长。

```C++
int main()
{
    int x { 5 };
    int y { x }; // x is an lvalue expression

    return 0;
}
```

在上面的程序中，表达式x是左值表达式，因为它计算为变量x（具有标识符）。

自从在语言中引入常量以来，左值分为两个子类型：可修改左值是其值可以修改的左值。不可修改左值是其值不能修改的左值（因为左值是const或constexpr）。

```C++
int main()
{
    int x{};
    const double d{};

    int y { x }; // x is a modifiable lvalue expression
    const double e { d }; // d is a non-modifiable lvalue expression

    return 0;
}
```

rvalue（发音为“arr value”，是“right value”的缩写，有时写为r-value）是不是左值的表达式。Rvalue表达式计算为一个值。常见的右值包括文本（C样式的字符串文本除外，它们是左值）以及按值返回的函数和运算符的返回值。R值是不可识别的（这意味着它们必须立即使用），并且仅存在于使用它们的表达式的范围内。

```C++
int return5()
{
    return 5;
}

int main()
{
    int x{ 5 }; // 5 is an rvalue expression
    const double d{ 1.2 }; // 1.2 is an rvalue expression

    int y { x }; // x is a modifiable lvalue expression
    const double e { d }; // d is a non-modifiable lvalue expression
    int z { return5() }; // return5() is an rvalue expression (since the result is returned by value)

    int w { x + 1 }; // x + 1 is an rvalue expression
    int q { static_cast<int>(d) }; // the result of static casting d to an int is an rvalue expression

    return 0;
}
```

您可能想知道为什么return5（）、x+1和static_cast<int>（d）是右值：答案是因为这些表达式产生的临时值不是可识别的对象。

现在我们可以回答为什么x=5有效，而5=x无效的问题：赋值操作要求赋值的左操作数是可修改的左值表达式，右操作数是右值表达式。后一个赋值（5=x）失败，因为左操作数表达式5不是左值。

```C++
int main()
{
    int x{};

    // Assignment requires the left operand to be a modifiable lvalue expression and the right operand to be an rvalue expression
    x = 5; // valid: x is a modifiable lvalue expression and 5 is an rvalue expression
    5 = x; // error: 5 is an rvalue expression and x is a modifiable lvalue expression

    return 0;
}
```

{{< alert success >}}
**关键洞察力**

L值表达式计算为可识别的对象。Rvalue表达式计算为一个值。

{{< /alert >}}

{{< alert success >}}
**相关内容**

在这里可以找到左值和右值表达式的完整列表。在C++11中，右值分为两个子类型：prvalues和xvalues，因此我们在这里讨论的右值是这两个类别的总和。

{{< /alert >}}

{{< alert success >}}
**提示**

如果您不确定表达式是左值还是右值，请尝试使用运算符&获取其地址，这要求其操作数是左值。If&（表达式）；编译时，表达式必须是左值：

```C++
int foo()
{
    return 5;
}

int main()
{
    int x { 5 };
    &x; // compiles: x is an lvalue expression
    &5; // doesn't compile: 5 is an rvalue expression
    &foo(); // doesn't compile: foo() is an rvalue expression
}
```

{{< /alert >}}

{{< alert success >}}
**关键洞察力**

C样式字符串文本是左值，因为C样式字符串（是C样式数组）衰减为指针。只有当数组是左值（因此具有可以存储在指针中的地址）时，衰减过程才有效。C++继承了这一点以向后兼容。

我们在第17.8课中讨论了阵列衰减——C型阵列衰减。

{{< /alert >}}

***
## L值到R值的转换

让我们再次看一看这个例子：

```C++
int main()
{
    int x { 5 };
    int y { x }; // x is an lvalue expression

    return 0;
}
```

如果x是计算变量x的左值表达式，那么y如何以值5结束？

答案是，在期望右值但提供左值的上下文中，左值表达式将隐式转换为右值表达式。int变量的初始值设定项应为rvalue表达式。因此，左值表达式x进行左值到右值的转换，其计算为值5，然后用于初始化y。

我们在上面说过，赋值运算符期望右操作数是右值表达式，那么为什么这样的代码可以工作呢？

```C++
int main()
{
    int x{ 1 };
    int y{ 2 };

    x = y; // y is a modifiable lvalue, not an rvalue, but this is legal

    return 0;
}
```

在这种情况下，y是左值表达式，但它经历了左值到右值的转换，其计算为y（2）的值，然后将其赋值给x。

现在考虑这个例子：

```C++
int main()
{
    int x { 2 };

    x = x + 1;

    return 0;
}
```

在该语句中，变量x在两个不同的上下文中使用。在赋值运算符的左侧，x是计算为变量x的左值表达式。在赋值操作符的右侧，x+1是计算为值3的右值表达式。

现在我们已经讨论了左值，我们可以得到我们的第一个复合类型：左值引用。

{{< alert success >}}
**关键洞察力**

识别左值和右值表达式的经验法则：

1. L值表达式是那些求值为变量或其他可识别对象的表达式，这些变量或对象持续存在于表达式末尾之后。
2. Rvalue表达式是那些计算为在表达式末尾丢弃的函数/运算符返回的文本或值的表达式。


{{< /alert >}}

