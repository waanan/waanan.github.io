---
title: "对象大小和sizeof运算符"
date: 2023-10-09T20:06:10+08:00
---

***
## 对象大小

正如您在第4.1课——基本数据类型介绍中所学的那样，现代机器上的内存通常被组织为字节大小的单位，内存的每个字节都有一个唯一的地址。到目前为止，将内存视为一堆文件柜或邮箱是有用的，我们可以在其中放置和检索信息，将变量视为访问这些文件柜或信箱的名称。

然而，这种类比在一个方面并不十分正确——大多数对象实际上占用超过1个字节的内存。单个对象可以使用1、2、4、8或甚至更多的连续存储器地址。对象使用的内存量基于其数据类型。

由于我们通常通过变量名（而不是直接通过内存地址）访问内存，编译器能够向我们隐藏给定对象使用多少字节的详细信息。当我们访问某个变量x时，编译器知道要检索多少字节的数据（基于变量x的类型），并可以为我们处理该任务。

即使如此，有几个原因可以帮助您了解对象使用了多少内存。

首先，对象使用的内存越多，它可以容纳的信息就越多。

单个位可以保存2个可能的值，即0或1：

2位可以保存4个可能的值：

3位可以保存8个可能的值：

概括地说，具有n位（其中n是整数）的对象可以保存2n（2的n次幂，也通常写入2^n）唯一值。因此，对于8位字节，字节大小的对象可以保存28（256）个不同的值。使用2个字节的对象可以保存2^16（65536）个不同的值！

因此，对象的大小限制了它可以存储的唯一值的数量——使用更多字节的对象可以存储更多的唯一值。当我们更多地讨论整数时，我们将进一步探索这一点。

其次，计算机有有限的空闲内存。每次定义对象时，只要对象存在，就会使用该空闲内存的一小部分。由于现代计算机有大量内存，这种影响通常可以忽略不计。然而，对于需要大量对象或数据的程序（例如，渲染数百万个多边形的游戏），使用1字节和8字节对象之间的差异可能非常显著。

{{< alert success >}}
**关键洞察力**

新程序员通常过于关注优化他们的代码，以使用尽可能少的内存。在大多数情况下，这造成了微不足道的差异。专注于编写可维护的代码，并仅在效益显著时进行优化。

{{< /alert >}}

***
## 基本数据类型大小

显而易见的下一个问题是“不同数据类型的变量占用多少内存？”。

也许令人惊讶的是，C++标准没有定义任何基本类型的确切大小。相反，它只为整型和char类型定义了最小大小（以位为单位），并将所有类型的实际大小留给实现定义！C++标准也不假设字节是8位。

在本教程系列中，我们将通过做出一些合理的假设来简化视图，这些假设通常适用于现代架构：

1. 一个字节是8位。
2. 内存是字节可寻址的，因此最小的对象是1个字节。
3. 浮点支持符合IEEE-754。
4. 我们采用的是32位或64位体系结构。


鉴于此，我们可以声明如下：

{{< alert success >}}
**提示**

为了获得最大的可移植性，您不应该假设变量大于指定的最小大小。

或者，如果希望假设类型具有特定大小（例如，int至少为4个字节），则可以使用static_assert使编译器在该假设不成立的架构上编译生成时失败。我们在第8.18课中介绍了如何做到这一点——断言和static_Assert。

{{< /alert >}}

{{< alert success >}}
**相关内容**

如果您在不符合我们假设的系统上使用C++，或者只是好奇，您可以在这里找到有关C++标准对各种类型的最小大小的更多信息。

{{< /alert >}}

***
## sizeof运算符

为了确定特定机器上数据类型的大小，C++提供了一个名为sizeof的操作符。sizeof运算符是一元运算符，它接受类型或变量，并返回其大小（以字节为单位）。您可以编译并运行以下程序，以了解某些数据类型的大小：

```C++
#include <iomanip> // for std::setw (which sets the width of the subsequent output)
#include <iostream>

int main()
{
    std::cout << std::left; // left justify output
    std::cout << std::setw(16) << "bool:" << sizeof(bool) << " bytes\n";
    std::cout << std::setw(16) << "char:" << sizeof(char) << " bytes\n";
    std::cout << std::setw(16) << "short:" << sizeof(short) << " bytes\n";
    std::cout << std::setw(16) << "int:" << sizeof(int) << " bytes\n";
    std::cout << std::setw(16) << "long:" << sizeof(long) << " bytes\n";
    std::cout << std::setw(16) << "long long:" << sizeof(long long) << " bytes\n";
    std::cout << std::setw(16) << "float:" << sizeof(float) << " bytes\n";
    std::cout << std::setw(16) << "double:" << sizeof(double) << " bytes\n";
    std::cout << std::setw(16) << "long double:" << sizeof(long double) << " bytes\n";

    return 0;
}
```

以下是作者机器的输出：

您的结果可能因编译器、计算机架构、操作系统、编译设置（32位与64位）等而异…

尝试对不完整的类型（如void）使用sizeof将导致编译错误。

您还可以对变量名使用sizeof运算符：

```C++
#include <iostream>

int main()
{
    int x{};
    std::cout << "x is " << sizeof(x) << " bytes\n";

    return 0;
}
```

{{< alert success >}}
**对于高级读者**

sizeof不包括对象使用的动态分配内存。我们将在以后的课程中讨论动态内存分配。

{{< /alert >}}

***
## 基本数据类型性能

在现代机器上，基本数据类型的对象速度很快，所以使用或复制这些类型时的性能通常不应成为问题。

{{< alert success >}}
**作为旁白…**

您可以假设使用较少内存的类型比使用较多内存的类型更快。这并不总是正确的。CPU通常被优化为处理特定大小的数据（例如32位），并且与该大小匹配的类型可以更快地处理。在这样的机器上，32位int可能比16位short或8位char更快。

{{< /alert >}}

