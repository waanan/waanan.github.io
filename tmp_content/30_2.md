---
title: "使用ostream和ios输出"
date: 2025-03-02T00:53:53+08:00
---

在本节中，我们将研究iostream输出类（ostream）的各个方面。

插入运算符

插入运算符（<<）用于将信息放入输出流中。C++为所有内置数据类型预定义了插入操作，并且您已经看到了如何为自己的类重载插入操作符。

在关于流的课程中，您看到istream和ostream都派生自一个名为ios的类。ios（和ios_base）的任务之一是控制输出的格式选项。

格式化

有两种方法可以更改格式选项：标志和操纵器。您可以将标志视为可以打开和关闭的布尔变量。操纵器是放置在流中的对象，影响事物的输入和输出方式。

要打开标志，请使用setf（）函数，并将适当的标志作为参数。例如，默认情况下，C++不会在正数之前打印+号。然而，通过使用std:：ios:：showpos标志，我们可以更改此行为：

```C++
std::cout.setf(std::ios::showpos); // turn on the std::ios::showpos flag
std::cout << 27 << '\n';
```

这将产生以下输出：

可以使用Bitwise OR（|）运算符一次打开多个ios标志：

```C++
std::cout.setf(std::ios::showpos | std::ios::uppercase); // turn on the std::ios::showpos and std::ios::uppercase flag
std::cout << 1234567.89f << '\n';
```

该输出：

要关闭标志，请使用unsetf（）函数：

```C++
std::cout.setf(std::ios::showpos); // turn on the std::ios::showpos flag
std::cout << 27 << '\n';
std::cout.unsetf(std::ios::showpos); // turn off the std::ios::showpos flag
std::cout << 28 << '\n';
```

这将产生以下输出：

在使用setf（）时，还有一点需要注意的技巧。许多标志属于组，称为格式组。格式组是一组执行类似（有时互斥）格式选项的标志。例如，名为“basefield”的格式组包含标志“oct”、“dec”和“hex”，这些标志控制整数值的基数。默认情况下，设置“dec”标志。因此，如果我们这样做：

```C++
std::cout.setf(std::ios::hex); // try to turn on hex output
std::cout << 27 << '\n';
```

我们得到以下输出：

它不工作！原因是因为setf（）仅打开标志——它不够聪明，无法关闭互斥标志。因此，当我们打开std:：hex时，std:：ios:：dec仍处于打开状态，而std:∶ios:∶dec显然优先。有两种方法可以解决这个问题。

首先，我们可以关闭std:：ios:：dec，以便仅设置std:∶hex：

```C++
std::cout.unsetf(std::ios::dec); // turn off decimal output
std::cout.setf(std::ios::hex); // turn on hexadecimal output
std::cout << 27 << '\n';
```

现在我们得到了预期的输出：

第二种方法是使用不同形式的setf（），它接受两个参数：第一个参数是要设置的标志，第二个参数是它所属的格式化组。当使用这种形式的setf（）时，属于该组的所有标志都被关闭，只有传入的标志被打开。例如：

```C++
// Turn on std::ios::hex as the only std::ios::basefield flag
std::cout.setf(std::ios::hex, std::ios::basefield);
std::cout << 27 << '\n';
```

这也会产生预期的输出：

使用setf（）和unsetf（）往往会很尴尬，因此C++提供了第二种更改格式选项的方法：操纵器。操纵器的好处是它们足够聪明，可以打开和关闭适当的标志。下面是使用一些操纵器更改基础的示例：

```C++
std::cout << std::hex << 27 << '\n'; // print 27 in hex
std::cout << 28 << '\n'; // we're still in hex
std::cout << std::dec << 29 << '\n'; // back to decimal
```

该程序生成输出：

通常，使用操纵器比设置和取消设置标志容易得多。许多选项通过标志和操纵器都可用（例如更改基础），然而，其他选项仅通过标志或操纵器可用，因此了解如何同时使用这两个选项非常重要。

有用的格式化程序

下面是一些更有用的标志、操纵器和成员函数的列表。标志存在于std:：ios类中，操纵器存在于std命名空间中，成员函数存在于std:：ostream类中。

示例：

```C++
std::cout << true << ' ' << false << '\n';

std::cout.setf(std::ios::boolalpha);
std::cout << true << ' ' << false << '\n';

std::cout << std::noboolalpha << true << ' ' << false << '\n';

std::cout << std::boolalpha << true << ' ' << false << '\n';
```

结果：

示例：

```C++
std::cout << 5 << '\n';

std::cout.setf(std::ios::showpos);
std::cout << 5 << '\n';

std::cout << std::noshowpos << 5 << '\n';

std::cout << std::showpos << 5 << '\n';
```

结果：

示例：

```C++
std::cout << 12345678.9 << '\n';

std::cout.setf(std::ios::uppercase);
std::cout << 12345678.9 << '\n';

std::cout << std::nouppercase << 12345678.9 << '\n';

std::cout << std::uppercase << 12345678.9 << '\n';
```

结果：

示例：

```C++
std::cout << 27 << '\n';

std::cout.setf(std::ios::dec, std::ios::basefield);
std::cout << 27 << '\n';

std::cout.setf(std::ios::oct, std::ios::basefield);
std::cout << 27 << '\n';

std::cout.setf(std::ios::hex, std::ios::basefield);
std::cout << 27 << '\n';

std::cout << std::dec << 27 << '\n';
std::cout << std::oct << 27 << '\n';
std::cout << std::hex << 27 << '\n';
```

结果：

现在，您应该能够看到通过标志和通过操纵器设置格式之间的关系。在未来的示例中，我们将使用操纵器，除非它们不可用。

精度、符号和小数点

使用操纵器（或标志），可以更改显示浮点数的精度和格式。有几个格式选项以某种复杂的方式组合在一起，因此我们将更仔细地看一看。

如果使用固定或科学记数法，则精度决定分数中显示的小数位数。请注意，如果精度小于有效位数，则数字将四舍五入。

```C++
std::cout << std::fixed << '\n';
std::cout << std::setprecision(3) << 123.456 << '\n';
std::cout << std::setprecision(4) << 123.456 << '\n';
std::cout << std::setprecision(5) << 123.456 << '\n';
std::cout << std::setprecision(6) << 123.456 << '\n';
std::cout << std::setprecision(7) << 123.456 << '\n';

std::cout << std::scientific << '\n';
std::cout << std::setprecision(3) << 123.456 << '\n';
std::cout << std::setprecision(4) << 123.456 << '\n';
std::cout << std::setprecision(5) << 123.456 << '\n';
std::cout << std::setprecision(6) << 123.456 << '\n';
std::cout << std::setprecision(7) << 123.456 << '\n';
```

产生结果：

如果既不使用固定数字，也不使用科学数字，则精度决定应显示多少有效数字。同样，如果精度小于有效位数，则该数字将四舍五入。

```C++
std::cout << std::setprecision(3) << 123.456 << '\n';
std::cout << std::setprecision(4) << 123.456 << '\n';
std::cout << std::setprecision(5) << 123.456 << '\n';
std::cout << std::setprecision(6) << 123.456 << '\n';
std::cout << std::setprecision(7) << 123.456 << '\n';
```

产生以下结果：

使用showpoint操纵器或标志，可以使流写入小数点和尾随零。

```C++
std::cout << std::showpoint << '\n';
std::cout << std::setprecision(3) << 123.456 << '\n';
std::cout << std::setprecision(4) << 123.456 << '\n';
std::cout << std::setprecision(5) << 123.456 << '\n';
std::cout << std::setprecision(6) << 123.456 << '\n';
std::cout << std::setprecision(7) << 123.456 << '\n';
```

产生以下结果：

下面是一个包含更多示例的汇总表：

宽度、填充字符和对齐

通常，在打印数字时，打印数字时不考虑其周围的空间。然而，可以向左或向右调整数字的打印。为了做到这一点，我们必须首先定义字段宽度，它定义了值将具有的输出空间的数量。如果实际打印的数字小于字段宽度，则它将左对齐或右对齐（按规定）。如果实际数字大于字段宽度，则不会截断它——它将溢出字段。

为了使用这些格式化程序中的任何一个，我们首先必须设置字段宽度。这可以通过width（int）成员函数或setw（）操纵器来完成。请注意，默认设置为右对齐。

```C++
std::cout << -12345 << '\n'; // print default value with no field width
std::cout << std::setw(10) << -12345 << '\n'; // print default with field width
std::cout << std::setw(10) << std::left << -12345 << '\n'; // print left justified
std::cout << std::setw(10) << std::right << -12345 << '\n'; // print right justified
std::cout << std::setw(10) << std::internal << -12345 << '\n'; // print internally justified
```

这将产生以下结果：

需要注意的一点是setw（）和width（）仅影响下一个输出语句。它们不像其他一些标志/操纵器那样是持久的。

现在，让我们设置填充字符并执行相同的示例：

```C++
std::cout.fill('*');
std::cout << -12345 << '\n'; // print default value with no field width
std::cout << std::setw(10) << -12345 << '\n'; // print default with field width
std::cout << std::setw(10) << std::left << -12345 << '\n'; // print left justified
std::cout << std::setw(10) << std::right << -12345 << '\n'; // print right justified
std::cout << std::setw(10) << std::internal << -12345 << '\n'; // print internally justified
```

这将产生输出：

请注意，字段中的所有空格都已用填充字符填充。

ostream类和iostream库包含其他可能有用的输出函数、标志和操纵器，具体取决于您需要执行的操作。与istream类一样，这些主题确实更适合于关注标准库的教程或书籍。

