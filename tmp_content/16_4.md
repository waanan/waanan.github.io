---
title: "具有成员函数的类模板"
date: 2024-06-24T18:56:16+08:00
---

在第11.6课-函数模板中，我们查看了函数模板：

```C++
template <typename T> // this is the template parameter declaration
T max(T x, T y) // this is the function template definition for max<T>
{
    return (x < y) ? y : x;
}
```

使用函数模板，我们可以定义类型模板参数（例如，类型名T），然后将它们用作函数参数（T x，T y）的类型。

在第13.13课——类模板中，我们介绍了类模板，它允许我们为类类型（结构、类和联合）的数据成员的类型使用类型模板参数：

```C++
#include <iostream>

template <typename T>
struct Pair
{
    T first{};
    T second{};
};

// Here's a deduction guide for our Pair (required in C++17 or older)
// Pair objects initialized with arguments of type T and T should deduce to Pair<T>
template <typename T>
Pair(T, T) -> Pair<T>;

int main()
{
    Pair<int> p1{ 5, 6 };        // instantiates Pair<int> and creates object p1
    std::cout << p1.first << ' ' << p1.second << '\n';

    Pair<double> p2{ 1.2, 3.4 }; // instantiates Pair<double> and creates object p2
    std::cout << p2.first << ' ' << p2.second << '\n';

    Pair<double> p3{ 7.8, 9.0 }; // creates object p3 using prior definition for Pair<double>
    std::cout << p3.first << ' ' << p3.second << '\n';

    return 0;
}
```

在本课中，我们将结合函数模板和类模板的元素，以便更仔细地查看具有成员函数的类模板。

{{< alert success >}}
**相关内容**

我们在第13.14课中讨论演绎指南——类模板参数演绎（CTAD）和演绎指南。

{{< /alert >}}

***
## 在成员函数中键入模板参数

定义为类模板参数声明的一部分的类型模板参数既可以用作数据成员的类型，也可以用作成员函数参数的类型。

在下面的示例中，我们重写了上面的Pair类模板，将其从结构转换为类：

```C++
#include <ios>       // for std::boolalpha
#include <iostream>

template <typename T>
class Pair
{
private:
    T m_first{};
    T m_second{};

public:
    // When we define a member function inside the class definition,
    // the template parameter declaration belonging to the class applies
    Pair(const T& first, const T& second)
        : m_first{ first }
        , m_second{ second }
    {
    }

    bool isEqual(const Pair<T>& pair);
};

// When we define a member function outside the class definition,
// we need to resupply a template parameter declaration
template <typename T>
bool Pair<T>::isEqual(const Pair<T>& pair)
{
    return m_first == pair.m_first && m_second == pair.m_second;
}

int main()
{
    Pair p1{ 5, 6 }; // uses CTAD to infer type Pair<int>
    std::cout << std::boolalpha << "isEqual(5, 6): " << p1.isEqual( Pair{5, 6} ) << '\n';
    std::cout << std::boolalpha << "isEqual(5, 7): " << p1.isEqual( Pair{5, 7} ) << '\n';

    return 0;
}
```

上面的内容应该非常简单，但有几点值得注意。

首先，因为我们的类具有私有成员，所以它不是聚合，因此不能使用聚合初始化。相反，我们必须使用构造函数初始化类对象。

由于类数据成员的类型为T，因此我们将构造函数类型的参数设置为constT&，因此用户可以提供相同类型的初始化值。由于T的复制成本可能很高，因此通过常量引用传递比通过值传递更安全。

注意，当我们在类模板定义中定义成员函数时，我们不需要为成员函数提供模板参数声明。这样的成员函数隐式使用类模板参数声明。

其次，我们不需要CTAD的演绎指南来处理非聚合类。匹配构造函数为编译器提供从初始值设定项推断模板参数所需的信息。

第三，让我们更仔细地看一下在类模板定义之外为类模板定义成员函数的情况：

```C++
template <typename T>
bool Pair<T>::isEqual(const Pair<T>& pair)
{
    return m_first == pair.m_first && m_second == pair.m_second;
}
```

由于该成员函数定义与类模板定义是分开的，因此我们需要重新提供模板参数声明（template<typenameT>），以便编译器知道T是什么。

此外，当我们在类之外定义成员函数时，我们需要用类模板的完全模板化名称（Pair<T>：：isEqual，而不是Pair:：isEqual）来限定成员函数名称。

***
## 在何处为类外部的类模板定义成员函数

对于类模板的成员函数，编译器需要查看类定义（以确保将成员函数模板声明为类的一部分）和模板成员函数定义（了解如何实例化模板）。因此，我们通常希望在同一位置定义类及其成员函数模板。

当在类定义中定义成员函数模板时，模板成员函数定义是类定义的一部分，因此，只要可以看到类定义，就可以看到模板成员函数的定义。这使得事情变得容易（以弄乱类定义为代价）。

当成员函数模板在类定义之外定义时，通常应在类定义的正下方定义它。这样，在任何可以看到类定义的地方，也将看到类定义下面的成员函数模板定义。

在类在头文件中定义的典型情况下，这意味着在类之外定义的任何成员函数模板也应该在类定义下面的相同头文件中进行定义。

{{< alert success >}}
**关键洞察力**

在第11.7课——函数模板实例化中，我们注意到从模板隐式实例化的函数是隐式内联的。这包括非成员和成员函数模板。因此，将头文件中定义的成员函数模板包含到多个代码文件中没有问题，因为从这些模板实例化的函数将隐式内联（并且链接器将消除它们的重复）。

{{< /alert >}}

{{< alert success >}}
**最佳做法**

在类定义之外定义的任何成员函数模板都应该在类定义的正下方定义（在同一文件中）。

{{< /alert >}}

***
## 测验时间

问题#1

编写一个名为Triad的类模板，该模板具有3个具有独立类型模板参数的私有数据成员。该类应该具有构造函数、访问函数和在类外部定义的print（）成员函数。

应编译并运行以下程序：

```C++
#include <iostream>
#include <string>

int main()
{
	Triad<int, int, int> t1{ 1, 2, 3 };
	t1.print();
	std::cout << '\n';
	std::cout << t1.first() << '\n';

	using namespace std::literals::string_literals;
	const Triad t2{ 1, 2.3, "Hello"s };
	t2.print();
	std::cout << '\n';

	return 0;
}
```

并产生输出：

显示解决方案

问题#2

如果从print（）函数声明和定义中删除const，程序将不再编译。为什么不呢？

显示解决方案

