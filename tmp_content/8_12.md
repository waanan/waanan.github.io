---
title: "内联函数"
date: 2023-11-01T20:12:31+08:00
---

考虑这样的情况，您需要编写一些代码来执行一些离散的任务，例如读取用户的输入，或将某些内容输出到文件，或计算特定的值。在实现此代码时，基本上有两个选项：

编写函数提供了许多潜在的好处，如函数中的代码：

1. 在整个程序的上下文中更容易阅读和理解。
2. 更易于使用，因为您可以在不了解其实现方式的情况下调用该函数。
3. 更容易更新，因为函数中的代码可以在一个位置更新。
4. 更易于重用，因为函数自然是模块化的。


然而，使用函数的一个缺点是，每次调用函数时，都会发生一定数量的性能开销。考虑以下示例：

```C++
#include <iostream>

int min(int x, int y)
{
    return (x < y) ? x : y;
}

int main()
{
    std::cout << min(5, 6) << '\n';
    std::cout << min(3, 2) << '\n';
    return 0;
}
```

当遇到对min（）的调用时，CPU必须存储它正在执行的当前指令的地址（以便它知道以后返回到哪里）以及各种CPU寄存器的值（以便它们可以在返回时恢复）。然后必须实例化参数x和y，然后进行初始化。然后，执行路径必须跳到min（）函数中的代码。当函数结束时，程序必须跳回到函数调用的位置，并且必须复制返回值，以便可以输出它。换句话说，每个函数调用都会产生大量的开销成本。

对于大型和/或执行复杂任务的函数，与函数运行所需的时间相比，函数调用的开销通常微不足道。然而，对于小函数（如上面的min（）），开销成本可能大于实际执行函数代码所需的时间！在经常调用小函数的情况下，使用函数可能会导致在适当的位置编写相同的代码，从而导致显著的性能损失。

***
## 内联式扩展

幸运的是，C++编译器有一个技巧可以用来避免这种开销：内联扩展是一个函数调用被被调用函数定义中的代码替换的过程。

例如，如果编译器在上例中展开了min（）调用，则生成的代码如下所示：

```C++
#include <iostream>

int main()
{
    std::cout << ((5 < 6) ? 5 : 6) << '\n';
    std::cout << ((3 < 2) ? 3 : 2) << '\n';
    return 0;
}
```

注意，对函数min（）的两个调用已被min（）函数体中的代码替换（用参数的值替换参数）。这允许我们避免这些调用的开销，同时保留代码的结果。

***
## 内联代码的性能

除了消除函数调用开销的成本外，内联扩展还允许编译器更有效地优化结果代码——例如，因为表达式（（5<6）？5:6）现在是编译时间常量，编译器可以将main（）中的第一条语句进一步优化为std:：cout<<5<<'\n'；。

然而，内联扩展有自己的潜在成本：如果被扩展的函数体比被替换的函数调用需要更多的指令，则每个内联扩展都将导致可执行文件变大。较大的可执行文件往往较慢（由于不适合缓存）。

关于函数是否会从内联中受益的决定（因为删除函数调用开销超过了更大的可执行文件的成本）并不简单。根据函数调用的相对成本、函数的大小以及可以执行的其他优化，内联扩展可能会导致性能改进、性能降低或根本不改变性能。

内联扩展最适合于简单、简短的函数（例如，不超过几个语句），特别是单个函数调用执行多次的情况（例如，循环内的函数调用）。

***
## 发生内联扩展时

每个函数都分为两类之一，其中对函数的调用：

1. 可以扩展（大多数功能都在此类别中）。
2. 无法展开。


大多数函数都属于“可以”类别：如果这样做是有益的，则可以扩展它们的函数调用。对于这一类别中的函数，现代编译器将评估每个函数和每个函数调用，以确定该特定函数调用是否将受益于内联扩展。编译器可能决定将任何、部分或所有函数调用扩展到给定函数。

{{< alert success >}}
**提示**

现代优化编译器决定何时内联扩展函数。

{{< /alert >}}

***
## inline关键字，历史记录

从历史上看，编译器要么没有能力确定内联扩展是否有益，要么不太擅长。由于这个原因，C++提供了关键字inline，该关键字旨在向编译器提示函数将从内联扩展中受益。

使用inline关键字声明的函数称为inline函数。

下面是使用inline关键字的示例：

```C++
#include <iostream>

inline int min(int x, int y) // hint to the compiler that it should do inline expansion of this function
{
    return (x < y) ? x : y;
}

int main()
{
    std::cout << min(5, 6) << '\n';
    std::cout << min(3, 2) << '\n';
    return 0;
}
```

这就是术语“内联函数”的来源（因为这样的函数具有内联说明符作为函数声明语法的一部分）。

然而，在现代C++中，inline关键字不再用于请求内联扩展函数。这有许多原因：

1. 使用内联请求内联扩展是过早优化的一种形式，误用实际上可能会损害性能。
2. inline关键字只是一个提示——编译器完全可以忽略内联函数的请求。如果您试图内联一个冗长的函数，这很可能是结果！编译器还可以自由地对不使用inline关键字作为其正常优化集的一部分的函数执行内联扩展。
3. inline关键字在错误的粒度级别定义。我们在函数定义上使用inline关键字，但内联扩展实际上是根据函数调用确定的。扩展某些函数调用可能是有益的，而扩展其他函数调用可能有害，并且没有语法会影响这一点。


现代优化编译器通常非常善于确定哪些函数应该内联生成——在大多数情况下比人类更好。因此，编译器可能会忽略或降低对内联的任何使用，以请求函数的内联扩展。

{{< alert success >}}
**对于高级读者**

某些类型的函数被隐式处理为内联函数。这些包括：

1. 在类、结构或联合类型定义内定义的函数。
2. Constexpr/consteval函数（7.14——Constexpr和consteval函数）。。
3. 从函数模板隐式实例化的函数。


{{< /alert >}}

{{< alert success >}}
**最佳做法**

不要使用inline关键字来请求函数的内联扩展。

{{< /alert >}}

***
## inline关键字，modernly

在前面的章节中，我们提到不应该在头文件中实现函数（具有外部链接），因为当这些头包含在多个.cpp文件中时，函数定义将被复制到多个.ccp文件中。然后将编译这些文件，链接器将抛出一个错误，因为它将注意到您多次定义了相同的函数，这违反了一个定义规则。

在第7.9课——跨多个文件共享全局常量（使用内联变量）中，我们注意到在现代C++中，内联概念已经发展为具有新的含义：程序中允许多个定义。函数和变量都是如此。因此，如果我们将函数标记为内联，则允许该函数具有多个定义（在不同的文件中）。

这对于仅标头库特别有用，这是一个或多个实现某些功能的标头文件（不包括.cpp文件）。仅标头库很受欢迎，因为没有需要添加到项目中才能使用的源文件，也没有需要链接的源文件。您只需#包含仅标头库，然后就可以使用它。

内联函数有两个限制：编译器需要能够在调用函数的任何位置看到内联函数的完整定义，并且所有这样的函数定义必须相同（否则将导致未定义的行为）。因此，内联函数通常在头文件中定义，其中可以将它们#包含到需要查看函数的完整定义的任何代码文件中。这确保了函数的所有定义都是相同的。

在大多数情况下，您不应该将函数标记为内联，除非您在头文件中定义它们。

{{< alert success >}}
**关键洞察力**

编译器需要能够看到内联函数的完整定义，无论它在哪里被调用，并且所有这样的定义都必须相同（否则将导致未定义的行为）

{{< /alert >}}

{{< alert success >}}
**最佳做法**

避免对函数使用inline关键字，除非您有特定的、令人信服的理由这样做（例如，您正在头文件中定义这些函数）。

{{< /alert >}}

