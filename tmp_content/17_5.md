---
title: "阵列和循环"
date: 2024-07-08T11:10:28+08:00
---

在本章的入门课（16.1——容器和数组简介）中，我们介绍了当我们有许多相关的单个变量时出现的可伸缩性挑战。在本课中，我们将重新介绍该问题，然后讨论数组如何帮助我们优雅地解决此类问题。

***
## 可变可扩展性挑战，重温

考虑这样一种情况，我们想要找到一个班级学生的平均考试成绩。为了使这些例子简洁，我们假设这个班只有5个学生。

下面是我们可以使用单个变量解决此问题的方法：

```C++
#include <iostream>

int main()
{
    // allocate 5 integer variables (each with a different name)
    int testScore1{ 84 };
    int testScore2{ 92 };
    int testScore3{ 76 };
    int testScore4{ 81 };
    int testScore5{ 56 };

    int average { (testScore1 + testScore2 + testScore3 + testScore4 + testScore5) / 5 };

    std::cout << "The class average is: " << average << '\n';

    return 0;
}
```

这是大量的变量和大量的输入。想象一下，我们要为30名学生或600名学生做多少工作。此外，如果添加了新的测试分数，则必须声明、初始化新变量，并将其添加到平均计算中。你记得更新除数吗？如果您忘记了，那么现在有一个语义错误。每当您必须修改现有代码时，都有引入错误的风险。

现在，您知道了，当我们有一组相关的变量时，应该使用数组。因此，让我们用std:：vector替换单个变量：

```C++
#include <iostream>
#include <vector>

int main()
{
    std::vector testScore { 84, 92, 76, 81, 56 };
    std::size_t length { testScore.size() };
    
    int average { (testScore[0] + testScore[1] + testScore[2] + testScore[3] + testScore[4])
        / static_cast<int>(length) };

    std::cout << "The class average is: " << average << '\n';

    return 0;
}
```

这更好——我们显著减少了定义的变量的数量，平均计算的除数现在直接由数组的长度确定。

但平均计算仍然是一个问题，因为我们必须手动逐个列出每个元素。因为我们必须显式地列出每个元素，所以我们的平均计算仅适用于具有与我们列出的元素数量完全相同的元素的数组。如果我们还希望能够平均其他长度的数组，则需要为每个不同的数组长度编写一个新的平均计算。

我们真正需要的是某种方法来访问每个数组元素，而不必显式列出每个元素。

***
## 阵列和循环

在前面的课程中，我们注意到数组下标不需要是常量表达式——它们可以是运行时表达式。这意味着我们可以使用变量的值作为索引。

还请注意，在前一示例的平均计算中使用的数组索引是升序：0、1、2、3、4。因此，如果我们有某种方法将变量按顺序设置为值0、1、2、3和4，那么我们可以只使用该变量作为数组索引，而不是文本。我们已经知道如何做到这一点——使用for循环。

让我们使用for循环重写上面的示例，其中循环变量用作数组索引：

```C++
#include <iostream>
#include <vector>

int main()
{
    std::vector testScore { 84, 92, 76, 81, 56 };
    std::size_t length { testScore.size() };

    int average { 0 };
    for (std::size_t index{ 0 }; index < length; ++index) // index from 0 to length-1
        average += testScore[index];                      // add the value of element with index `index`
    average /= static_cast<int>(length);                  // calculate the average

    std::cout << "The class average is: " << average << '\n';

    return 0;
}
```

这应该是相当简单的。索引从0开始，testScore[0]添加到平均值，并且索引增加到1。testScore[1]加到平均值上，索引增加到2。最终，当索引增加到5时，index<length为false，循环终止。

此时，循环将testScore[0]、testScore[1]、testScore[2]、testScre[3]和testScole[4]的值添加到平均值。

最后，我们通过将累积值除以数组长度来计算平均值。

该解决方案在可维护性方面是理想的。循环迭代的次数由数组的长度确定，循环变量用于执行所有数组索引。我们不再需要手动列出每个数组元素。

如果我们想添加或删除测试分数，我们可以只修改数组初始值设定项的数量，其余的代码仍然可以工作，而无需进一步更改！

以某种顺序访问容器的每个元素称为遍历，或遍历容器。遍历通常称为迭代，或者在容器上迭代或在容器中迭代。

{{< alert success >}}
**相关内容**

我们在第8.10课中讨论了循环——用于语句。

{{< /alert >}}

{{< alert success >}}
**作者注释**

由于容器类使用类型size_t作为长度和索引，因此在本课中，我们将执行相同的操作。我们将在即将到来的第16.7课——数组、循环和符号挑战解决方案中讨论使用有符号长度和索引。

{{< /alert >}}

***
## 模板、阵列和循环释放了可扩展性

数组提供了一种存储多个对象的方法，而不必命名每个元素。

循环提供了一种遍历数组的方法，而不必显式列出每个元素。

模板提供了一种参数化元素类型的方法。

模板、数组和循环一起允许我们编写可以在元素容器上操作的代码，而不管容器中的元素类型或元素数量！

为了进一步说明这一点，让我们重写上面的示例，将平均计算重构为函数模板：

```C++
#include <iostream>
#include <vector>

// Function template to calculate the average of the values in a std::vector
template <typename T>
T calculateAverage(const std::vector<T>& arr)
{
    std::size_t length { arr.size() };
    
    T average { 0 };                                      // if our array has elements of type T, our average should of type T too
    for (std::size_t index{ 0 }; index < length; ++index) // iterate through all the elements
        average += arr[index];                            // sum up all the elements
    average /= static_cast<int>(length);
    
    return average;
}

int main()
{
    std::vector class1 { 84, 92, 76, 81, 56 };
    std::cout << "The class 1 average is: " << calculateAverage(class1) << '\n'; // calc average of 5 ints

    std::vector class2 { 93.2, 88.6, 64.2, 81.0 };
    std::cout << "The class 2 average is: " << calculateAverage(class2) << '\n'; // calc average of 4 doubles
    
    return 0;
}
```

这将打印：

在上面的示例中，我们创建了函数模板calculateAverage（），它接受任意元素类型和任意长度的std:：vector，并返回平均值。在main（）中，我们演示了当使用5个int元素的数组或4个双元素的数组调用该函数时，该函数同样可以很好地工作！

calculateAverage（）将适用于支持函数内使用的运算符（operator+=（T），operator/=（int））的任何类型T。如果尝试使用不支持这些运算符的T，编译器将在尝试编译实例化函数模板时出错。

***
## 我们可以对数组和循环做什么

既然我们知道了如何使用循环遍历元素的容器，那么让我们看看可以使用容器遍历的最常见的事情。我们通常通过遍历容器来执行以下四项操作之一：

其中的前三个相当简单。我们可以使用单个循环遍历数组，根据需要检查或修改每个元素。

重新排序容器的元素要复杂得多，因为这样做通常涉及在另一个循环中使用循环。虽然我们可以手动执行此操作，但通常最好使用标准库中的现有算法来执行此操作。我们将在未来的一章中讨论算法时更详细地讨论这一点。

***
## 阵列和off-by-one错误

当使用索引遍历容器时，必须注意确保循环执行正确的次数。Off-by-one错误（循环体执行一次太多或一次太少）很容易发生。

通常，当使用索引遍历容器时，我们将从0开始索引，并循环直到索引<长度。

新程序员有时会意外地将索引<=长度用作循环条件。这将导致在索引==长度时执行循环，这将导致越界下标和未定义的行为。

***
## 测验时间

问题#1

编写一个简短的程序，使用循环将以下向量的元素打印到屏幕上：

```C++
#include <iostream>
#include <vector>

int main()
{
    std::vector arr{ 4, 6, 7, 3, 8, 2, 1, 9 };

    // Add your code here

    return 0;
}
```

输出应如下所示：

显示解决方案

问题#2

更新先前测验解决方案的代码，以便以下程序编译并具有相同的输出：

```C++
#include <iostream>
#include <vector>

// Implement printArray() here

int main()
{
    std::vector arr{ 4, 6, 7, 3, 8, 2, 1, 9 };

    printArray(arr); // use function template to print array

    return 0;
}
```

显示解决方案

问题#3

给出测试2的解决方案，执行以下操作：

1. 请用户输入介于1和9之间的值。如果用户没有输入介于1和9之间的值，则重复要求输入整数值，直到他们输入为止。如果用户输入了一个数字，然后是无关的输入，则忽略无关的输入。
2. 打印阵列。
3. 编写函数模板以在数组中搜索用户输入的值。如果值在数组中，则返回该元素的索引。如果值不在数组中，则返回适当的值。
4. 如果找到该值，请打印该值和索引。如果找不到该值，请打印该值，并说明找不到它。


我们在第9.5课中介绍了如何处理无效输入——std:：cin和处理无效输入。

下面是该程序的两个运行示例：

显示解决方案

问题#4

编写函数模板以查找std:：vector中的最大值。如果向量为空，则返回元素类型的默认值。

应执行以下代码：

```C++
int main()
{
    std::vector data1 { 84, 92, 76, 81, 56 };
    std::cout << findMax(data1) << '\n';

    std::vector data2 { -13.0, -26.7, -105.5, -14.8 };
    std::cout << findMax(data2) << '\n';

    std::vector<int> data3 { };
    std::cout << findMax(data3) << '\n';
    
    return 0;
}
```

并打印以下结果：

显示提示

显示解决方案

问题#5

在第8.10课的测验中——对于语句，我们为数字3、5和7实现了一个名为FizzBuzz的游戏。

在本次测验中，按如下方式实施游戏：

1. 只能被3整除的数字应该打印“fizz”。
2. 只能被5整除的数字应该打印“嗡嗡”。
3. 只能被7整除的数字应打印“pop”。
4. 只能被11整除的数字应该打印“bang”。
5. 只能被13整除的数字应该打印“jazz”。
6. 只能被17整除的数字应打印“pow”。
7. 只能被19整除的数字应该打印“boom”。
8. 可被上述一个以上数整除的数字应打印与其除数相关的每个单词。
9. 不能被上面任何一个整除的数字应该只打印数字。


使用std:：vector来保存除数，使用另一个std:∶vector保存单词（类型为std::string_view）。如果数组的长度不相同，则程序应该断言。产生150个数字的输出。

显示提示

显示提示

下面是前21个迭代的预期输出：

显示解决方案

