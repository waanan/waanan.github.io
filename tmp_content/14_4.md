---
title: "结构、成员和成员选择简介"
date: 2024-03-08T13:20:57+08:00
---

在编程中有许多情况下，我们需要多个变量来表示感兴趣的东西。正如我们在前一章的介绍（12.1——复合数据类型介绍）中所讨论的那样，分数有一个分子和分母，它们被链接到一个单独的数学对象中。

或者，假设我们想编写一个程序，在其中存储有关公司员工的信息。我们可能有兴趣跟踪员工的姓名、职务、年龄、员工id、经理id、工资、生日、雇佣日期等属性…

如果我们使用自变量来跟踪所有这些信息，可能会如下所示：

```C++
std::string name;
std::string title;
int age;
int id;
int managerId;
double wage;
int birthdayYear;
int birthdayMonth;
int birthdayDay;
int hireYear;
int hireMonth;
int hireDay;
```

然而，这种方法存在许多问题。首先，还不能立即清楚这些变量是否实际相关（您必须阅读注释，或者查看它们在上下文中的使用方式）。其次，现在有12个变量需要管理。如果我们想将这个雇员传递给函数，我们必须传递12个参数（并且以正确的顺序），这将把我们的函数原型和函数调用搞得一团糟。既然函数只能返回单个值，那么函数怎么会返回雇员呢？

如果我们想要一个以上的员工，我们需要为每个额外的员工定义12个以上的变量（每个变量都需要一个唯一的名称）！这显然根本无法扩展。我们真正需要的是某种方法来将所有这些相关的数据片段组织在一起，使它们更易于管理。

幸运的是，C++附带了两种旨在解决此类挑战的复合类型：结构（我们现在将介绍）和类（我们将很快探索）。结构（structure的缩写）是程序定义的数据类型（13.1——程序定义（用户定义）类型简介），它允许我们将多个变量绑定到一个类型中。正如您稍后将看到的，这使得相关变量集的管理简单得多！

***
## 定义结构

由于结构是程序定义的类型，因此在开始使用结构类型之前，我们必须首先告诉编译器结构类型的外观。下面是简化员工的结构定义示例：

```C++
struct Employee
{
    int id {};
    int age {};
    double wage {};
};
```

struct关键字用于告诉编译器我们正在定义一个结构，我们将其命名为Employee（因为程序定义的类型通常以大写字母开头）。

然后，在一对花括号内，我们定义每个Employee对象将包含的变量。在这个例子中，我们创建的每个Employee都有3个变量：intid、intage和双倍工资。作为结构一部分的变量称为数据成员（或成员变量）。

就像我们使用一组空的花括号来初始化（1.4——变量赋值和初始化）普通变量一样，每个成员变量后面的空花括号确保在创建Employee时，Employer中的成员变量被初始化。在几节课（13.7——默认成员初始化）中讨论默认成员初始化时，我们将更多地讨论这一点。

最后，我们用分号结束类型定义。

提醒一下，Employee只是一个类型定义——此时实际上没有创建任何对象。

{{< alert success >}}
**提示**

在日常语言中，成员是属于一个群体的个人。例如，您可能是篮球队的成员，而您的妹妹可能是合唱团的成员。

在C++中，成员是属于结构（或类）的变量、函数或类型。所有成员都必须在结构（或类）定义中声明。

在以后的课程中，我们将经常使用“成员”一词，因此请确保您记住它的含义。

{{< /alert >}}

***
## 定义结构对象

为了使用Employee类型，我们简单地定义了Employme类型的变量：

```C++
Employee joe {}; // Employee is the type, joe is the variable name
```

这定义了一个名为joe的Employee类型的变量。执行代码时，将实例化包含3个数据成员的Employee对象。空大括号确保对象是值初始化的。

与任何其他类型一样，可以定义相同结构类型的多个变量：

```C++
Employee joe {}; // create an Employee struct for Joe
Employee frank {}; // create an Employee struct for Frank
```

***
## 正在访问成员

考虑以下示例：

```C++
struct Employee
{
    int id {};
    int age {};
    double wage {};
};

int main()
{
    Employee joe {};

    return 0;
}
```

在上面的示例中，名称joe指的是整个结构对象（其中包含成员变量）。为了访问特定的成员变量，我们在结构变量名和成员名之间使用成员选择操作符（operator.）。例如，要访问Joe的年龄成员，我们将使用Joe.age。

结构成员变量就像普通变量一样工作，因此可以对它们进行普通操作，包括赋值、算术、比较等…

```C++
#include <iostream>

struct Employee
{
    int id {};
    int age {};
    double wage {};
};

int main()
{
    Employee joe {};

    joe.age = 32;  // use member selection operator (.) to select the age member of variable joe

    std::cout << joe.age << '\n'; // print joe's age

    return 0;
}
```

这将打印：

结构的最大优势之一是，我们只需要为每个结构变量创建一个新名称（成员名称作为结构类型定义的一部分是固定的）。在下面的示例中，我们实例化了两个Employee对象：joe和frank。

```C++
#include <iostream>

struct Employee
{
    int id {};
    int age {};
    double wage {};
};

int main()
{
    Employee joe {};
    joe.id = 14;
    joe.age = 32;
    joe.wage = 60000.0;

    Employee frank {};
    frank.id = 15;
    frank.age = 28;
    frank.wage = 45000.0;

    int totalAge { joe.age + frank.age };

    if (joe.wage > frank.wage)
        std::cout << "Joe makes more than Frank\n";
    else if (joe.wage < frank.wage)
        std::cout << "Joe makes less than Frank\n";
    else
        std::cout << "Joe and Frank make the same amount\n";

    // Frank got a promotion
    frank.wage += 5000.0;

    // Today is Joe's birthday
    ++joe.age; // use pre-increment to increment Joe's age by 1

    return 0;
}
```

在上面的示例中，很容易区分哪些成员变量属于Joe，哪些属于Frank。这提供了比单个变量更高级别的组织。此外，由于Joe和Frank的成员具有相同的名称，因此在具有相同结构类型的多个变量时，这提供了一致性。

在下一课中，我们将继续探索结构，包括查看如何初始化它们。

