---
title: "好友类和好友成员函数"
date: 2024-06-24T18:56:16+08:00
---

***
## 朋友课程

友元类是可以访问另一个类的私有成员和受保护成员的类。

下面是一个示例：

```C++
#include <iostream>

class Storage
{
private:
    int m_nValue {};
    double m_dValue {};
public:
    Storage(int nValue, double dValue)
       : m_nValue { nValue }, m_dValue { dValue }
    { }

    // Make the Display class a friend of Storage
    friend class Display;
};

class Display
{
private:
    bool m_displayIntFirst {};

public:
    Display(bool displayIntFirst)
         : m_displayIntFirst { displayIntFirst }
    {
    }

    // Because Display is a friend of Storage, Display members can access the private members of Storage
    void displayStorage(const Storage& storage)
    {
        if (m_displayIntFirst)
            std::cout << storage.m_nValue << ' ' << storage.m_dValue << '\n';
        else // display double first
            std::cout << storage.m_dValue << ' ' << storage.m_nValue << '\n';
    }

    void setDisplayIntFirst(bool b)
    {
         m_displayIntFirst = b;
    }
};

int main()
{
    Storage storage { 5, 6.7 };
    Display display { false };

    display.displayStorage(storage);

    display.setDisplayIntFirst(true);
    display.displayStorage(storage);

    return 0;
}
```

由于Display类是Storage的朋友，因此Display成员可以访问他们有权访问的任何Storage对象的私有成员。

该程序产生以下结果：

关于朋友课程的一些附加注释。

首先，尽管Display是Storage的朋友，但Display不能访问Storage对象的*this指针（因为*这实际上是一个函数参数）。

第二，友谊不是对等的。仅仅因为显示器是存储的朋友，并不意味着存储也是显示器的朋友。如果希望两个类成为彼此的朋友，则两者都必须将对方声明为朋友。

阶级友谊也是不可传递的。如果A类是B的朋友，而B是C的朋友，这并不意味着A是C的好友。

友元类声明充当被友元化的类的转发声明。这意味着我们不需要在将类绑定到朋友之前向前声明它。在上面的示例中，朋友类Display同时充当Display的向前声明和朋友声明。

{{< alert success >}}
**作者注释**

对不起，如果这一个击中有点接近家！

{{< /alert >}}

{{< alert success >}}
**对于高级读者**

友谊也不是遗传的。如果类A使B成为朋友，则从B派生的类不是A的朋友。

{{< /alert >}}

***
## 好友成员函数

您可以将单个成员函数设置为好友，而不是将整个类设置为好友。这类似于使非成员函数成为朋友，只是改为使用成员函数的名称。

然而，在现实中，这可能比预期的要复杂一些。让我们转换前面的示例，使Display:：displayStorage成为朋友成员函数。您可以尝试这样的操作：

```C++
#include <iostream>

class Display; // forward declaration for class Display

class Storage
{
private:
	int m_nValue {};
	double m_dValue {};
public:
	Storage(int nValue, double dValue)
		: m_nValue { nValue }, m_dValue { dValue }
	{
	}

	// Make the Display::displayStorage member function a friend of the Storage class
	friend void Display::displayStorage(const Storage& storage); // error: Storage hasn't seen the full definition of class Display
};

class Display
{
private:
	bool m_displayIntFirst {};

public:
	Display(bool displayIntFirst)
		: m_displayIntFirst { displayIntFirst }
	{
	}

	void displayStorage(const Storage& storage)
	{
		if (m_displayIntFirst)
			std::cout << storage.m_nValue << ' ' << storage.m_dValue << '\n';
		else // display double first
			std::cout << storage.m_dValue << ' ' << storage.m_nValue << '\n';
	}
};

int main()
{
    Storage storage { 5, 6.7 };
    Display display { false };
    display.displayStorage(storage);

    return 0;
}
```

然而，这是行不通的。为了使单个成员函数成为朋友，编译器必须看到朋友成员函数类的完整定义（而不仅仅是前向声明）。由于类Storage尚未看到类Display的完整定义，因此编译器将在尝试使成员函数成为朋友时出错。

幸运的是，通过将类Display的定义移动到类Storage的定义之前（在同一文件中，或者将Display的含义移动到头文件中，并在定义Storage之前#包括它），可以很容易地解决这个问题。

```C++
#include <iostream>

class Display
{
private:
	bool m_displayIntFirst {};

public:
	Display(bool displayIntFirst)
		: m_displayIntFirst { displayIntFirst }
	{
	}

	void displayStorage(const Storage& storage) // compile error: compiler doesn't know what a Storage is
	{
		if (m_displayIntFirst)
			std::cout << storage.m_nValue << ' ' << storage.m_dValue << '\n';
		else // display double first
			std::cout << storage.m_dValue << ' ' << storage.m_nValue << '\n';
	}
};

class Storage
{
private:
	int m_nValue {};
	double m_dValue {};
public:
	Storage(int nValue, double dValue)
		: m_nValue { nValue }, m_dValue { dValue }
	{
	}

	// Make the Display::displayStorage member function a friend of the Storage class
	friend void Display::displayStorage(const Storage& storage); // okay now
};

int main()
{
    Storage storage { 5, 6.7 };
    Display display { false };
    display.displayStorage(storage);

    return 0;
}
```

然而，我们现在有另一个问题。因为成员函数Display:：displayStorage（）使用Storage作为引用参数，并且我们刚刚将Storage的定义移到Display的定义之下，编译器将抱怨它不知道Storage是什么。我们不能通过重新排列定义顺序来修复此问题，因为这样我们将撤消以前的修复。

幸运的是，通过几个简单的步骤，这也是可以修复的。首先，我们可以添加类Storage作为前向声明，以便编译器在看到类的完整定义之前可以引用Storage。

其次，我们可以在Storage类的完整定义之后，将Display:：displayStorage（）的定义移出该类。

下面是它的样子：

```C++
#include <iostream>

class Storage; // forward declaration for class Storage

class Display
{
private:
	bool m_displayIntFirst {};

public:
	Display(bool displayIntFirst)
		: m_displayIntFirst { displayIntFirst }
	{
	}

	void displayStorage(const Storage& storage); // forward declaration for Storage needed for reference here
};

class Storage // full definition of Storage class
{
private:
	int m_nValue {};
	double m_dValue {};
public:
	Storage(int nValue, double dValue)
		: m_nValue { nValue }, m_dValue { dValue }
	{
	}

	// Make the Display::displayStorage member function a friend of the Storage class
	// Requires seeing the full definition of class Display (as displayStorage is a member)
	friend void Display::displayStorage(const Storage& storage);
};

// Now we can define Display::displayStorage
// Requires seeing the full definition of class Storage (as we access Storage members)
void Display::displayStorage(const Storage& storage)
{
	if (m_displayIntFirst)
		std::cout << storage.m_nValue << ' ' << storage.m_dValue << '\n';
	else // display double first
		std::cout << storage.m_dValue << ' ' << storage.m_nValue << '\n';
}

int main()
{
    Storage storage { 5, 6.7 };
    Display display { false };
    display.displayStorage(storage);

    return 0;
}
```

现在一切都将正确编译：类Storage的前向声明足以满足Display类中Display:：displayStorage（）的声明。Display的完整定义满足了将Display:：displayStorage（）声明为Storage的朋友。类Storage的完整定义足以满足成员函数Display:：displayStorage（）的定义。

如果这有点令人困惑，请参阅上面程序中的注释。关键点是类前向声明满足对类的引用。然而，访问类的成员需要编译器看到完整的类定义。

如果这看起来像是一种痛苦，那就是。幸运的是，这种舞蹈只是必要的，因为我们试图在单个文件中完成所有事情。更好的解决方案是将每个类定义放在单独的头文件中，成员函数定义放在相应的.cpp文件中。这样，所有的类定义都将在.cpp文件中可用，并且不需要重新排列类或函数！

***
## 测验时间

问题#1

在几何中，点是空间中的位置。我们可以将三维空间中的点定义为坐标x、y和z的集合。例如，点{2.0、1.0、0.0}将是坐标空间x=2.0、y=1.0和z=0.0处的点。

在物理学中，向量是具有大小（长度）和方向（但没有位置）的量。我们可以将三维空间中的向量定义为x、y和z值，表示向量沿x、y、z轴的方向（长度可以从中导出）。例如，Vector{2.0，0.0，0.0}将是表示沿x轴正方向的向量（仅），长度为2.0。

向量可以应用于点，以将点移动到新位置。这是通过将向量的方向添加到点的位置来实现的，以产生新的位置。例如，点{2.0，1.0，0.0}+Vector{2.0，0.0，0.0}将产生点{4.0，1.0，0.01}。

这样的点和向量通常用于计算机图形学（其中点表示形状的顶点，向量表示形状的移动）。

给定以下程序：

```C++
#include <iostream>

class Vector3d
{
private:
	double m_x{};
	double m_y{};
	double m_z{};

public:
	Vector3d(double x, double y, double z)
		: m_x{x}, m_y{y}, m_z{z}
	{
	}

	void print() const
	{
		std::cout << "Vector(" << m_x << ", " << m_y << ", " << m_z << ")\n";
	}
};

class Point3d
{
private:
	double m_x{};
	double m_y{};
	double m_z{};

public:
	Point3d(double x, double y, double z)
		: m_x{x}, m_y{y}, m_z{z}
	{ }

	void print() const
	{
		std::cout << "Point(" << m_x << ", " << m_y << ", " << m_z << ")\n";
	}

	void moveByVector(const Vector3d& v)
	{
		// implement this function as a friend of class Vector3d
	}
};

int main()
{
	Point3d p { 1.0, 2.0, 3.0 };
	Vector3d v { 2.0, 2.0, -3.0 };

	p.print();
	p.moveByVector(v);
	p.print();

	return 0;
}
```

>步骤#1

使Point3d成为Vector3d的朋友类，并实现函数Point3d:：moveByVector（）。

显示解决方案

>步骤#2

与其使类Point3d成为类Vector3d的朋友，不如使成员函数Point3d:：moveByVector成为类Vetor3d的朋友。

显示解决方案

>步骤#3

使用5个单独的文件重新实现前一步骤的解决方案：Point3d.h、Point3d.cpp、Vector3d.h，Vector3d.cpp和main.cpp。

感谢读者湿婆的建议和解决方案。

显示解决方案

