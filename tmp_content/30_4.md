---
title: "流状态和输入验证"
date: 2025-03-02T00:53:53+08:00
---

***
## 流状态

ios_base类包含多个状态标志，用于通知使用流时可能发生的各种情况：

尽管这些标志存在于ios_base中，但由于ios是从ios_bases派生的，并且ios比ios_base需要更少的类型，因此它们通常通过ios访问（例如，作为std:：ios:：failbit）。

ios还提供了许多成员函数，以便方便地访问这些状态：

最常见的处理位是故障位，它是在用户输入无效输入时设置的。例如，考虑以下程序：

```C++
std::cout << "Enter your age: ";
int age {};
std::cin >> age;
```

请注意，该程序需要用户输入整数。然而，如果用户输入非数字数据，如“Alex”，cin将无法提取任何到年龄的内容，并且将设置故障位。

如果发生错误，并且流被设置为良好位以外的任何值，则将忽略该流上的进一步流操作。可以通过调用clear（）函数来清除此条件。

***
## 输入验证

输入验证是检查用户输入是否满足某组标准的过程。输入验证通常可以分为两种类型：字符串和数字。

通过字符串验证，我们将所有用户输入作为字符串接受，然后根据字符串的格式是否适当来接受或拒绝该字符串。例如，如果我们要求用户输入电话号码，我们可能希望确保他们输入的数据有十个数字。在大多数语言（特别是像Perl和PHP这样的脚本语言）中，这是通过正则表达式完成的。C++标准库也有一个正则表达式库。由于与手动字符串验证相比，正则表达式速度较慢，因此只有在性能（编译时和运行时）不受关注或手动验证过于繁琐的情况下才应使用它们。

对于数值验证，我们通常关注的是确保用户输入的数字在特定范围内（例如，在0和20之间）。然而，与字符串验证不同，用户可以输入根本不是数字的东西——我们也需要处理这些情况。

为了帮助我们，C++提供了许多有用的函数，我们可以使用这些函数来确定特定的字符是数字还是字母。cctype标头中存在以下函数：

***
## 字符串验证

让我们通过要求用户输入他们的名字来进行一个简单的字符串验证。我们的验证标准是用户只输入字母字符或空格。如果遇到任何其他情况，输入将被拒绝。

对于可变长度输入，验证字符串的最佳方法（除了使用正则表达式库）是单步执行字符串的每个字符，并确保它符合验证标准。这正是我们在这里要做的，或者更好，这就是std:：all_of为我们做的。

```C++
#include <algorithm> // std::all_of
#include <cctype> // std::isalpha, std::isspace
#include <iostream>
#include <ranges>
#include <string>
#include <string_view>

bool isValidName(std::string_view name)
{
  return std::ranges::all_of(name, [](char ch) {
    return std::isalpha(ch) || std::isspace(ch);
  });

  // Before C++20, without ranges
  // return std::all_of(name.begin(), name.end(), [](char ch) {
  //    return std::isalpha(ch) || std::isspace(ch);
  // });
}

int main()
{
  std::string name{};

  do
  {
    std::cout << "Enter your name: ";
    std::getline(std::cin, name); // get the entire line, including spaces
  } while (!isValidName(name));

  std::cout << "Hello " << name << "!\n";
}
```

注意，这段代码并不完美：用户可以说他们的名字是“asfwjweosdiweao”或其他一些胡言乱语，或者更糟的是，只是一堆空格。我们可以通过改进验证标准来稍微解决这个问题，使其仅接受包含至少一个字符和最多一个空格的字符串。

现在，让我们来看另一个例子，我们将要求用户输入他们的电话号码。与用户名（长度可变，每个字符的验证标准相同）不同，电话号码是固定长度的，但验证标准因字符的位置而异。因此，我们将采取不同的方法来验证我们的电话号码输入。在这种情况下，我们将编写一个函数，该函数将根据预定的模板检查用户的输入，以查看它是否匹配。模板的工作方式如下：

#将匹配用户输入中的任何数字。@将匹配用户输入中的任何字母字符。_将匹配任何空白。A？将匹配任何内容。否则，用户输入和模板中的字符必须完全匹配。

因此，如果我们要求函数匹配模板“（###）###-####”，这意味着我们希望用户输入一个“（”字符、三个数字、一个“）”字符、一个空格、三个数、一个破折号和四个以上的数字。如果这些东西中的任何一个不匹配，输入将被拒绝。

代码如下：

```C++
#include <algorithm> // std::equal
#include <cctype> // std::isdigit, std::isspace, std::isalpha
#include <iostream>
#include <map>
#include <ranges>
#include <string>
#include <string_view>

bool inputMatches(std::string_view input, std::string_view pattern)
{
    if (input.length() != pattern.length())
    {
        return false;
    }

    // This table defines all special symbols that can match a range of user input
    // Each symbol is mapped to a function that determines whether the input is valid for that symbol
    static const std::map<char, int (*)(int)> validators{
      { '#', &std::isdigit },
      { '_', &std::isspace },
      { '@', &std::isalpha },
      { '?', [](int) { return 1; } }
    };

    // Before C++20, use
    // return std::equal(input.begin(), input.end(), pattern.begin(), [](char ch, char mask) -> bool {
    // ...

    return std::ranges::equal(input, pattern, [](char ch, char mask) -> bool {
        auto found{ validators.find(mask) };
        
        if (found != validators.end())
        {
            // The pattern's current element was found in the validators. Call the
            // corresponding function.
            return (*found->second)(ch);
        }

        // The pattern's current element was not found in the validators. The
        // characters have to be an exact match.
        return ch == mask;
        }); // end of lambda
}

int main()
{
    std::string phoneNumber{};

    do
    {
        std::cout << "Enter a phone number (###) ###-####: ";
        std::getline(std::cin, phoneNumber);
    } while (!inputMatches(phoneNumber, "(###) ###-####"));

    std::cout << "You entered: " << phoneNumber << '\n';
}
```

使用此函数，我们可以强制用户精确匹配我们的特定格式。然而，该函数仍然受到几个约束：if#、@、_和？是用户输入中的有效字符，该函数将不起作用，因为这些符号已被赋予特殊含义。此外，与正则表达式不同，没有表示“可以输入可变数量的字符”的模板符号。因此，这样的模板不能用于确保用户输入由空白分隔的两个单词，因为它不能处理单词长度可变的事实。对于此类问题，非模板方法通常更合适。

{{< alert success >}}
**作者注释**

读者“Waldo”提供了一个C++20解决方案（使用std:：ranges），解决了这里的这些缺点

{{< /alert >}}

***
## 数字验证

处理数值输入时，显而易见的方法是使用提取操作符将输入提取为数值类型。通过检查故障位，我们可以知道用户是否输入了数字。

让我们试试这种方法：

```C++
#include <iostream>
#include <limits>

int main()
{
    int age{};

    while (true)
    {
        std::cout << "Enter your age: ";
        std::cin >> age;

        if (std::cin.fail()) // no extraction took place
        {
            std::cin.clear(); // reset the state bits back to goodbit so we can use ignore()
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // clear out the bad input from the stream
            continue; // try again
        }

        if (age <= 0) // make sure age is positive
            continue;

        break;
    }

    std::cout << "You entered: " << age << '\n';
}
```

如果用户输入整数，则提取将成功。std:：cin.fail（）将计算为false，跳过条件，并且（假设用户输入了一个正数），我们将命中break语句，退出循环。

如果用户输入以字母开头的输入，则提取将失败。std:：cin.fail（）将计算为true，我们将进入条件。在条件块的末尾，我们将点击continue语句，该语句将跳回到while循环的顶部，用户将被要求再次输入输入。

然而，还有一种情况我们尚未测试，那就是用户输入一个以数字开头但随后包含字母的字符串（例如“34abcd56”）。在这种情况下，起始数字（34）将被提取到年龄中，字符串的其余部分（“abcd56”）将留在输入流中，并且不会设置故障位。这会导致两个潜在问题：

让我们解决第一个问题。这很容易：

```C++
#include <iostream>
#include <limits>

int main()
{
    int age{};

    while (true)
    {
        std::cout << "Enter your age: ";
        std::cin >> age;

        if (std::cin.fail()) // no extraction took place
        {
            std::cin.clear(); // reset the state bits back to goodbit so we can use ignore()
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // clear out the bad input from the stream
            continue; // try again
        }

        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // clear out any additional input from the stream

        if (age <= 0) // make sure age is positive
            continue;

      break;
    }

    std::cout << "You entered: " << age << '\n';
}
```

如果您不希望这样的输入有效，我们将不得不做一些额外的工作。幸运的是，前面的解决方案使我们走到了一半。我们可以使用gcount（）函数来确定忽略了多少个字符。如果输入有效，gcount（）应该返回1（被丢弃的换行符）。如果返回大于1，则用户输入了未正确提取的内容，我们应该要求他们输入新的输入。下面是一个例子：

```C++
#include <iostream>
#include <limits>

int main()
{
    int age{};

    while (true)
    {
        std::cout << "Enter your age: ";
        std::cin >> age;

        if (std::cin.fail()) // no extraction took place
        {
            std::cin.clear(); // reset the state bits back to goodbit so we can use ignore()
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // clear out the bad input from the stream
            continue; // try again
        }

        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // clear out any additional input from the stream
        if (std::cin.gcount() > 1) // if we cleared out more than one additional character
        {
            continue; // we'll consider this input to be invalid
        }

        if (age <= 0) // make sure age is positive
        {
            continue;
        }

        break;
    }

    std::cout << "You entered: " << age << '\n';
}
```

***
## 作为字符串的数字验证

为了得到一个简单的值，上面的示例做了相当多的工作！处理数字输入的另一种方法是将其作为字符串读入，然后尝试将其转换为数字类型。以下程序使用该方法：

```C++
#include <charconv> // std::from_chars
#include <iostream>
#include <limits>
#include <optional>
#include <string>
#include <string_view>

// std::optional<int> returns either an int or nothing
std::optional<int> extractAge(std::string_view age)
{
    int result{};
    const auto end{ age.data() + age.length() }; // get end iterator of underlying C-style string

    // Try to parse an int from age
    // If we got an error of some kind...
    if (std::from_chars(age.data(), end, result).ec != std::errc{})
    {
        return {}; // return nothing
    }

    if (result <= 0) // make sure age is positive
    {
        return {}; // return nothing
    }

    return result; // return an int value
}

int main()
{
    int age{};

    while (true)
    {
        std::cout << "Enter your age: ";
        std::string strAge{};

        // Try to get a line of input
        if (!std::getline(std::cin >> std::ws, strAge))
        {
            // If we failed, clean up and try again
            std::cin.clear();
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');    
            continue;
        }

        // Try to extract the age
        auto extracted{ extractAge(strAge) };

        // If we failed, try again
        if (!extracted)
            continue;

        age = *extracted; // get the value
        break;
    }

  std::cout << "You entered: " << age << '\n';
}
```

这种方法是否比直接的数字提取工作得多，取决于您的验证参数和限制。

正如您所看到的，在C++中进行输入验证是一项大量的工作。幸运的是，许多这样的任务（例如，作为字符串进行数字验证）可以很容易地转换为可以在各种情况下重用的函数。

