---
title: "std:：数组长度和索引"
date: 2024-08-13T13:06:02+08:00
---

在第16.3课——std:：vector和无符号长度和下标问题中，我们讨论了让标准库容器类对长度和索引使用无符号值的不幸决定。因为std:：array是标准库容器类，所以它也会遇到相同的问题。

在本课中，我们将回顾索引和获取std:：数组长度的方法。由于std:：vector和std:∶array具有类似的接口，因此这将与我们为std::vector介绍的内容并行。但由于只有std:：array完全支持constexpr，所以我们将更多地关注它。

在继续之前，现在是刷新您关于“符号转换正在缩小转换，constexpr除外”的记忆的好时机（请参见16.3--std:：vector和无符号长度和下标问题）。

***
## std:：数组的长度的类型为std:：size_t

std:：array实现为模板结构，其声明如下：

```C++
template<typename T, std::size_t N> // N is a non-type template parameter
struct array;
```

正如您所看到的，表示数组长度（N）的非类型模板参数的类型为std:：size_t。正如您现在可能知道的那样，std:：size_t是一个大型无符号整数类型。

因此，当我们定义std:：数组时，长度非类型模板参数必须具有类型std:∶size_t，或者可以转换为类型std:：size_t.由于该值必须是constexpr，因此在使用有符号整数值时不会遇到符号转换问题，因为编译器会很高兴地在编译时将有符号整值转换为std:：size _t，而不会将其视为收缩转换。

{{< alert success >}}
**相关内容**

我们在第13.13课（第11.10课——非类型模板参数）中介绍了类模板（包括结构模板）。

{{< /alert >}}

{{< alert success >}}
**作为旁白…**

在C++23之前，C++甚至没有std:：size_t的文字后缀，因为在需要constexpr std：：size_t的情况下，从int到std:。

添加后缀主要是为了进行类型扣除，因为constexpr auto x{0}将为您提供int，而不是std:：size_t。在这种情况下，能够区分0（int）和0UZ（std:∶size_t），而不必使用显式static_cast是有用的。

{{< /alert >}}

***
## 数组的长度和索引的类型为size_type，它始终是std:：size_t

就像std:：vector一样，std:∶array定义了一个名为size_type的嵌套typedef成员，它是用于容器长度（和索引，如果支持）的类型的别名。在std:：array的情况下，size_type始终是std:：size_t的别名。

请注意，定义std:：数组长度的非类型模板参数被显式定义为std:：size_t，而不是size_type。这是因为size_type是std:：array的成员，并且在该点没有定义。这是唯一显式使用std:：size_t的地方——其他地方都使用size_type。

***
## 获取std:：数组的长度

有三种常用的方法来获取std:：array对象的长度。

首先，我们可以使用size（）成员函数（该函数将长度返回为unsigned size_type）来询问std:：array对象的长度：

```C++
#include <array>
#include <iostream>

int main()
{
    constexpr std::array arr { 9.0, 7.2, 5.4, 3.6, 1.8 };
    std::cout << "length: " << arr.size() << '\n'; // returns length as type `size_type` (alias for `std::size_t`)
    return 0;
}
```

这将打印：

与同时具有length（）和size（）成员函数（执行相同的操作）的std:：string和std:：string_view不同，std::array（以及C++中的大多数其他容器类型）仅具有size（。

其次，在C++17中，我们可以使用std:：size（）非成员函数（对于std:∶array，该函数仅调用size（.）成员函数，从而将长度返回为无符号size_type）。

```C++
#include <array>
#include <iostream>

int main()
{
    constexpr std::array arr{ 9, 7, 5, 3, 1 };
    std::cout << "length: " << std::size(arr); // C++17, returns length as type `size_type` (alias for `std::size_t`)

    return 0;
}
```

最后，在C++20中，我们可以使用std:：ssize（）非成员函数，该函数将长度返回为一个大的有符号整数类型（通常为std:：ptrdiff_t）：

```C++
#include <array>
#include <iostream>

int main()
{
    constexpr std::array arr { 9, 7, 5, 3, 1 };
    std::cout << "length: " << std::ssize(arr); // C++20, returns length as a large signed integral type

    return 0;
}
```

这是三个函数中唯一一个将长度返回为有符号类型的函数。

***
## 获取std:：数组的长度作为constexpr值

由于std:：数组的长度是constexpr，因此上面的每个函数都将以constexp值的形式返回std:数组的长度（即使在非constexpr-std::array对象上调用）！这意味着我们可以在常量表达式中使用这些函数中的任何一个，并且返回的长度可以隐式转换为int，而不会进行收缩转换：

```C++
#include <array>
#include <iostream>

int main()
{
    std::array arr { 9, 7, 5, 3, 1 }; // note: not constexpr for this example
    constexpr int length{ std::size(arr) }; // ok: return value is constexpr std::size_t and can be converted to int, not a narrowing conversion

    std::cout << "length: " << length << '\n';

    return 0;
}
```

{{< alert success >}}
**对于Visual Studio用户**

Visual Studio错误地触发了上述示例的警告C4365。该问题已报告给Microsoft。

{{< /alert >}}

{{< alert success >}}
**警告**

由于语言缺陷，在通过（const）引用传递的std:：array函数参数上调用时，上述函数将返回非常量表达式值：

```C++
#include <array>
#include <iostream>

void foo(const std::array<int, 5> &arr)
{
    constexpr int length{ std::size(arr) }; // compile error!
    std::cout << "length: " << length << '\n';
}

int main()
{
    std::array arr { 9, 7, 5, 3, 1 };
    constexpr int length{ std::size(arr) }; // works just fine
    std::cout << "length: " << length << '\n';

    foo(arr);

    return 0;
}
```

P2280在C++23中解决了此缺陷。在编写本文时，目前很少有编译器支持此功能。

解决方法是使foo（）成为函数模板，其中数组长度是非类型模板参数。然后可以在函数内部使用此非类型模板参数。我们在第17.3课中进一步讨论了这一点——传递和返回std:：array。

{{< /alert >}}

***
## 使用运算符[]或at（）成员函数订阅std:：数组

在上一课17.1——std:：array简介中，我们介绍了索引std:∶array的最常见方法是使用下标操作符（操作符[]）。在这种情况下不进行边界检查，传入无效索引将导致未定义的行为。

就像std:：vector一样，std:∶array也有一个at（）成员函数，该函数通过运行时边界检查来进行订阅。我们建议避免使用此函数，因为我们通常希望在索引之前进行边界检查，或者希望进行编译时边界检查。

这两个函数都要求索引的类型为size_type（std:：size_t）。

如果使用constexpr值调用这两个函数中的任何一个，编译器将对std:：size_t执行constexpr转换。这不被认为是收缩转换，因此您不会在这里遇到符号问题。

然而，如果使用非constexpr有符号整数值调用这两个函数中的任何一个，则将认为对std:：size_t的转换正在缩小，编译器可能会发出警告。在第16.3课中，我们进一步讨论了这种情况（使用std:：vector）——std:∶vector和无符号长度和下标问题。

***
## std:：get（）对constexpr索引执行编译时边界检查

由于std:：数组的长度是constexpr，因此如果我们的索引也是constexp值，则编译器应该能够在编译时验证constexpl索引是否在数组的边界内（如果constexpn索引超出边界，则停止编译）。

然而，操作符[]不按定义进行边界检查，at（）成员函数仅执行运行时边界检查。函数参数不能是constexpr（即使是consteexpr或consteval函数），那么我们如何传递constexpl索引呢？

要在有constexpr索引时进行编译时边界检查，可以使用std:：get（）函数模板，该模板将索引作为非类型模板参数：

```C++
#include <array>
#include <iostream>

int main()
{
    constexpr std::array prime{ 2, 3, 5, 7, 11 };

    std::cout << std::get<3>(prime); // print the value of element with index 3
    std::cout << std::get<9>(prime); // invalid index (compile error)

    return 0;
}
```

在std:：get（）的实现内部，有一个static_assert，它检查以确保非类型模板参数小于数组长度。如果不是，则static_assert将因编译错误而停止编译过程。

由于模板参数必须是constexpr，因此只能使用constexpl索引调用std:：get（）。

***
## 测验时间

问题#1

使用以下值初始化std:：数组：'h'，'e'，'l'，'1'，'o'。打印数组的长度，然后使用操作符[]、at（）和std:：get（）打印索引为1的元素的值。

程序应打印：

显示解决方案

