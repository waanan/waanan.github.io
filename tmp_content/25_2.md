---
title: "派生类的构造顺序"
date: 2024-10-08T17:45:57+08:00
---

在上一课关于C++中的基本继承的内容中，您学习了类可以从其他类继承成员和函数。在本课中，我们将更仔细地看一看在实例化派生类时发生的构造顺序。首先，让我们介绍一些新的类，这些类将帮助我们说明一些重要的观点。ClassBase{public:intm_id{}；基（int id=0）：m_id{id}{}int getId（）常量{return m_id；}}；派生类：public Base{public:double m_cost{}；派生（双成本=0.0）：m_cost{cost}{}double getCost（）const{return m_cost；}}；在这个例子中，Derived类是从Base类派生的。由于Derived从Base继承函数和变量，因此您可以假设Base的成员被复制到Derived。然而，这不是真的。相反，我们可以将“衍生”视为一个由两部分组成的类：一部分“衍生”，一部分“基础”。您已经看到了大量例子，说明当我们实例化一个普通（非派生）类时会发生什么：intmain（）{Base-Base；return 0；}Base是一个非派生类，因为它不从任何其他类继承。C++为Base分配内存，然后调用Base的默认构造函数来进行初始化。现在让我们看看实例化派生类时会发生什么：intmain（）{derived-derived；return 0；}如果您自己尝试，您不会注意到与前面实例化非派生类Base的示例有任何不同。但在幕后，情况略有不同。如上所述，衍生实际上是两个部分：基础零件和衍生零件。当C++构造派生对象时，它分阶段进行。首先，构造最多的基类（在继承树的顶部）。然后按顺序构造每个子类，直到最后构造大多数子类（位于继承树的底部）。因此，当我们实例化Derived的实例时，首先构造Deriveed的Base部分（使用Base默认构造函数）。一旦基本部分完成，就构建衍生部分（使用衍生默认构造函数）。此时，没有更多的派生类，因此我们完成了。这个过程实际上很容易说明#include<iostream>class Base{public:int m_id{}；基（int id=0）：m_id{id}{std:：cout<<“Base\n”；}int getId（）常量{return m_id；}}；派生类：public Base{public:double m_cost{}；派生（双成本=0.0）：m_cost{cost}{std:：cout<<“Derived\n”；}双getCost（）const{return m_cost；}}；int main（）{std:：cout<<“实例化Base\n”；Base Base；std:；cout<<<“Instantiating Derived\n”；派生派生；返回0；}此程序产生以下结果：实例化基址实例化派生基址如您所见，当构造Derived时，首先构造Derive的Base部分。这是有意义的：从逻辑上讲，没有父级，子级就不能存在。这也是做事情的安全方法：子类通常使用来自父类的变量和函数，但父类不知道子类的任何信息。首先实例化父类可以确保在创建派生类并准备使用它们时，这些变量已经初始化。继承链的构造顺序有时类是从其他类派生的，这些类本身也是从其他类衍生的。例如：#include<iostream>ClassA{public:A（）{std:：cout<<“A\n”；}}；类B:public A{public:B（）{std:：cout<<“B\n”；}}；类C:public B{public:C（）{std:：cout<<“C\n”；}}；类D:public C{public:D（）{std:：cout<<“D\n”；}}；记住，C++总是首先构造“第一个”或“最基本”类。然后，它按顺序遍历继承树，并构造每个连续的派生类。下面是一个简短的程序，它说明了整个继承链的创建顺序。int main（）{std:：cout<<“构造a:\n”；a a；std:；cout<>“构造B:\n”，B B；std::：cout<“构造C:\n”；C C；std::cout<=“构造D:\n”。D D；}此代码打印以下内容：构造a:a构造B:a构造C:a B C构造D:a B C结论C++分阶段构造派生类，从最基本的类开始（位于继承树），并完成大多数子类（在继承树的底部）。在构造每个类时，调用该类的适当构造函数来初始化类的该部分。您将注意到，本节中的示例类都使用了基类默认构造函数（为了简单起见）。在下一课中，我们将更仔细地研究构造函数在构造派生类过程中的作用（包括如何显式选择希望派生类使用的基类构造函数）。下一个lesson24.4派生类的构造函数和初始化返回目录上一个leson24.2 C中的基本继承++

