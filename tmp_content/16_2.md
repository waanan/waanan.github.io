---
title: "嵌套类型（成员类型）"
date: 2024-06-24T18:56:16+08:00
---

考虑以下简短计划：

```C++
#include <iostream>

enum class FruitType
{
	apple,
	banana,
	cherry
};

class Fruit
{
private:
	FruitType m_type { };
	int m_percentageEaten { 0 };

public:
	Fruit(FruitType type) :
		m_type { type }
	{
	}

	FruitType getType() { return m_type; }
	int getPercentageEaten() { return m_percentageEaten; }

	bool isCherry() { return m_type == FruitType::cherry; }

};

int main()
{
	Fruit apple { FruitType::apple };
	
	if (apple.getType() == FruitType::apple)
		std::cout << "I am an apple";
	else
		std::cout << "I am not an apple";
	
	return 0;
}
```

这个程序没有问题。但由于枚举类FruitType旨在与Fruit类一起使用，因此让它独立于类存在让我们推断它们是如何连接的。

***
## 嵌套类型（成员类型）

到目前为止，我们已经看到了具有两种不同类型的成员的类类型：数据成员和成员函数。在上面的例子中，我们的Fruit类同时具有这两个特性。

类类型支持另一种类型的成员：嵌套类型（也称为成员类型）。要创建嵌套类型，只需在类内的适当访问说明符下定义类型。

下面是与上面相同的程序，重写为使用在Fruit类中定义的嵌套类型：

```C++
#include <iostream>

class Fruit
{
public:
	// FruitType has been moved inside the class, under the public access specifier
        // We've also renamed it Type and made it an enum rather than an enum class
	enum Type
	{
		apple,
		banana,
		cherry
	};

private:
	Type m_type {};
	int m_percentageEaten { 0 };

public:
	Fruit(Type type) :
		m_type { type }
	{
	}

	Type getType() { return m_type;  }
	int getPercentageEaten() { return m_percentageEaten;  }

	bool isCherry() { return m_type == cherry; } // Inside members of Fruit, we no longer need to prefix enumerators with FruitType::
};

int main()
{
	// Note: Outside the class, we access the enumerators via the Fruit:: prefix now
	Fruit apple { Fruit::apple };
	
	if (apple.getType() == Fruit::apple)
		std::cout << "I am an apple";
	else
		std::cout << "I am not an apple";
	
	return 0;
}
```

这里有几点值得指出。

首先，请注意，FruitType现在在类中定义，由于我们稍后将讨论的原因，它已被重命名为Type。

其次，在类的顶部定义了嵌套类型type。嵌套类型名称在使用之前必须完全定义，因此通常首先定义它们。

第三，嵌套类型遵循正常的访问规则。类型是在公共访问说明符下定义的，因此类型名称和枚举数可以由公共直接访问。

第四，类类型充当中声明的名称的作用域区域，就像命名空间一样。因此，Type的完全限定名为Fruit:：Type，而apple枚举器的完全限定名称为Fruit：：apple。

在类的成员中，我们不需要使用完全限定名。例如，在成员函数isCherry（）中，我们在没有Fruit:：scope限定符的情况下访问樱桃枚举器。

在类之外，我们必须使用完全限定的名称（例如，水果：：苹果）。我们将FruitType重命名为Type，以便可以将其访问为Fruit:：Type（而不是更冗余的Fruit：：FruitType.）。

最后，我们将枚举类型从作用域更改为非作用域。由于类本身现在充当作用域区域，因此也使用作用域枚举器有点多余。更改为未限定范围的枚举意味着我们可以以Fruit:：apple的形式访问枚举器，而不是在枚举器被限定范围时必须使用的较长的Fruit：：Type:：apple。

{{< alert success >}}
**最佳做法**

在类类型的顶部定义任何嵌套类型。

{{< /alert >}}

***
## 嵌套的typedef和类型别名

类类型还可以包含嵌套的typedef或类型别名：

```C++
#include <iostream>
#include <string>
#include <string_view>

class Employee
{
public:
    using IDType = int;

private:
    std::string m_name{};
    IDType m_id{};
    double m_wage{};

public:
    Employee(std::string_view name, IDType id, double wage)
        : m_name { name }
        , m_id { id }
        , m_wage { wage }
    {
    }

    const std::string& getName() { return m_name; }
    IDType getId() { return m_id; } // can use unqualified name within class
};

int main()
{
    Employee john { "John", 1, 45000 };
    Employee::IDType id { john.getId() }; // must use fully qualified name outside class

    std::cout << john.getName() << " has id: " << id << '\n';

    return 0;
}
```

这将打印：

请注意，在类内部，我们只能使用IDType，但在类外部，我们必须使用完全限定名Employee:：IDType。

我们在第10.7课中讨论了类型别名的好处——Typedef和类型别名，它们在这里的作用是相同的。C++标准库中的类通常使用嵌套的typedef。截至编写时，std:：string定义了十个嵌套的typedef！

***
## 嵌套类和对外部类成员的访问

类将其他类作为嵌套类型是相当少见的，但这是可能的。在C++中，嵌套类不能访问外部（包含）类的该指针，因此嵌套类不能直接访问外部类的成员。这是因为嵌套类可以独立于外部类进行实例化（在这种情况下，将没有可访问的外部类成员！）

然而，由于嵌套类是外部类的成员，因此它们可以访问范围内外部类的任何私有成员。

让我们用一个例子来说明：

```C++
#include <iostream>
#include <string>
#include <string_view>

class Employee
{
public:
    using IDType = int;

    class Printer
    {
    public:
        void print(const Employee& e) const
        {
            // Printer can't access Employee's `this` pointer
            // so we can't print m_name and m_id directly
            // Instead, we have to pass in an Employee object to use
            // Because Printer is a member of Employee,
            // we can access private members e.m_name and e.m_id directly
            std::cout << e.m_name << " has id: " << e.m_id << '\n';
        }
    };

private:
    std::string m_name{};
    IDType m_id{};
    double m_wage{};

public:
    Employee(std::string_view name, IDType id, double wage)
        : m_name{ name }
        , m_id{ id }
        , m_wage{ wage }
    {
    }

    // removed the access functions in this example (since they aren't used)
};

int main()
{
    const Employee john{ "John", 1, 45000 };
    const Employee::Printer p{}; // instantiate an object of the inner class
    p.print(john);

    return 0;
}
```

这将打印：

有一种情况下，嵌套类更常用。在标准库中，大多数迭代器类都被实现为容器的嵌套类，它们被设计为在容器上迭代。例如，std:：string:：iterator被实现为std:∶string的嵌套类。我们将在未来的一章中介绍迭代器。

***
## 嵌套类型不能向前声明

嵌套类型还有一个值得一提的限制——嵌套类型不能被前向声明。在C++的未来版本中，可以取消此限制。

