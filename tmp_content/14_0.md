---
title: "程序定义（用户定义）类型简介"
date: 2024-03-08T13:20:57+08:00
---

因为基本类型被定义为核心C++语言的一部分，所以它们可以立即使用。例如，如果要定义类型为int或double的变量，我们可以这样做：

```C++
int x; // define variable of fundamental type 'int'
double d; // define variable of fundamental type 'double'
```

这对于作为基本类型（包括函数、指针、引用和数组）的简单扩展的复合类型也是如此：

```C++
void fcn(int) {}; // define a function of type void()(int)
int* ptr; // define variable of compound type 'pointer to int'
int& ref { x }; // define variable of compound type 'reference to int' (initialized with x)
int arr[5]; // define an array of 5 integers of type int[5] (we'll cover this in a future chapter)
```

这是可行的，因为C++语言已经知道这些类型的类型名称（和符号）意味着什么——我们不需要提供或导入任何定义。

然而，考虑类型别名的情况（在第10.7课中介绍——Typedef和类型别名），它允许我们为现有类型定义新名称。由于类型别名将新标识符引入程序，因此必须定义类型别名才能使用：

```C++
#include <iostream>

using length = int; // define a type alias with identifier 'length'

int main()
{
    length x { 5 }; // we can use 'length' here since we defined it above
    std::cout << x << '\n';

    return 0;
}
```

如果我们省略长度的定义，编译器将不知道长度是什么，并且在我们尝试使用该类型定义变量时会抱怨。长度的定义并不创建对象——它只是告诉编译器长度是什么，以便以后可以使用。

***
## 什么是用户定义/程序定义的类型？

回到前一章的介绍（12.1——复合数据类型介绍），我们介绍了想要存储分数的挑战，分数具有概念上连接在一起的分子和分母。在那节课中，我们讨论了使用两个单独的整数独立存储分数的分子和分母的一些挑战。

如果C++有内置的分数类型，那将是完美的——但它没有。C++没有包括数百种其他可能有用的类型，因为它不可能预测某人可能需要的所有内容（更不用说实现和测试这些内容）。

相反，C++以不同的方式解决了这样的问题：通过允许我们创建用于程序的全新的自定义类型！这样的类型通常称为用户定义类型（尽管我们认为术语“程序定义类型”更好——我们将在本课后面讨论差异）。C++有两类复合类型允许这种情况：枚举类型（包括非范围枚举和范围枚举）和类类型（包括结构、类和联合）。

***
## 定义程序定义的类型

就像类型别名一样，程序定义的类型也必须在使用之前定义。程序定义类型的定义称为类型定义。

尽管我们还没有介绍结构是什么，但下面的示例显示了自定义Fraction类型的定义和使用该类型的对象的实例化：

```C++
// Define a program-defined type named Fraction so the compiler understands what a Fraction is
// (we'll explain what a struct is and how to use them later in this chapter)
// This only defines what a Fraction type looks like, it doesn't create one
struct Fraction
{
	int numerator {};
	int denominator {};
};

// Now we can make use of our Fraction type
int main()
{
	Fraction f{ 3, 4 }; // this actually instantiates a Fraction object named f

	return 0;
}
```

在这个例子中，我们使用struct关键字来定义一个名为Fraction的新程序定义类型（在全局范围内，因此它可以在文件的其余部分的任何地方使用）。这不会分配任何内存——它只是告诉编译器Fraction是什么样子的，所以我们可以稍后分配Fraction类型的对象。然后，在main（）中，我们实例化（并初始化）一个名为f的Fraction类型的变量。

程序定义的类型定义必须以分号结尾。未能在类型定义的末尾包含分号是常见的程序员错误，并且可能很难调试，因为编译器可能会在类型定义后的行上出错。

在下一课（13.2——无范围枚举）中，我们将展示定义和使用程序定义类型的更多示例，并从第13.5课——结构、成员和成员选择简介开始介绍结构。

{{< alert success >}}
**警告**

不要忘记以分号结束类型定义。

{{< /alert >}}

***
## 命名程序定义的类型

按照惯例，程序定义的类型以大写字母开头命名，并且不使用后缀（例如，Fraction、not Fraction，Fraction_t或Fraction_t）。

由于类型名和变量名之间的相似性，新程序员有时会发现变量定义（如以下）令人困惑：

```C++
Fraction fraction {}; // Instantiates a variable named fraction of type Fraction
```

这与任何其他变量定义没有什么不同：首先是类型（Fraction）（因为Fraction是大写的，所以我们知道它是程序定义的类型），然后是变量名（Fraction），最后是可选的初始值设定项。因为C++是区分大小写的，所以这里没有命名冲突！

{{< alert success >}}
**最佳做法**

以大写字母开头命名程序定义的类型，不要使用后缀。

{{< /alert >}}

***
## 在整个多文件程序中使用程序定义的类型

使用程序定义类型的每个代码文件都需要在使用之前查看完整的类型定义。转发声明是不够的。这是必需的，以便编译器知道为该类型的对象分配多少内存。

为了将类型定义传播到需要它们的代码文件中，通常在头文件中定义程序定义的类型，然后将#包含到需要该类型定义的任何代码文件中。这些头文件通常具有与程序定义类型相同的名称（例如，名为Fraction的程序定义类型将在Fraction.h中定义）

下面是一个示例，说明如果我们将Fraction类型移动到头文件（名为Fraction.h）中，以便它可以包含在多个代码文件中，它会是什么样子：

分数.h：

```C++
#ifndef FRACTION_H
#define FRACTION_H

// Define a new type named Fraction
// This only defines what a Fraction looks like, it doesn't create one
// Note that this is a full definition, not a forward declaration
struct Fraction
{
	int numerator {};
	int denominator {};
};

#endif
```

分数.cpp：

```C++
#include "Fraction.h" // include our Fraction definition in this code file

// Now we can make use of our Fraction type
int main()
{
	Fraction f{ 3, 4 }; // this actually creates a Fraction object named f

	return 0;
}
```

{{< alert success >}}
**最佳做法**

仅在一个代码文件中使用的程序定义类型应在该代码文件中定义，并尽可能靠近第一个使用点。

在多个代码文件中使用的程序定义类型应在与程序定义类型同名的头文件中定义，然后根据需要将#包含在每个代码文件中。

{{< /alert >}}

***
## 类型定义部分免除了一个定义规则（ODR）

在第2.7课——前向声明和定义中，我们讨论了一个定义规则如何要求每个函数和全局变量每个程序只有一个定义。要在不包含定义的文件中使用给定的函数或全局变量，我们需要一个前向声明（通常通过头文件传播）。这是因为当涉及函数和非constexpr变量时，声明足以满足编译器的要求，然后链接器可以连接所有内容。

然而，以类似的方式使用前向声明不适用于类型，因为编译器通常需要查看完整的定义才能使用给定的类型。我们必须能够将完整的类型定义传播到需要它的每个代码文件。

为了实现这一点，类型被部分地排除在一个定义规则之外：允许在多个代码文件中定义给定的类型。

您已经使用了该功能（可能没有意识到）：如果您的程序有两个代码文件，它们都#include<iostream>，那么您将把所有的输入/输出类型定义导入到这两个文件中。

有两个警告值得了解。首先，每个代码文件仍然只能有一个类型定义（这通常不是问题，因为头保护将阻止这一点）。其次，给定类型的所有类型定义都必须相同，否则将导致未定义的行为。

***
## 命名：用户定义类型与程序定义类型

术语“用户定义类型”有时出现在随意的对话中，也在C++语言标准中提到（但没有定义）。在非正式对话中，该术语往往意味着“在您自己的程序中定义的类型”（例如上面的Fraction类型示例）。

C++语言标准以非常规的方式使用术语“用户定义类型”。在语言标准中，“用户定义类型”是由您、标准库或实现定义的任何类类型或枚举类型（例如，由编译器定义以支持语言扩展的类型）。也许与直觉相反，这意味着std:：string（标准库中定义的类类型）被认为是用户定义的类型！

为了提供额外的区别，C++20语言标准有用地定义了术语“程序定义类型”，以表示未定义为标准库、实现或核心语言的一部分的类类型和枚举类型。换句话说，“程序定义类型”仅包括由我们（或第三方库）定义的类类型和枚举类型。

因此，当只讨论我们定义用于自己的程序的类类型和枚举类型时，我们更喜欢术语“程序定义的”，因为它有更精确的定义。

