---
title: "std:：vector和list构造函数简介"
date: 2024-07-08T11:10:28+08:00
---

在上一课16.1——容器和数组简介中，我们介绍了容器和数组。在本课中，我们将介绍在本章剩余部分中重点关注的数组类型：std:：vector。我们还将解决上一课介绍的可扩展性挑战的一部分。

***
## std:：vector简介

vector是C++标准容器库中实现数组的容器类之一。std:：vector在<vector>头中定义为类模板，具有定义元素类型的模板类型参数。因此，std:：vector<int>声明了一个std:∶vector，其元素的类型为int。

实例化std:：vector对象很简单：

```C++
#include <vector>

int main()
{
	// Value initialization (uses default constructor)
	std::vector<int> empty{}; // vector containing 0 int elements

	return 0;
}
```

变量empty被定义为一个std:：vector，其元素的类型为int。因为我们在这里使用了值初始化，所以我们的向量将以空开始（即，没有元素）。

没有元素的向量现在可能不太有用，但我们将在以后的课程中再次遇到这种情况（特别是16.11---std:：vector和堆栈行为）。

***
## 使用值列表初始化std:：vector

由于容器的目标是管理一组相关的值，因此我们通常希望用这些值初始化容器。我们可以通过使用具有所需的特定初始化值的列表初始化来实现这一点。例如：

```C++
#include <vector>

int main()
{
	// List construction (uses list constructor)
	std::vector<int> primes{ 2, 3, 5, 7 };          // vector containing 4 int elements with values 2, 3, 5, and 7
	std::vector vowels { 'a', 'e', 'i', 'o', 'u' }; // vector containing 5 char elements with values 'a', 'e', 'i', 'o', and 'u'.  Uses CTAD (C++17) to deduce element type char (preferred).

	return 0;
}
```

对于素数，我们显式地指定需要一个std:：vector，其元素具有int类型。因为我们提供了4个初始化值，所以素数将包含4个元素，其值为2、3、5和7。

对于元音，我们没有显式地指定元素类型。相反，我们使用C++17的CTAD（类模板参数推导）让编译器从初始值设定项推断元素类型。因为我们提供了5个初始化值，元音将包含5个元素，其值为“a”、“e”、“i”、“o”和“u”。

***
## 列出构造函数和初始值设定项列表

让我们更详细地讨论一下上面的工作原理。

在第13.8课——结构聚合初始化中，我们将初始值设定项列表定义为逗号分隔值的大括号列表（例如{1，2，3}）。

容器通常具有一个名为列表构造函数的特殊构造函数，该构造函数允许我们使用初始值设定项列表构造容器的实例。列表构造函数做三件事：

1. 确保容器具有足够的存储空间来保存所有初始化值（如果需要）。
2. 将容器的长度设置为初始值设定项列表中的元素数（如果需要）。
3. 将元素初始化为初始值设定项列表中的值（按顺序）。


因此，当我们为容器提供值的初始值设定项列表时，将调用列表构造函数，并使用该值列表构造容器！

{{< alert success >}}
**最佳做法**

使用具有值的初始值设定项列表的列表初始化来构造具有这些元素值的容器。

{{< /alert >}}

{{< alert success >}}
**相关内容**

在第23.7课中，我们讨论了将列表构造函数添加到自己的程序定义类中——std:：initializer_list。

{{< /alert >}}

***
## 使用下标运算符（运算符[]）访问数组元素

现在我们已经创建了一个元素数组……我们如何访问它们？

让我们用一个类比。考虑一组相同的邮箱，并排放置。为了更容易识别邮箱，每个邮箱的前面都漆有一个数字。第一个邮箱有0号，第二个邮箱有1号，等等……所以如果你被告知在0号邮箱中放东西，你就会知道这意味着第一个邮箱。

在C++中，访问数组元素的最常见方法是使用数组的名称和下标运算符（运算符[]）。为了选择特定的元素，在下标运算符的方括号内，我们提供了一个整数值，用于标识要选择的元素。该整数值称为下标（非正式地称为索引）。与我们的邮箱非常相似，第一个元素是使用索引0访问的，第二个是使用索引1访问的，等等…

例如，质数[0]将从质数数组返回索引为0的元素（第一个元素）。下标运算符返回对实际元素的引用，而不是副本。一旦访问了数组元素，我们就可以像普通对象一样使用它（例如，为其赋值、输出它等等…）

因为索引从0开始，而不是1，所以我们说C++中的数组是从零开始的。这可能会令人困惑，因为我们习惯于从1开始计算对象。这也可能导致一些歧义，因为当我们谈论数组元素1时，可能不清楚我们谈论的是第一个数组元素（索引为0）还是第二个数组元素。

下面是一个示例：

```C++
#include <iostream>
#include <vector>

int main()
{
    std::vector primes { 2, 3, 5, 7, 11 }; // hold the first 5 prime numbers (as int)

    std::cout << "The first prime number is: " << primes[0] << '\n';
    std::cout << "The second prime number is: " << primes[1] << '\n';
    std::cout << "The sum of the first 5 primes is: " << primes[0] + primes[1] + primes[2] + primes[3] + primes[4] << '\n';

    return 0;
}
```

这将打印：

通过使用数组，我们不再需要定义5个不同命名的变量来保存5个质数值。相反，我们可以定义一个具有5个元素的数组（质数），只需更改索引的值以访问不同的元素！

在下一课16.3中，我们将更多地讨论操作符[]和访问数组元素的一些其他方法——std:：vector和无符号长度和下标问题。

***
## 下标越界

索引数组时，提供的索引必须选择数组的有效元素。也就是说，对于长度为N的数组，下标必须是介于0和N-1（包含）之间的值。

运算符[]不执行任何类型的边界检查，这意味着它不检查索引是否在0到N-1（包括0和N-1）的边界内。将无效索引传递给运算符[]将以未定义的行为返回。

记住不要使用负下标是相当容易的。不太容易记住，没有索引为N的元素！数组的最后一个元素具有索引N-1，因此使用索引N将导致编译器尝试访问数组末尾后一个的元素。

{{< alert success >}}
**提示**

在具有N个元素的数组中，第一个元素具有索引0，第二个元素具有指数1，最后一个元素具有指标N-1。没有索引为N的元素！

使用N作为下标将导致未定义的行为（因为这实际上是试图访问N+1个元素，它不是数组的一部分）。

{{< /alert >}}

{{< alert success >}}
**提示**

某些编译器（如Visual Studio）提供了索引有效的运行时断言。在这种情况下，如果在调试模式下提供了无效索引，则程序将断言。在发布模式下，将编译断言，因此没有性能惩罚。

{{< /alert >}}

***
## 数组在内存中是连续的

数组的定义特征之一是元素总是在内存中连续分配，这意味着元素在内存中都是相邻的（它们之间没有间隙）。

作为一个例子：

```C++
#include <iostream>
#include <vector>

int main()
{
    std::vector primes { 2, 3, 5, 7, 11 }; // hold the first 5 prime numbers (as int)

    std::cout << "An int is " << sizeof(int) << " bytes\n";
    std::cout << &(primes[0]) << '\n';
    std::cout << &(primes[1]) << '\n';
    std::cout << &(primes[2]) << '\n';

    return 0;
}
```

在作者的机器上，上述程序的一次运行产生了以下结果：

您将注意到，这些int元素的内存地址间隔为4个字节，与作者机器上的int大小相同。

这意味着数组没有任何每元素开销。它还允许编译器快速计算数组中任何元素的地址。

数组是少数允许随机访问的容器类型之一，这意味着容器中的任何元素都可以直接访问（与顺序访问相反，顺序访问中的元素必须按特定顺序访问）。对数组元素的随机访问通常是有效的，并且使数组非常易于使用。这是数组通常比其他容器更受欢迎的主要原因。

{{< alert success >}}
**相关内容**

我们将在第17.9课中讨论下标背后的数学——指针算术和下标。

{{< /alert >}}

***
## 构造特定长度的std:：向量

考虑这样一种情况，我们希望用户输入10个值，这些值将存储在std:：vector中。在这种情况下，在将任何值放入std:：vector之前，需要一个长度为10的std:∶vector。我们如何解决这个问题？

我们可以创建一个std:：vector，并使用具有10个占位符值的初始值设定项列表对其进行初始化：

```C++
	std::vector<int> data { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // vector containing 10 int values
```

但由于许多原因，这是不好的。它需要大量的打字。要知道有多少个初始值设定项并不容易。如果我们决定以后需要不同数量的值，则更新并不容易。

幸运的是，std:：vector有一个显式构造函数（显式std:：vector<T>（int）），该构造函数采用单个int值来定义要构造的std::vector的长度：

```C++
	std::vector<int> data( 10 ); // vector containing 10 int elements, value-initialized to 0
```

每个创建的元素都是值初始化的，对于int，它执行零初始化（对于类类型，调用默认构造函数）。

然而，使用这个构造函数有一件不明显的事情：必须使用直接初始化来调用它。

***
## 列表构造函数优先于其他构造函数

要理解为什么必须使用直接初始化调用上一个构造函数，请考虑以下定义：

```C++
	std::vector<int> data{ 10 }; // what does this do?
```

有两个不同的构造函数与此初始化匹配：

1. {10}可以解释为初始值设定项列表，并与列表构造函数匹配以构造长度为1、值为10的向量。
2. {10}可以解释为单个支撑初始化值，并与std:：vector<T>（int）构造函数匹配，以构造长度为10的向量，其中元素值初始化为0。


通常，当类类型定义与多个构造函数匹配时，匹配被认为是不明确的，并导致编译错误。然而，C++对于这种情况有一个特殊的规则：匹配的列表构造函数将被选择，而不是其他匹配的构造函数。如果没有此规则，列表构造函数将导致与采用单个类型参数的任何构造函数的不明确匹配。

由于{10}可以解释为初始值设定项列表，并且std:：vector具有列表构造函数，因此在这种情况下，列表构造函数优先。

为了帮助进一步阐明在各种初始化情况下会发生什么，让我们看一下使用复制、直接和列表初始化的类似情况：

```C++
	// Copy init
	std::vector<int> v1 = 10;     // 10 not an initializer list, copy init won't match explicit constructor: compilation error

	// Direct init
	std::vector<int> v2(10);      // 10 not an initializer list, matches explicit single-argument constructor

	// List init
	std::vector<int> v3{ 10 };    // { 10 } interpreted as initializer list, matches list constructor

	// Copy list init
	std::vector<int> v4 = { 10 }; // { 10 } interpreted as initializer list, matches list constructor
	std::vector<int> v5({ 10 });  // { 10 } interpreted as initializer list, matches list constructor
```

在v1的情况下，10的初始化值不是初始值设定项列表，因此列表构造函数不匹配。单参数构造函数显式std:：vector<T>（int）也不匹配，因为复制初始化将不匹配显式构造函数。由于没有匹配的构造函数，这是一个编译错误。

在v2的情况下，10的初始化值不是初始值设定项列表，因此列表构造函数不匹配。单参数构造函数显式std:：vector<T>（int）匹配，因此选择单参数构造函数。

在v3（列表初始化）的情况下，{10}可以与列表构造函数或显式std:：vector<T>（int）匹配。列表构造函数优先于其他匹配构造函数，并被选中。

在v4（复制列表初始化）的情况下，{10}可以与列表构造函数匹配（这是一个非显式构造函数，因此可以与复制初始化一起使用）。已选择列表构造函数。

令人惊讶的是，情况v5是复制列表初始化（不是直接初始化）的替代语法，并且与v4相同。

这是C++初始化的缺点之一：{10}将匹配列表构造函数（如果存在），或者匹配单参数构造函数（如果列表构造函数不存在）。这意味着您获得的行为取决于列表构造函数是否存在！通常可以假设容器具有列表构造函数。

总之，列表初始值设定项通常被设计为允许我们使用元素值列表来初始化容器，并且应该用于该目的。无论如何，这是我们大多数时候想要的。因此，如果10是元素值，则{10}是适当的。如果10是容器的非列表构造函数的参数，请使用直接初始化。

{{< alert success >}}
**关键洞察力**

在构造类类型对象时，匹配列表构造函数被选中，而不是其他匹配构造函数。

{{< /alert >}}

{{< alert success >}}
**最佳做法**

使用不是元素值的初始值设定项构造容器（或具有列表构造函数的任何类型）时，请使用直接初始化。

{{< /alert >}}

{{< alert success >}}
**提示**

当std:：vector是类类型的成员时，不太清楚如何提供默认的初始值设定项，该初始值设定器将std:∶vector的长度设置为某个初始值：

```C++
#include <vector>

struct Foo
{
    std::vector<int> v1(8); // compile error: direct initialization not allowed for member default initializers
};
```

为类类型的成员提供默认初始值设定项时：

1. 我们必须使用复制初始化或列表初始化。
2. 不允许CTAD（因此我们必须显式指定元素类型）。


答案如下：

```C++
struct Foo
{
    std::vector<int> v{ std::vector<int>(8) }; // ok 
};
```

这将创建一个容量为8的std:：vector，然后将其用作v的初始值设定项。

{{< /alert >}}

***
## Const和constexpr标准：：矢量

可以将std:：vector类型的对象设置为const:

```C++
#include <vector>

int main()
{
    const std::vector<int> prime { 2, 3, 5, 7, 11 }; // prime and its elements cannot be modified

    return 0;
}
```

必须初始化const std:：vector，然后不能修改。这样一个向量的元素被视为常量。

非常量std:：vector的元素必须是非常量。因此，不允许出现以下情况：

```C++
#include <vector>

int main()
{
    std::vector<const int> prime { 2, 3, 5, 7, 11 };
}
```

std:：vector的最大缺点之一是它不能成为constexpr。如果需要constexpr数组，请使用std:：array。

{{< alert success >}}
**相关内容**

我们在第17.1课——std:：array简介中介绍了std:∶array。

{{< /alert >}}

***
## 为什么它被称为向量？

当人们在谈话中使用术语“向量”时，他们通常指的是几何向量，即具有大小和方向的对象。那么，当std:：vector不是几何向量时，它是如何获得名称的呢？

亚历山大·斯蒂芬诺夫（Alexander Stepanov）在《从数学到泛型编程》（From Mathematics to Generic Programming）一书中写道，“STL中的名称向量取自早期的编程语言Scheme和Common Lisp。不幸的是，这与数学中这个词的更古老的含义不一致……这种数据结构应该被称为数组。遗憾的是，如果你犯了错误并违反了这些原则，结果可能会保留很长时间。”

因此，基本上，std:：vector的名称是错误的，但现在更改它太晚了。

***
## 测验时间

问题#1

使用CTAD定义std:：向量，并用前5个正方形数（1、4、9、16和25）对其进行初始化。

显示解决方案

问题#2

这两个定义之间的行为差异是什么？

```C++
std::vector<int> v1 { 5 };
std::vector<int> v2 ( 5 );
```

显示解决方案

问题#3

定义一个std:：vector（使用显式模板类型参数）来保持一年中每天的高温（精确到十分之一度）（假设一年中有365天）。

显示解决方案

问题#4

使用std:：vector编写一个程序，要求用户输入3个整数值。打印这些值的总和和乘积。

输出应匹配以下内容：

显示解决方案

