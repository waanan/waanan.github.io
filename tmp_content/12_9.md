---
title: "第11章总结和测验"
date: 2024-02-10T01:33:43+08:00
---

不错的工作。函数模板可能看起来相当复杂，但它们是一种非常强大的方法，可以使代码与不同类型的对象一起工作。在以后的章节中，我们将看到更多的模板内容，所以请抓紧你的帽子。

***
## 章节回顾

函数重载允许我们创建具有相同名称的多个函数，只要每个同名函数具有不同的参数类型集（或者可以以其他方式区分函数）。这样的函数称为重载函数（简称重载）。返回类型不考虑区分。

在解析重载函数时，如果找不到精确匹配，编译器将更喜欢可以通过数字提升匹配的重载函数，而不是那些需要数字转换的重载函数。当对已重载的函数进行函数调用时，编译器将基于函数调用中使用的参数，尝试将函数调用与适当的重载相匹配。这称为重载解析。

当编译器发现两个或多个函数可以与重载函数的函数调用相匹配，但无法确定哪一个是最佳的时，就会发生不明确的匹配。

默认参数是为函数参数提供的默认值。具有默认参数的参数必须始终是最右边的参数，并且在解析重载函数时，它们不用于区分函数。

函数模板允许我们创建类似函数的定义，该定义用作创建相关函数的模式。在函数模板中，我们使用类型模板参数作为以后要指定的任何类型的占位符。告诉编译器我们正在定义模板并声明模板类型的语法称为模板参数声明。

从函数模板（具有模板类型）创建函数（具有特定类型）的过程简称为函数模板实例化（或实例化）。当这个过程由于函数调用而发生时，它被称为隐式实例化。实例化的函数称为函数实例（或简称为实例，有时称为模板函数）。

模板参数推导允许编译器从函数调用的参数中推导出应用于实例化函数的实际类型。模板参数推导不进行类型转换。

模板类型有时称为泛型类型，使用模板进行编程有时称为通用编程。

在C++20中，当auto关键字用作普通函数中的参数类型时，编译器将自动将函数转换为函数模板，每个auto参数都成为独立的模板类型参数。用于创建函数模板的方法称为缩写函数模板。

非类型模板参数是具有固定类型的模板参数，它用作作为模板参数传入的constexpr值的占位符。

***
## 测验时间

***
## 测验1

1a）该程序的输出是什么，为什么？

```C++
#include <iostream>

void print(int x)
{
    std::cout << "int " << x << '\n';
}

void print(double x)
{
    std::cout << "double " << x << '\n';
}

int main()
{
    short s { 5 };
    print(s);

    return 0;
}
```

显示解决方案

1b）为什么下面的代码不能编译？

```C++
#include <iostream>

void print()
{
    std::cout << "void\n";
}

void print(int x=0)
{
    std::cout << "int " << x << '\n';
}

void print(double x)
{
    std::cout << "double " << x << '\n';
}

int main()
{
    print(5.0f);
    print();

    return 0;
}
```

显示解决方案

1c）为什么下面的代码不能编译？

```C++
#include <iostream>

void print(long x)
{
    std::cout << "long " << x << '\n';
}

void print(double x)
{
    std::cout << "double " << x << '\n';
}

int main()
{
    print(5);

    return 0;
}
```

显示解决方案

问题#2

>步骤#1

编写一个名为add（）的函数模板，允许用户添加2个相同类型的值。应运行以下程序：

```C++
#include <iostream>

// write your add function template here

int main()
{
	std::cout << add(2, 3) << '\n';
	std::cout << add(1.2, 3.4) << '\n';

	return 0;
}
```

并产生以下输出：

显示解决方案



>步骤#2



```C++
#include <iostream>

// write your mult function template here

int main()
{
	std::cout << mult(2, 3) << '\n';
	std::cout << mult(1.2, 3) << '\n';

	return 0;
}
```

并产生以下输出：

显示解决方案

>步骤#3

编写一个名为sub（）的函数模板，允许用户减去两个不同类型的值。应运行以下程序：

```C++
#include <iostream>

// write your sub function template here

int main()
{
	std::cout << sub(3, 2) << '\n';
	std::cout << sub(3.5, 2) << '\n';
	std::cout << sub(4, 1.5) << '\n';

	return 0;
}
```

并产生以下输出：

显示解决方案

问题#3

这个程序的输出是什么？为什么？

```C++
#include <iostream>

template <typename T>
int count(T) // This is the same as int count(T x), except we're not giving the parameter a name since we don't use the parameter
{
    static int c { 0 };
    return ++c;
}

int main()
{
    std::cout << count(1) << '\n';
    std::cout << count(1) << '\n';
    std::cout << count(2.3) << '\n';
    std::cout << count<double>(1) << '\n';
    
    return 0;
}
```

显示解决方案

问题#4

这个程序的输出是什么？

```C++
#include <iostream>

int foo(int n)
{
    return n + 10;
}

template <typename T>
int foo(T n)
{
    return n;
}

int main()
{
    std::cout << foo(1) << '\n'; // #1

    short s { 2 };
    std::cout << foo(s) << '\n'; // #2
    
    std::cout << foo<int>(4) << '\n'; // #3

    std::cout << foo<int>(s) << '\n'; // #4

    std::cout << foo<>(6) << '\n'; // #5
    
    return 0;
}
```

显示解决方案

