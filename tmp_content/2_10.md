---
title: "标题文件"
date: 2023-10-09T20:06:10+08:00
---

***
## 标题及其用途

随着程序变得越来越大（并使用更多的文件），必须向前声明在不同文件中定义的每个要使用的函数变得越来越乏味。如果您可以将所有的前向声明放在一个位置，然后在需要时导入它们，这不是很好吗？

C++代码文件（扩展名为.cpp）并不是C++程序中常见的唯一文件。另一种类型的文件称为头文件。头文件通常具有.h扩展名，但您偶尔会看到它们具有.hpp扩展名或根本没有扩展名。头文件的主要目的是将声明传播到代码（.cpp）文件。

{{< alert success >}}
**关键洞察力**

头文件允许我们将声明放在一个位置，然后在需要的地方导入它们。这可以节省多文件程序中的大量输入。

{{< /alert >}}

***
## 使用标准库头文件

考虑以下程序：

```C++
#include <iostream>

int main()
{
    std::cout << "Hello, world!";
    return 0;
}
```

该程序使用std:：cout将“Hello，world！”打印到控制台。然而，该程序从未提供std:：cout的定义或声明，那么编译器如何知道什么是std:∶cout？

答案是std:：cout已在“iostream”头文件中向前声明。当我们#include<iostream>时，我们请求预处理器将所有内容（包括std:：cout的前向声明）从名为“iostream”的文件复制到执行#incluse的文件中。

考虑如果iostream标头不存在会发生什么。无论在哪里使用std:：cout，都必须手动将与std:∶cout相关的所有声明键入或复制到使用std::cout！这将需要大量关于如何声明std:：cout的知识，并且将是一项繁重的工作。更糟糕的是，如果添加或更改了函数原型，我们就必须手动更新所有的前向声明。

只#include<iostream>要容易得多！

{{< alert success >}}
**关键洞察力**

当您#包含文件时，所包含文件的内容将插入到包含点。这提供了一种从另一个文件中拉入声明的有用方法。

{{< /alert >}}

***
## 使用头文件传播前向声明

现在，让我们回到上一课中讨论的示例。当我们停止时，有两个文件，add.cpp和main.cpp，如下所示：

添加.cpp：

```C++
int add(int x, int y)
{
    return x + y;
}
```

主.cpp：

```C++
#include <iostream>

int add(int x, int y); // forward declaration using function prototype

int main()
{
    std::cout << "The sum of 3 and 4 is " << add(3, 4) << '\n';
    return 0;
}
```

（如果从头开始重新创建此示例，请不要忘记将add.cpp添加到项目中，以便在中进行编译）。

在本例中，我们使用了前向声明，以便编译器在编译main.cpp时知道添加的标识符是什么。如前所述，为您想要使用的位于另一个文件中的每个函数手动添加前向声明可能会很快变得乏味。

让我们编写一个头文件来减轻我们的负担。编写头文件非常容易，因为头文件仅由两部分组成：

将头文件添加到项目中的工作方式类似于添加源文件（在第2.8课-具有多个代码文件的程序中介绍）。

如果使用IDE，请执行相同的步骤，并在询问时选择“标题”而不是“源”。头文件应作为项目的一部分出现。

如果使用命令行，只需在您喜爱的编辑器中创建一个新文件，该文件与源（.cpp）文件位于同一目录中。与源文件不同，头文件不应添加到编译命令中（它们被#include语句隐式包含并编译为源文件的一部分）。

头文件通常与代码文件配对，头文件为相应的代码文件提供前向声明。由于头文件将包含add.cpp中定义的函数的前向声明，因此我们将调用新的头文件add.h。

这是我们完成的头文件：

添加.h：

```C++
// 1) We really should have a header guard here, but will omit it for simplicity (we'll cover header guards in the next lesson)

// 2) This is the content of the .h file, which is where the declarations go
int add(int x, int y); // function prototype for add.h -- don't forget the semicolon!
```

为了在main.cpp中使用此头文件，我们必须#包含它（使用引号，而不是尖括号）。

主.cpp：

```C++
#include "add.h" // Insert contents of add.h at this point.  Note use of double quotes here.
#include <iostream>

int main()
{
    std::cout << "The sum of 3 and 4 is " << add(3, 4) << '\n';
    return 0;
}
```

添加.cpp：

```C++
#include "add.h" // Insert contents of add.h at this point.  Note use of double quotes here.

int add(int x, int y)
{
    return x + y;
}
```

当预处理器处理#include“add.h”行时，它会在该点将add.h的内容复制到当前文件中。因为我们的add.h包含函数add（）的前向声明，所以该前向声明将被复制到main.cpp.最终结果是一个程序，其功能与我们在main.cpp顶部手动添加前向声明的程序相同。

因此，我们的程序将正确编译和链接。



注意：在上图中，“标准运行库”应标记为“C++标准库”。

{{< alert success >}}
**最佳做法**

命名头文件时首选.h后缀（除非您的项目已经遵循其他约定）。

这是C++头文件的一个长期约定，大多数IDE仍然默认为.h而不是其他选项。

{{< /alert >}}

{{< alert success >}}
**最佳做法**

如果头文件与代码文件成对出现（例如，add.h与add.cpp），则它们都应该具有相同的基名称（add）。

{{< /alert >}}

***
## 在头文件中包含定义如何导致违反一个定义规则

现在，应该避免将函数或变量定义放在头文件中。在头文件包含在多个源文件中的情况下，这样做通常会导致违反一个定义规则（ODR）。

让我们来说明这是如何发生的：

添加.h：

```C++
// We really should have a header guard here, but will omit it for simplicity (we'll cover header guards in the next lesson)

// definition for add() in header file -- don't do this!
int add(int x, int y)
{
    return x + y;
}
```

主.cpp：

```C++
#include "add.h" // Contents of add.h copied here
#include <iostream>

int main()
{
    std::cout << "The sum of 3 and 4 is " << add(3, 4) << '\n';

    return 0;
}
```

添加.cpp：

```C++
#include "add.h" // Contents of add.h copied here
```

编译main.cpp时，#include“add.h”将替换为add.h的内容，然后进行编译。因此，编译器将编译如下所示的内容：

main.cpp（预处理后）：

```C++
int add(int x, int y)
{
    return x + y;
}
include <iostream>

int main()
{
    std::cout << "The sum of 3 and 4 is " << add(3, 4) << '\n';

    return 0;
}
```

这将编译得很好。

编译器编译add.cpp时，#include“add.h”将替换为add.h的内容，然后进行编译。因此，编译器将编译如下：

add.cpp（预处理后）：

```C++
int add(int x, int y)
{
    return x + y;
}
```

这也可以很好地编译。

最后，链接器将运行。链接器将看到函数add（）现在有两个定义：一个在main.cpp中，另一个在add.cpp.这违反了ODR第2部分的规定，该部分指出，“在给定的程序中，变量或普通函数只能有一个定义。”

{{< alert success >}}
**相关内容**

我们在第2.7课中讨论了单定义规则（ODR）——转发声明和定义。

{{< /alert >}}

{{< alert success >}}
**最佳做法**

不要将函数和变量定义放在头文件中（目前）。

如果随后将头#包含在多个源（.cpp）文件中，则在头文件中定义其中之一可能会导致违反一个定义规则（ODR）。

{{< /alert >}}

{{< alert success >}}
**作者注释**

在以后的课程中，我们将遇到可以在头文件中安全定义的其他类型的定义（因为它们不受ODR的限制）。这包括内联函数、内联变量、类型和模板的定义。我们将在介绍其中的每一个时进一步讨论这一点。

{{< /alert >}}

***
## 源文件应包括它们的成对标头

在C++中，代码文件的最佳实践是#包含其成对的头文件（如果存在）。在上面的示例中，add.cpp包括add.h。

这允许编译器在编译时而不是链接时捕获某些类型的错误。例如：

某物.h：

```C++
int something(int); // return type of forward declaration is int
```

某物.cpp：

```C++
#include "something.h"

void something(int) // error: wrong return type
{
}
```

由于something.cpp#包含somethine.h，编译器将注意到函数something（）的返回类型不匹配，并给出编译错误。如果something.cpp没有#include somethine.h，我们必须等待链接器发现差异，这会浪费时间。有关另一个示例，请参阅此注释。

在未来的课程中，我们还将看到许多示例，其中源文件所需的内容在成对的标题中定义。在这种情况下，包括页眉是必要的。

{{< alert success >}}
**最佳做法**

源文件应#包括其成对的头文件（如果存在）。

{{< /alert >}}

***
## 不#include.cpp文件

尽管预处理器很乐意这样做，但通常不应该#include.cpp文件。这些应该添加到项目中并进行编译。

这有许多原因：

1. 这样做可能会导致源文件之间的命名冲突。
2. 在大型项目中，很难避免一个定义规则（ODR）问题。
3. 对这样的.cpp文件的任何更改都将导致.cpp文件和包含它的任何其他.cpp file重新编译，这可能需要很长时间。与源文件相比，标头的更改频率较低。
4. 这样做是非常规的。


{{< alert success >}}
**最佳做法**

避免#包括.cpp文件。

{{< /alert >}}

***
## 故障排除

如果出现编译器错误，指示找不到add.h，请确保该文件实际命名为add.h。根据您创建和命名该文件的方式，该文件可能被命名为add（无扩展名）或add.h.txt或add.hpp.此外，请确保它与其余代码文件位于同一目录中。

如果收到关于未定义函数add的链接器错误，请确保已在项目中包含add.cpp，以便可以将函数add定义链接到程序中。

***
## 尖括号与双引号

您可能很好奇为什么我们对iostream使用尖括号，对add.h使用双引号。有可能在多个目录中存在具有相同文件名的头文件。我们对尖括号和双引号的使用有助于给预处理器一个线索，告诉它应该在哪里查找头文件。

当我们使用尖括号时，我们告诉预处理器，这是一个不是我们自己编写的头文件。预处理器将仅在包含目录指定的目录中搜索标头。include目录配置为项目/IDE设置/编译器设置的一部分，通常默认为包含编译器和/或操作系统附带的头文件的目录。预处理器不会在项目的源代码目录中搜索头文件。

当我们使用双引号时，我们告诉预处理器这是我们编写的头文件。预处理器将首先在当前目录中搜索头文件。如果它在那里找不到匹配的标头，那么它将搜索包含目录。

{{< alert success >}}
**规则**

使用双引号包括您编写的或预期在当前目录中找到的头文件。使用尖括号来包含编译器、操作系统或系统上其他地方安装的第三方库附带的标头。

{{< /alert >}}

***
## 为什么iostream没有.h扩展名？

另一个常见的问题是“为什么iostream（或任何其他标准库头文件）没有.h扩展名？”。答案是iostream.h与iostream是不同的头文件！解释需要上一堂简短的历史课。

首次创建C++时，标准库中的所有文件都以.h后缀结尾。生活是始终如一的，是美好的。cout和cin的原始版本在iostream.h中声明。当ANSI委员会标准化该语言时，他们决定将标准库中使用的所有名称移到std命名空间中，以帮助避免与用户声明的标识符发生命名冲突。然而，这提出了一个问题：如果他们将所有名称移到std命名空间中，则旧程序（包括iostream.h）都将无法再工作！

为了解决这个问题，引入了一组新的头文件，它们没有.h扩展名。这些新的头文件声明std命名空间中的所有名称。这样，包含#include<iostream.h>的较旧程序不需要重写，而较新的程序可以#incluse<iostream>。

此外，从C继承的许多在C++中仍然有用的库都被赋予了C前缀（例如，stdlib.h变为cstdlib）。

{{< alert success >}}
**关键洞察力**

扩展名为.h的头文件在全局命名空间中声明了它们的名称，也可以选择在std命名空间中声明它们。

不带.h扩展名的头文件将在std命名空间中声明其名称。不幸而愚蠢的是，这些头文件也可以选择在全局命名空间中声明这些名称。

{{< /alert >}}

{{< alert success >}}
**最佳做法**

包含标准库中的头文件时，如果存在不带.h扩展名的版本，请使用该版本。用户定义的标头仍应使用.h扩展名。

如果没有.h扩展名的头文件将名称声明到全局命名空间中，请避免使用这些名称，因为它们可能在其他编译器的全局命名空间中不可用。首选在std命名空间中声明的名称。

{{< /alert >}}

***
## 包括来自其他目录的头文件

另一个常见的问题涉及如何包括来自其他目录的头文件。

这样做的一种（错误的）方法是包含要包含为#include行一部分的头文件的相对路径。例如：

```C++
#include "headers/myHeader.h"
#include "../moreHeaders/myOtherHeader.h"
```

虽然这将进行编译（假设文件存在于这些相对目录中），但这种方法的缺点是它需要您在代码中反映目录结构。如果您更新了目录结构，则代码将不再工作。

一个更好的方法是告诉编译器或IDE，您在其他位置有一组头文件，这样当它在当前目录中找不到它们时，它就会在那里查找。这通常可以通过在IDE项目设置中设置包含路径或搜索目录来完成。

这种方法的好处是，如果您更改了目录结构，则只需更改单个编译器或IDE设置，而不是每个代码文件。

{{< alert success >}}
**对于Visual Studio用户**

在解决方案资源管理器中右键单击项目，然后选择属性，然后选择VC++目录选项卡。从这里，您将看到一行，名为包含目录。添加希望编译器在其中搜索其他标头的目录。

{{< /alert >}}

{{< alert success >}}
**对于代码：：阻止用户**

在“代码：：块”中，转到“项目”菜单并选择“生成选项”，然后选择“搜索目录”选项卡。添加希望编译器在其中搜索其他标头的目录。

{{< /alert >}}

{{< alert success >}}
**对于GCC/G++用户**

使用g++，可以使用-I选项指定备用包含目录：g++-o main-I/source/includes main.cpp

-I后面没有空格。

{{< /alert >}}

{{< alert success >}}
**对于VS代码用户**

在tasks.json配置文件中，在“Args”部分添加新行：“-I/source/includes”，

{{< /alert >}}

***
## 标题可以包括其他标题

头文件通常需要存在于不同头文件中的声明或定义。因此，头文件通常#包含其他头文件。

当您的代码文件#包含第一个头文件时，您还将获得第一个头文件包含的任何其他头文件（以及其中包含的任何头文件，等等）。这些额外的头文件有时称为传递包含，因为它们是隐式包含的，而不是显式包含的。

这些可传递包含的内容可在代码文件中使用。然而，通常不应依赖传递包含的标头的内容（除非参考文档指示需要这些传递包含）。头文件的实现可能会随着时间的推移而变化，或者在不同的系统中有所不同。如果发生这种情况，您的代码可能只能在某些系统上编译，或者可以现在编译，但不能在将来编译。通过显式包含代码文件内容所需的所有头文件，可以很容易地避免这种情况。

不幸的是，当您的代码文件意外地依赖于另一个头文件所包含的头文件的内容时，并没有简单的方法来检测。

{{< alert success >}}
**最佳做法**

每个文件都应该显式地#包含它需要编译的所有头文件。不要依赖于从其他标头传递包含的标头。

{{< /alert >}}

{{< alert success >}}
**Q： 我没有包含<someheader>，但我的程序仍然有效！为什么？**

这是本网站上最常见的问题之一。答案是：它可能会工作，因为您包括了其他一些头（例如<iostream>），它本身包括<someheader>。尽管您的程序将编译，但根据上面的最佳实践，您不应该依赖于此。为您编译的内容可能无法在朋友的机器上编译。

{{< /alert >}}

***
## 头文件的#include顺序

如果头文件编写正确，并且#include了它们需要的所有内容，那么包含的顺序应该无关紧要。

现在考虑以下场景：假设标头A需要来自标头B的声明，但忘记包含它。在我们的代码文件中，如果在标头A之前包含标头B，我们的代码仍然会编译！这是因为编译器将在编译A中依赖于这些声明的代码之前编译B中的所有声明。

然而，如果我们首先包括头A，那么编译器将抱怨，因为来自A的代码将在编译器看到来自B的声明之前编译。这实际上是更好的，因为错误已经出现，然后我们可以修复它。

这样，如果您的用户定义标头之一缺少第三方库或标准库标头的#include，则更有可能导致编译错误，因此您可以修复它。

{{< alert success >}}
**最佳做法**

要最大限度地提高编译器标记缺少的Include的机会，请按以下顺序排列#includes：

每个分组的标题应按字母顺序排序（除非第三方库的文档指示您否则）。

{{< /alert >}}

***
## 头文件最佳做法

下面是关于创建和使用头文件的更多建议。

1. 始终包括顶盖护罩（我们将在下一课中介绍这些）。
2. 不要在头文件中定义变量和函数（目前）。
3. 为头文件提供与其关联的源文件相同的名称（例如，grades.h与grades.cpp成对出现）。
4. 每个头文件都应该有一个特定的作业，并且尽可能独立。例如，您可以将与功能A相关的所有声明放在A.h中，将与功能B相关的所有宣言放在B.h中。这样，如果您稍后只关心A，则可以只包含A.h，而不获取与B相关的任何内容。
5. 请注意需要为代码文件中使用的功能显式包含哪些标头。
6. 您编写的每个标头都应该自己编译（它应该#包括它需要的每个依赖项）。
7. 仅#包含您需要的内容（不要仅因为可以而包含所有内容）。
8. 不要#include.cpp文件。
9. 更喜欢在页眉中放置关于某事的作用或如何使用它的文档。它更可能在那里被看到。描述某些内容如何工作的文档应保留在源文件中。


