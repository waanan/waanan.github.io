---
title: "第13章总结和测验"
date: 2024-03-08T13:20:57+08:00
---

恭喜你！你通过了另一个。当我们谈到C++最重要的主题——类时，您获得的关于结构的知识将非常有用！

***
## 快速审阅

程序定义类型（也称为用户定义类型）是一种自定义类型，我们可以创建它以在自己的程序中使用。枚举类型和类类型（包括结构、类和联合）允许创建程序定义的类型。必须先定义程序定义的类型，然后才能使用它们。程序定义类型的定义称为类型定义。类型定义不受一个定义规则的约束。

枚举（也称为枚举类型或枚举）是一种复合数据类型，其中每个可能的值都定义为符号常量（称为枚举器）。枚举是不同的类型，这意味着编译器可以将它们与其他类型区分开来（与类型别名不同）。

无范围枚举之所以如此命名，是因为它们将其枚举器名称放入与枚举定义本身相同的范围中（而不是像命名空间那样创建新的范围区域）。无范围枚举还为其枚举器提供命名范围区域。无范围枚举将隐式转换为整数值。

作用域枚举的工作方式类似于非作用域枚举，但不会隐式转换为整数，并且枚举器仅放在枚举的作用域区域中（而不是放在定义枚举的作用区区域中）。

struct（structure的缩写）是一种程序定义的数据类型，它允许我们将多个变量绑定到一个类型中。作为结构（或类）一部分的变量称为数据成员（或成员变量）。为了访问特定的成员变量，我们在结构变量名称和成员名称（对于普通结构和对结构的引用）之间使用成员选择操作符（操作符.），或者从指针操作符（运算符->）中选择成员（对于结构的指针）。

在一般编程中，聚合数据类型（也称为聚合）是可以包含多个数据成员的任何类型。在C++中，只有数据成员的数组和结构是聚合的。

聚合使用一种称为聚合初始化的初始化形式，它允许我们直接初始化聚合的成员。为此，我们提供了一个初始化器列表作为初始化器，它只是一个逗号分隔值的列表。聚合初始化执行成员级初始化，这意味着结构中的每个成员都是按声明的顺序初始化的。

在C++20中，指定初始值设定项允许您显式定义哪些初始化值映射到哪些成员。成员必须按照在结构中声明的顺序进行初始化，否则将导致错误。

当我们定义结构（或类）类型时，我们可以为每个成员提供默认的初始化值，作为类型定义的一部分。该过程称为非静态成员初始化，初始化值称为默认成员初始值设定项。

出于性能原因，编译器有时会在结构中添加间隙（这称为填充），因此结构的大小可能大于其成员大小的总和。

类模板是用于实例化类类型（结构、类或联合）的模板定义。类模板参数演绎（CTAD）是C++17的一个功能，它允许编译器从初始值设定项中推导模板类型参数。

***
## 测验时间

耶！

问题#1

在设计游戏时，我们决定要有怪物，因为每个人都喜欢与怪物战斗。声明一个代表你的怪物的结构。怪物应该是以下类型之一：食人魔、龙、兽人、巨型蜘蛛或黏液。为此使用枚举类。

每个怪物也应该有一个名称（使用std:：string或std:∶string_view），以及表示它们在死亡之前可以承受的伤害的生命量。编写一个名为printMonster（）的函数，打印出结构的所有成员。实例化一个食人魔和一个黏液，使用初始化器列表初始化它们，并将它们传递给printMonster（）。

程序应产生以下输出：

显示解决方案

问题#2

指定是否应通过值、常量地址或常量引用传递每个给定类型的对象。可以假设将这些类型作为参数的函数不会修改它们。

a） 字符

显示解决方案

b） 标准：：字符串

显示解决方案

c） 无符号长

显示解决方案

d） 布尔

显示解决方案

e） 枚举类型

显示解决方案

f）、

```C++
struct Position
{
  double x{};
  double y{};
  double z{};
};
```

显示解决方案

g）

```C++
struct Player
{
  int health{};
  // The Player struct is still under development.  More members will be added.
};
```

显示解决方案

h） 整数*

显示解决方案

i） 标准：：字符串视图

显示解决方案

问题#3

创建名为Triad的类模板，该类模板具有3个相同模板类型的成员。还创建一个名为print的函数模板，可以打印空间坐标轴。应编译以下程序：

```C++
int main()
{
	Triad t1{ 1, 2, 3 }; // note: uses CTAD to deduce template arguments
	print(t1);

	Triad t2{ 1.2, 3.4, 5.6 }; // note: uses CTAD to deduce template arguments
	print(t2);

	return 0;
}
```

并产生以下结果：

如果您使用的是C++17，则需要为CTAD提供演绎指南才能工作（请参见13.12——类模板参数演绎（CTAD）和演绎指南，以了解有关信息）。

显示解决方案

