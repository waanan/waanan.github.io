---
title: "算术运算符"
date: 2023-12-07T13:09:17+08:00
---

***
## 一元算术运算符

有两个一元算术运算符，加号（+）和减号（-）。提醒一下，一元运算符是仅采用一个操作数的运算符。

一元减运算符返回乘以-1的操作数。换句话说，如果x=5，-x是-5。

一元加法运算符返回操作数的值。换句话说，+5是5，+x是x。通常，您不需要使用此运算符，因为它是冗余的。它主要是为了提供一元负算子的对称性而添加的。

为了可读性，这两个操作符都应该放在操作数之前（例如-x，而不是-x）。

不要将一元减法运算符与二进制减法运算符混淆，后者使用相同的符号。例如，在表达式x=5--3中；，第一个减号是二进制减法运算符，第二个是一元减法运算符。

***
## 二进制算术运算符

有5个二进制算术运算符。二元运算符是采用左操作数和右操作数的运算符。

加法、减法和乘法运算符的工作方式与它们在现实生活中的工作方式相同，没有任何警告。

除法和余数需要一些额外的解释。我们将在下面讨论除法，其余部分将在下一课中讨论。

***
## 整数和浮点除法

最容易想到的是，除法运算符具有两种不同的“模式”。

如果操作数中的一个（或两个）是浮点值，则除法运算符执行浮点除法。浮点除法返回浮点值，并保留分数。例如，7.0/4=1.75、7/4.0=1.75和7.0/4.0=1.75。与所有浮点算术运算一样，可能会发生舍入错误。

如果两个操作数都是整数，则除法运算符执行整数除法。整数除法删除任何分数并返回整数值。例如，7/4=1，因为结果的小数部分被丢弃。类似地，-7/4=-1，因为分数被丢弃。

***
## 使用static_cast<>对整数进行浮点除法

上面提出了一个问题——如果我们有两个整数，并且希望在不丢失分数的情况下对它们进行除法，我们将如何做？

在第4.12课——类型转换和static_cast简介中，我们展示了如何使用static_cast<>操作符将字符转换为整数，以便将其打印为整数而不是字符。

类似地，我们可以使用static_cast<>将整数转换为浮点数，以便可以进行浮点除法，而不是整数除法。考虑以下代码：

```C++
#include <iostream>

int main()
{
    int x{ 7 };
    int y{ 4 };

    std::cout << "int / int = " << x / y << '\n';
    std::cout << "double / int = " << static_cast<double>(x) / y << '\n';
    std::cout << "int / double = " << x / static_cast<double>(y) << '\n';
    std::cout << "double / double = " << static_cast<double>(x) / static_cast<double>(y) << '\n';

    return 0;
}
```

这将产生以下结果：

以上说明，如果任一操作数是浮点数，则结果将是浮点除法，而不是整数除法。

***
## 除以0和0.0

除数为0的整数除法将导致未定义的行为，因为结果在数学上是未定义的！

```C++
#include <iostream>

int main()
{
	std::cout << "You have 12 apples. Enter how many people to divide them between: ";
	int x {};
	std::cin >> x;

	std::cout << "Each person gets " << 12 / x << " whole apples.\n"; // 12 and x are int, so this is integer division

	return 0;
}
```

如果运行上述程序并输入0，则程序可能会崩溃。去试试吧，它不会损害你的计算机。

除以浮点值0.0的结果是实现定义的（这意味着行为由编译器/体系结构决定）。在支持IEEE754浮点格式的架构上，结果将是NaN或Inf。在其他架构上，其结果可能是未定义的行为。

通过运行以下程序并输入0或0.0，可以查看程序的功能：

```C++
#include <iostream>

int main()
{
	std::cout << "You have 12 apples. Enter how many servings of apples you want: ";
	double d {};
	std::cin >> d;

	std::cout << "Each serving is " << 12 / d << " apples.\n"; // d is double, so this is floating point division

	return 0;
}
```

{{< alert success >}}
**相关内容**

我们在第4.8课-浮点数中讨论NaN和Inf。

{{< /alert >}}

***
## 算术赋值运算符

到目前为止，当您需要将4添加到变量时，您可能已经完成了以下操作：

```C++
x = x + 4; // add 4 to existing value of x
```

这是可行的，但有点笨拙，需要两个操作符来执行（operator+和operator=）。

由于编写x=x+4之类的语句非常常见，因此C++为方便起见提供了五个算术赋值运算符。您可以写x+=4，而不是写x=x+4。可以写x*=y，而不是x=x*y。

因此，上述内容变为：

```C++
x += 4; // add 4 to existing value of x
```

