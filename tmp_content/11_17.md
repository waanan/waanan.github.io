---
title: "第10章总结和测验"
date: 2023-11-01T20:12:31+08:00
---

你成功了！本章中的主题（特别是类型别名、重载函数和函数模板）在C++标准库中无处不在。因此，您现在离理解一切是如何工作的更近了一大步！

***
## 快速审阅

将值从一种数据类型转换为另一种数据形式的过程称为类型转换。

只要需要一种数据类型，但提供了不同的数据类型，就执行隐式类型转换（也称为自动类型转换或强制）。如果编译器能够找出如何在这两种类型之间进行转换，它就会知道。如果它不知道如何操作，那么它将失败，并出现编译错误。

C++语言在其基本类型之间定义了许多内置转换（以及一些用于更高级类型的转换），称为标准转换。这些包括数字提升、数字转换和算术转换。

数值提升是将某些较小的数值类型转换为某些较大的数值类型（通常为int或double），以便CPU可以对与处理器的自然数据大小匹配的数据进行操作。数字促销包括积分促销和浮点促销。数字促销是保持价值的，这意味着不会损失价值或精度。并非所有扩大的转换都是促销。

数值转换是不是数值提升的基本类型之间的类型转换。窄化转换是可能导致值或精度丢失的数字转换。

在C++中，某些二进制运算符要求其操作数具有相同的类型。如果提供了不同类型的操作数，则使用一组称为常用算术转换的规则将其中一个或两个操作数隐式转换为匹配类型。

当程序员通过强制转换显式请求转换时，执行显式类型转换。强制转换表示程序员执行显式类型转换的请求。C++支持5种类型的转换：C样式转换、静态转换、常量转换、动态转换和重新解释转换。通常，应避免C样式转换、常量转换和重新解释转换。static_cast用于将值从一种类型转换为另一种类型的值，并且是迄今为止C++中使用最多的转换。

Typedef和类型别名允许程序员为数据类型创建别名。这些别名不是新类型，其行为与别名类型相同。Typedef和类型别名不提供任何类型的类型安全，需要注意不要假设别名与其别名的类型不同。

auto关键字有许多用法。首先，auto可以用于进行类型推导（也称为类型推理），这将从变量的初始值设定项中推导变量的类型。类型演绎会删除常量和引用，因此如果需要，请确保将它们添加回。

Auto也可以用作函数返回类型，以使编译器从函数的返回语句推断函数的返回类型，尽管对于普通函数应该避免这种情况。Auto用作尾部返回语法的一部分。

函数重载允许我们创建具有相同名称的多个函数，只要每个同名函数具有不同的参数类型集（或者可以以其他方式区分函数）。这样的函数称为重载函数（简称重载）。返回类型不考虑区分。

在解析重载函数时，如果找不到精确匹配，编译器将更喜欢可以通过数字提升匹配的重载函数，而不是那些需要数字转换的重载函数。当对已重载的函数进行函数调用时，编译器将基于函数调用中使用的参数，尝试将函数调用与适当的重载相匹配。这称为重载解析。

当编译器发现两个或多个函数可以与重载函数的函数调用相匹配，但无法确定哪一个是最佳的时，就会发生不明确的匹配。

默认参数是为函数参数提供的默认值。具有默认参数的参数必须始终是最右边的参数，并且在解析重载函数时，它们不用于区分函数。

函数模板允许我们创建类似函数的定义，该定义用作创建相关函数的模式。在函数模板中，我们使用类型模板参数作为以后要指定的任何类型的占位符。告诉编译器我们正在定义模板并声明模板类型的语法称为模板参数声明。

从函数模板（具有模板类型）创建函数（具有特定类型）的过程简称为函数模板实例化（或实例化）。当这个过程由于函数调用而发生时，它被称为隐式实例化。实例化的函数称为函数实例（或简称为实例，有时称为模板函数）。

模板参数推导允许编译器从函数调用的参数中推导出应用于实例化函数的实际类型。模板参数推导不进行类型转换。

模板类型有时称为泛型类型，使用模板进行编程有时称为通用编程。

在C++20中，当auto关键字用作普通函数中的参数类型时，编译器将自动将函数转换为函数模板，每个auto参数都成为独立的模板类型参数。用于创建函数模板的方法称为缩写函数模板。

非类型模板参数是具有固定类型的模板参数，它用作作为模板参数传入的constexpr值的占位符。

***
## 测验时间

