---
title: "常量表达式、编译时常量和运行时常量"
date: 2023-11-28T13:19:42+08:00
---

在上一课5.1——常量变量（命名常量）中，我们介绍了如何使用const关键字使变量成为值不能更改的常量变量。

在本课中，我们将查看常量的另一个属性：它们是运行时常量还是编译时常量。

***
## 仿佛规则

在C++中，编译器有很大的余地来优化程序。仿佛规则说，编译器可以随意修改程序，以产生更优化的代码，只要这些修改不影响程序的“可观察行为”。

编译器优化的确切方式取决于编译器本身。然而，我们可以做一些事情来帮助编译器更好地优化。

{{< alert success >}}
**对于高级读者**

“仿佛”规则有一个例外：即使那些复制构造函数具有可观察的行为，也可以省略（省略）对复制构造函数的不必要调用。我们在第14.15课中讨论了这个主题——类初始化和复制省略。

{{< /alert >}}

***
## 优化机会

考虑以下简短计划：

```C++
#include <iostream>

int main()
{
	int x { 3 + 4 };
	std::cout << x << '\n';

	return 0;
}
```

输出很简单：

然而，其中隐藏着一种有趣的优化可能性。

如果此程序完全按照编写的方式编译（没有优化），编译器将生成一个可执行文件，该可执行文件在运行时（当程序运行时）计算3+4的结果。如果程序执行了一百万次，3+4将被求值一百万次；结果值7产生一百万次。

但请注意，3+4的结果永远不会改变——它总是7。因此，每次运行程序时重新评估3+4是浪费的。

***
## 常量表达式

常量表达式是编译器可以在编译时计算的表达式。要成为常量表达式，表达式中的所有值都必须在编译时已知（并且调用的所有运算符和函数都必须支持编译时求值）。

当编译器遇到常量表达式时，它可以在编译时计算表达式，然后用计算结果替换常量表达式。

在上面的程序中，表达式3+4是一个常量表达式。因此，当编译该程序时，编译器可以将常量表达式3+4替换为结果值7。换句话说，在假设规则下，编译器实际上可以编译以下内容：

```C++
#include <iostream>

int main()
{
	int x { 7 };
	std::cout << x << '\n';

	return 0;
}
```

该程序产生与以前版本相同的输出（7），但生成的可执行文件不再需要在运行时花费CPU周期来计算3+4！更好的是，我们不需要做任何事情来启用此行为（除了启用优化）。

请注意，表达式std:：cout<<x不是常量表达式，因为我们的程序不能在编译时将值输出到控制台。因此，该表达式将始终在运行时求值。必须在运行时计算的表达式有时称为运行时表达式。

{{< alert success >}}
**关键洞察力**

在编译时计算常量表达式会使编译花费更长的时间（因为编译器必须做更多的工作），但这样的表达式只需要计算一次（而不是每次运行程序时）。生成的可执行文件更快，并且使用更少的内存。

C++执行编译时评估的能力是现代C++最重要和不断发展的领域之一。

{{< /alert >}}

***
## 另一个优化机会

上面的程序中还有另一个效率低下的地方：程序为x分配内存，将值7存储在该内存中，然后在随后的语句中返回内存以获得要打印的x（7）的值。由于x的值从不改变，因此这种内存访问是浪费的。

换句话说，在假设规则下，编译器可以将上述程序优化为：

```C++
#include <iostream>

int main()
{
	std::cout << 7 << '\n';

	return 0;
}
```

但为了进行这种优化，编译器必须确保x在定义和使用之间没有变化。由于x是非常量，编译器将不得不进行自己的分析来确定是否是这种情况。虽然复杂的现代优化编译器可以做到这一点（至少在这个简单的情况下），但不太复杂的编译器或更复杂的情况将阻碍这种优化。

与常量表达式优化（本质上是免费的）不同，这种优化可能免费，也可能不免费。

然而，对于少量的工作，我们可以帮助编译器，使其更有可能执行这种优化。

***
## 编译时间常数

编译时常量是其值为常量表达式的常量。文字（例如“1”、“2.3”和“Hello，world！”）是编译时间常量的一种类型。

常量变量可以是也可以不是编译时常量（取决于它们的初始化方式）。

***
## 编译时间常量

如果常量变量的初始值设定项是常量表达式，则常量变量是编译时常量。

考虑一个类似于上面使用常量变量的程序：

```C++
#include <iostream>

int main()
{
	const int x { 3 };  // x is a compile-time const
	const int y { 4 };  // y is a compile-time const

	const int z { x + y }; // x + y is a constant expression, so z is compile-time const

	std::cout << z << '\n'; 

	return 0;
}
```

由于x和y的初始化值是常量表达式，因此x和y是编译时常量。这意味着x+y也是常量表达式。因此，当编译器编译该程序时，它可以计算x+y的值，并用结果文本7替换常量表达式。

请注意，编译时常量的初始值设定项可以是任何常量表达式。以下所有变量都是编译时常量变量：

```C++
const int z { 3 };     // 3 is a constant expression, so z is compile-time const
const int a { 1 + 2 }; // 1 + 2 is a constant expression, so a is compile-time const
const int b { z * 2 }; // z * 2 is a constant expression, so b is compile-time const
```

编译时间常量变量通常用作命名常量：

```C++
const double gravity { 9.8 };
```

***
## 远离优化编译时常量

编译时间常数使编译器能够执行非编译时间常数不可用的优化。在许多情况下，编译时常数可以完全在程序外优化。例如，每当使用编译时常量重力时，编译器可以简单地将标识符重力替换为双9.8，这避免了必须从内存中的某个位置获取值。

让我们回到前面的例子，在这里我们停止了这个程序：

```C++
#include <iostream>

int main()
{
	int x { 7 }; // x is non-constant
	std::cout << x << '\n';

	return 0;
}
```

现在，让我们将x设置为编译时间常量：

```C++
#include <iostream>

int main()
{
	const int x { 7 }; // x is now a compile-time constant
	std::cout << x << '\n';

	return 0;
}
```

如果我们这样做，编译器就会知道x不会改变，并且很可能会将程序优化为：

```C++
#include <iostream>

int main()
{
	std::cout << 7 << '\n';

	return 0;
}
```

在无法优化编译时常量变量的情况下（或关闭优化时），该变量仍将在运行时创建（和初始化）。

{{< alert success >}}
**关键洞察力**

使变量编译时常量有助于编译器确定可以优化的内容。

{{< /alert >}}

***
## 运行时常量

如果常量变量的初始值设定项是非常量表达式，则常量变量是运行时常量。运行时常量是在运行时之前无法确定其初始化值的常量。

下面的示例说明了作为运行时常量的常量的使用：

```C++
#include <iostream>

int getNumber()
{
    std::cout << "Enter a number: ";
    int y{};
    std::cin >> y;

    return y;  
}

int main()
{
    const int x { 3 };           // x is a compile time constant

    const int y { getNumber() }; // y is a runtime constant

    const int z { x + y };       // x + y is a runtime expression, so z is a runtime const
    
    return 0;
}
```

即使y有一个常量限定符，初始化值（getNumber（）的返回值）直到运行时才知道。因此，y是运行时常量，而不是编译时常量。由于y是运行时常量，因此必须在运行时计算y，因此表达式x+y也是运行时表达式。

{{< alert success >}}
**关键洞察力**

编译时间常量可以在常量表达式中使用，并允许更好的优化。运行时常量只能在非常量表达式中使用。它们的主要用途是确保对象的值不会被修改。

{{< /alert >}}

