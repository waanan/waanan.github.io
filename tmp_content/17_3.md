---
title: "正在传递std:：vector"
date: 2024-07-08T11:10:28+08:00
---

类型为std:：vector的对象可以像任何其他对象一样传递给函数。这意味着，如果我们按值传递std:：vector，将生成一个昂贵的副本。因此，我们通常通过（const）引用传递std:：vector以避免这种复制。

对于std:：vector，元素类型是对象类型信息的一部分。因此，当我们使用std:：vector作为函数参数时，我们必须显式指定元素类型：

```C++
#include <iostream>
#include <vector>

void passByRef(const std::vector<int>& arr) // we must explicitly specify <int> here
{
    std::cout << arr[0] << '\n';
}

int main()
{
    std::vector primes{ 2, 3, 5, 7, 11 };
    passByRef(primes);

    return 0;
}
```

***
## 正在传递不同元素类型的std:：vector

由于passByRef（）函数需要std:：vector<int>，因此无法传递具有不同元素类型的向量：

```C++
#include <iostream>
#include <vector>

void passByRef(const std::vector<int>& arr)
{
    std::cout << arr[0] << '\n';
}

int main()
{
    std::vector primes{ 2, 3, 5, 7, 11 };
    passByRef(primes);  // ok: this is a std::vector<int>

    std::vector dbl{ 1.1, 2.2, 3.3 };
    passByRef(dbl); // compile error: std::vector<double> is not convertible to std::vector<int>

    return 0;
}
```

在C++17或更新版本中，您可以尝试使用CTAD来解决此问题：

```C++
#include <iostream>
#include <vector>

void passByRef(const std::vector& arr) // compile error: CTAD can't be used to infer function parameters
{
    std::cout << arr[0] << '\n';
}

int main()
{
    std::vector primes{ 2, 3, 5, 7, 11 }; // okay: use CTAD to infer std::vector<int>
    passByRef(primes);

    return 0;
}
```

尽管在定义向量时，CTAD可以从初始值设定项中推断出它的元素类型，但CTAD（目前）不能处理函数参数。

我们以前见过这种问题，其中我们有只因参数类型不同而不同的重载函数。这是一个使用函数模板的好地方！我们可以创建一个参数化元素类型的函数模板，然后C++将使用该函数模板来实例化具有实际类型的函数。

我们可以创建使用相同模板参数声明的函数模板：

```C++
#include <iostream>
#include <vector>

template <typename T>
void passByRef(const std::vector<T>& arr)
{
    std::cout << arr[0] << '\n';
}

int main()
{
    std::vector primes{ 2, 3, 5, 7, 11 };
    passByRef(primes); // ok: compiler will instantiate passByRef(const std::vector<int>&)

    std::vector dbl{ 1.1, 2.2, 3.3 };
    passByRef(dbl);    // ok: compiler will instantiate passByRef(const std::vector<double>&)

    return 0;
}
```

在上面的示例中，我们创建了一个名为passByRef（）的函数模板，该模板具有类型为const-std:：vector<T>&的参数。T在上一行的模板参数声明中定义：template<typename T.T是一个标准类型模板参数，允许调用方指定元素类型。

因此，当我们从main（）调用passByRef（质数）时（其中质数定义为std:：vector<int>），编译器将实例化并调用void passByRef（const std::vector<int>&arr）。

当我们从main（）调用passByRef（dbl）时（其中dbl定义为std:：vector<double>），编译器将实例化并调用void passByRef（const std::vector<double>&arr）。

因此，我们创建了一个单独的函数模板，可以实例化函数来处理任何元素类型和长度的std:：vector参数！

{{< alert success >}}
**相关内容**

我们在第11.6课——函数模板中介绍了函数模板。

{{< /alert >}}

***
## 使用通用模板或缩写函数模板传递std:：vector

我们还可以创建一个函数模板，该模板将接受任何类型的对象：

```C++
#include <iostream>
#include <vector>

template <typename T>
void passByRef(const T& arr) // will accept any type of object that has an overloaded operator[]
{
    std::cout << arr[0] << '\n';
}

int main()
{
    std::vector primes{ 2, 3, 5, 7, 11 };
    passByRef(primes); // ok: compiler will instantiate passByRef(const std::vector<int>&)

    std::vector dbl{ 1.1, 2.2, 3.3 };
    passByRef(dbl);    // ok: compiler will instantiate passByRef(const std::vector<double>&)

    return 0;
}
```

在C++20中，我们可以使用缩写的函数模板（通过自动参数）来执行相同的操作：

```C++
#include <iostream>
#include <vector>

void passByRef(const auto& arr) // abbreviated function template
{
    std::cout << arr[0] << '\n';
}

int main()
{
    std::vector primes{ 2, 3, 5, 7, 11 };
    passByRef(primes); // ok: compiler will instantiate passByRef(const std::vector<int>&)

    std::vector dbl{ 1.1, 2.2, 3.3 };
    passByRef(dbl);    // ok: compiler will instantiate passByRef(const std::vector<double>&)

    return 0;
}
```

这两个参数都将接受任何类型的将编译的参数。在编写我们可能希望对不仅仅是std:：vector进行操作的函数时，这是理想的。例如，上面的函数也可以在std:：数组、std::string或我们甚至没有考虑过的其他类型上工作。

该方法的潜在缺点是，如果函数被传递给一个编译但在语义上没有意义的类型的对象，它可能会导致错误。

***
## 断言数组长度

考虑以下模板函数，该函数类似于上面给出的函数：

```C++
#include <iostream>
#include <vector>

template <typename T>
void printElement3(const std::vector<T>& arr)
{
    std::cout << arr[3] << '\n';
}

int main()
{
    std::vector arr{ 9, 7, 5, 3, 1 };
    printElement3(arr);

    return 0;
}
```

虽然printElement3（arr）在这种情况下工作良好，但在该程序中有一个潜在的错误等待粗心的程序员。看到了吗？

上面的程序打印索引为3的数组元素的值。只要数组具有索引为3的有效元素，这是可以的。然而，编译器很乐意让您传入索引3超出界限的数组。例如：

```C++
#include <iostream>
#include <vector>

template <typename T>
void printElement3(const std::vector<T>& arr)
{
    std::cout << arr[3] << '\n';
}

int main()
{
    std::vector arr{ 9, 7 }; // a 2-element array (valid indexes 0 and 1)
    printElement3(arr);

    return 0;
}
```

这会导致未定义的行为。

这里的一个选项是对arr.size（）进行断言，当在调试构建配置中运行时，它将捕获此类错误。由于std:：vector:：size（）是一个非常量表达式函数，因此我们只能在这里进行运行时断言。

最好的选择是避免编写依赖于用户首先传入具有最小长度的向量的函数。



{{< alert success >}}
**提示**

更好的选择是避免在需要断言数组长度的情况下使用std:：vector。使用支持constexpr数组的类型（例如，std:：array）可能是更好的选择，因为您可以对constexpr.数组的长度进行static_assert。我们将在以后的第17.3课中讨论这一点——传递和返回std:：array。

{{< /alert >}}

***
## 测验时间

问题#1



编写一个接受两个参数的函数：std:：vector和index。如果索引超出界限，则打印错误。如果索引在范围内，则打印元素的值。

应编译以下示例程序：

```C++
#include <iostream>
#include <vector>

// Write your printElement function here

int main()
{
    std::vector v1 { 0, 1, 2, 3, 4 };
    printElement(v1, 2);
    printElement(v1, 5);

    std::vector v2 { 1.1, 2.2, 3.3 };
    printElement(v2, 0);
    printElement(v2, -1);

    return 0;
}
```

并产生以下结果：

显示解决方案

