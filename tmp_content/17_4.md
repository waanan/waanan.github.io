---
title: "返回std:：vector，并介绍移动语义"
date: 2024-07-08T11:10:28+08:00
---

当我们需要将std:：vector传递给函数时，我们通过（const）引用传递它，以便不制作数组数据的昂贵副本。

因此，您可能会惊讶地发现，可以逐值返回std:：vector。

说whaaaaaaaaAAAAAAAAaaAAAAaaaaAAaaaaaaAA？

***
## 复制语义

考虑以下程序：

```C++
#include <iostream>
#include <vector>

int main()
{
    std::vector arr1 { 1, 2, 3, 4, 5 }; // copies { 1, 2, 3, 4, 5 } into arr1
    std::vector arr2 { arr1 };          // copies arr1 into arr2

    arr1[0] = 6; // We can continue to use arr1
    arr2[0] = 7; // and we can continue to use arr2

    std::cout << arr1[0] << arr2[0] << '\n';

    return 0;
}
```

当arr2用arr1初始化时，调用std:：vector的复制构造函数，该构造函数将arr1复制到arr2中。

在这种情况下，制作副本是唯一合理的做法，因为我们需要arr1和arr2独立生活。本例最后制作了两个副本，每个初始化一个副本。

术语复制语义是指确定如何制作对象副本的规则。当我们说类型支持复制语义时，我们的意思是该类型的对象是可复制的，因为已经定义了制作这种副本的规则。当我们说正在调用复制语义时，这意味着我们已经做了一些事情来制作对象的副本。

对于类类型，复制语义通常通过复制构造函数（和复制赋值运算符）实现，该构造函数定义了如何复制该类型的对象。通常，这会导致复制类类型的每个数据成员。在前面的示例中，语句std:：vector arr2{arr1}；调用复制语义，导致调用std:：vector的复制构造函数，该构造函数随后将arr1的每个数据成员复制到arr2中。最终结果是arr1等价于（但独立于）arr2。

***
## 当复制语义不是最佳的时

现在考虑这个相关的例子：

```C++
#include <iostream>
#include <vector>

std::vector<int> generate() // return by value
{
    // We're intentionally using a named object here so mandatory copy elision doesn't apply
    std::vector arr1 { 1, 2, 3, 4, 5 }; // copies { 1, 2, 3, 4, 5 } into arr1
    return arr1;
}

int main()
{
    std::vector arr2 { generate() }; // the return value of generate() dies at the end of the expression

    // There is no way to use the return value of generate() here
    arr2[0] = 7; // we only have access to arr2

    std::cout << arr2[0] << '\n';

    return 0;
}
```

当arr2这次被初始化时，它正在使用函数generate（）返回的临时对象进行初始化。与前面的情况不同，其中初始值设定项是可以在未来语句中使用的左值，在这种情况下，临时对象是右值，将在初始化表达式的末尾被销毁。临时对象不能在该点之后使用。由于临时（及其数据）将在表达式末尾被销毁，因此我们需要某种方法将数据从临时中取出并放入arr2。

这里通常要做的事情与前面的示例相同：使用复制语义，并制作可能昂贵的副本。这样，arr2就获得了自己的数据副本，即使在临时（及其数据）被销毁后，也可以使用该副本。

然而，与前面的示例不同的是，临时文件无论如何都将被销毁。初始化完成后，临时文件不再需要其数据（这就是为什么我们可以销毁它）。我们不需要同时存在两组数据。在这种情况下，制作一个可能昂贵的拷贝，然后销毁原始数据是次优的。

***
## 移动语义简介

相反，如果arr2有一种方法可以“窃取”临时文件的数据，而不是复制它，该怎么办？然后，arr2将是数据的新所有者，并且不需要制作数据的副本。当数据的所有权从一个对象转移到另一个对象时，我们说数据已被移动。这种移动的成本通常很小（通常只有两个或三个指针分配，这比复制数据数组快得多！）。

作为一个额外的好处，当临时文件随后在表达式末尾被销毁时，它将不再有任何数据要销毁，因此我们也不必支付该成本。

这是移动语义的本质，它是指确定如何将数据从一个对象移动到另一个对象的规则。当调用移动语义时，将移动任何可以移动的数据成员，并复制任何无法移动的数据构件。移动数据而不是复制数据的能力可以使移动语义比复制语义更有效，特别是当我们可以用廉价的移动替换昂贵的副本时。

{{< alert success >}}
**关键洞察力**

移动语义是一种优化，它允许我们在某些情况下以较低的成本将某些数据成员的所有权从一个对象转移到另一个对象（而不是制作更昂贵的副本）。

而是复制无法移动的数据成员。

{{< /alert >}}

***
## 如何调用移动语义

通常，当用相同类型的对象初始化对象或为对象分配相同类型的属性时，将使用复制语义（假设没有省略副本）。

然而，当以下所有条件都为真时，将调用移动语义：

1. 对象的类型支持移动语义。
2. 从分配的初始值设定项或对象是rvalue（临时）对象。
3. 移动不会被忽略。


不幸的是，并不是很多类型都支持移动语义。然而，std:：vector和std:：string都可以！

在第22章中，我们将更详细地研究移动语义是如何工作的。现在，知道什么是移动语义，以及哪些类型支持移动就足够了。

{{< alert success >}}
**相关内容**

我们在第14.15课中讨论了复制省略——类初始化和复制省略。

{{< /alert >}}

***
## 我们可以按值返回支持移动的类型，如std:：vector

由于按值返回返回值，因此如果返回的类型支持移动语义，则可以移动返回的值，而不是将其复制到目标对象中。这使得这些类型的按值返回非常便宜！

{{< alert success >}}
**关键洞察力**

我们可以按值返回支持移动的类型（如std:：vector和std:∶string）。这样的类型将以较低的成本移动其值，而不是制作昂贵的副本。

此类类型仍应通过常量引用传递。

{{< /alert >}}

***
## 等等，等等，等等。复制类型的开销不应该通过值传递，但如果它们支持移动，则可以通过值返回它们？

正确。

下面的讨论是可选的，但可能有助于您理解为什么会出现这种情况。

我们在C++中做的最常见的事情之一是将一个值传递给某个函数，然后返回一个不同的值。当传递的值是类类型时，该过程涉及4个步骤：

下面是使用std:：vector的上述过程的示例：

```C++
#include <iostream>
#include <vector>

std::vector<int> doSomething(std::vector<int> v2)
{
    std::vector v3 { v2[0] + v2[0] }; // 3 -- construct value to be returned to caller
    return v3; // 4 -- actually return value
}

int main()
{
    std::vector v1 { 5 }; // 1 -- construct value to be passed to function
    std::cout << doSomething(v1)[0] << '\n'; // 2 -- actually pass value

    std::cout << v1[0] << '\n';

    return 0;
}
```

首先，假设std:：vector不支持移动。在这种情况下，上述程序制作4个副本：

现在，让我们谈谈如何优化上述内容。我们在这里可以处理许多工具：通过引用或地址传递、省略、移动语义和输出参数。

我们根本无法优化副本1和3。我们需要一个std:：vector来传递给函数，并且需要一个std:：vector来返回——必须构造这些对象。vector是其数据的所有者，因此它必须复制其初始值设定项。

我们可以影响副本2和4。

复制2是因为我们正在通过值从调用者传递到被调用的函数。我们还有其他选择吗？

1. 我们可以通过引用或地址传递吗？是的。我们可以保证参数将存在于整个函数调用中——调用方不必担心传递的对象意外超出范围。
2. 这个副本可以删掉吗？不。Elision仅在进行冗余复制或移动时有效。这里没有多余的拷贝或移动。
3. 我们可以在这里使用out参数吗？不。我们正在将值传递给函数，而不是获取值。
4. 我们可以在这里使用移动语义吗？不，参数是左值。如果我们将数据从v1移动到v2，v1将成为空向量，随后打印v1[0]将导致未定义的行为。


显然，在这里，通过常量引用传递是我们最好的选择，因为它避免了复制，避免了空指针问题，并同时使用左值和右值参数。

复制4是因为我们将按值从被调用的函数传递回调用方。我们还有其他选择吗？

1. 我们可以通过引用或地址返回吗？不。我们返回的对象是作为函数内的局部变量创建的，并且将在函数返回时被销毁。返回引用或指针将导致调用方接收悬空指针或引用。
2. 这个副本可以删掉吗？是的，可能吧。如果编译器是智能的，它将意识到我们正在被调用函数的范围内构造一个对象并返回它。通过重写代码（在假设规则下），以便在调用方的范围内构建v3，我们可以避免在返回时生成的副本。然而，我们依赖于编译器实现它可以做到这一点，因此不能保证。
3. 我们可以在这里使用out参数吗？是的。我们可以在调用者的范围内构造一个空的std:：vector对象，并通过非常量引用将其传递给函数，而不是将v3构造为局部变量。然后，该函数可以用数据填充该参数。当函数返回时，该对象将仍然存在。这避免了复制，但也有一些显著的缺点和约束：难看的调用语义，不能处理不支持赋值的对象，并且编写既可以处理左值参数又可以处理右值参数的函数是一项挑战。
4. 我们可以在这里使用移动语义吗？是的。当函数返回时，v3将被销毁，因此，我们可以使用移动语义将其数据移动到调用方，而不是将v3复制回调用方，从而避免复制。


在这里，Elision是最好的选择，但它是否发生是我们无法控制的。支持移动的类型的下一个最佳选项是移动语义，它可以在编译器不删除副本的情况下使用。对于支持移动的类型，在按值返回时自动调用移动语义。

总之，对于支持移动的类型，我们更喜欢通过常量引用传递，并通过值返回。

