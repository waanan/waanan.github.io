---
title: "C中的基本继承++"
date: 2024-10-08T17:45:57+08:00
---

既然我们已经讨论了什么是抽象意义上的继承，那么让我们讨论一下如何在C++中使用它。C++中的继承发生在类之间。在继承（is-a）关系中，从中继承的类称为父类、基类或超类，而执行继承的类则称为子类、派生类或子类。在上图中，水果是父母，苹果和香蕉都是孩子。在该图中，三角形既是图形的子对象，也是直角三角形的父对象。子类从父类继承行为（成员函数）和属性（成员变量）（受我们将在未来课程中介绍的一些访问限制的限制）。这些变量和函数成为派生类的成员。因为子类是成熟的类，所以它们（当然）可以有自己的特定于该类的成员。稍后我们将看到一个例子。Person类这里有一个简单的类来表示泛型Person：#include<string>#incl包括<string_view>classPerson{//在这个例子中，为了简单起见，我们将成员设置为public:std:：string m_name{}；整数_页{}；个人（std:：string_view name=“”，int age=0）：m_name{name}，m_age{age}{}常量std::string&getName（）const{return m_name；}int getAge（）const{returns m_age；}}；因为这个Person类被设计为表示泛型Person，所以我们只定义了对任何类型的人都通用的成员。每个人（无论性别、职业等……）都有名字和年龄，因此这些都在这里表示。注意，在这个例子中，我们已经将所有变量和函数设置为公共的。这纯粹是为了使这些示例现在保持简单。通常，我们会将变量设为私有。我们将在本章后面讨论访问控制以及这些访问控制如何与继承交互。BaseballPlayer类假设我们想编写一个程序来跟踪一些棒球运动员的信息。棒球运动员需要包含特定于棒球运动员的信息——例如，我们可能希望存储运动员的击球平均数，以及他们击出的本垒打次数。这是我们不完整的棒球手类：class BaseballPlayer{//在这个例子中，为了简单起见，我们将成员公开：double m_battingAverage{}；int m_homeRuns{}；棒球运动员（双击平均值=0.0，int homeRuns=0）：m_battingAverage{battingAverage}，m_homeRuns{homeRuns.}{}}；现在，我们还想跟踪棒球运动员的姓名和年龄，并且我们已经将该信息作为Person类的一部分。对于如何向BaseballPlayer添加姓名和年龄，我们有三个选择：将姓名和年龄直接作为成员添加到BaseballPlayer类。这可能是最糟糕的选择，因为我们正在复制已经存在于Person类中的代码。Person的任何更新都必须在BaseballPlayer中进行。使用合成将Person添加为BaseballPlayer的成员。但我们必须问自己，“棒球运动员有人吗”？不，它不是。所以这不是正确的范例。让BaseballPlayer从Person继承这些属性。请记住，继承表示is-a关系。棒球运动员是人吗？是的，是的。所以继承在这里是一个很好的选择。使BaseballPlayer成为派生类要使Baseball Player从Person类继承，语法相当简单。在类BaseballPlayer声明之后，我们使用冒号、单词“public”和希望继承的类的名称。这称为公共继承。在以后的课程中，我们将详细讨论公共继承的含义。//公开继承Person类的BaseballPlayer:public Person{public:double m_battingAverage{}；int m_homeRuns{}；棒球运动员（双击平均值=0.0，int homeRuns=0）：m_battingAverage{battingAverage}，m_homeRuns{homeRuns.}{}}；使用派生图，我们的继承看起来像这样：当BaseballPlayer从Person继承时，BaseballPlayer从Person.获取成员函数和变量。此外，BaseballPlayer还定义了自己的两个成员：m_battingAverage和m_homeRuns。这是有意义的，因为这些属性特定于棒球运动员，而不是任何人。因此，BaseballPlayer对象将具有4个成员变量：来自BaseballPlayer的m_battingAverage和m_homeRuns，以及来自Person的m_name和m_age。这很容易证明：#include<iostream>#incluse<string>#in包括<string_view>ClassPerson{public:std:：string m_name{}；整数_页{}；个人（std:：string_view name=“”，int age=0）：m_name{name}，m_age{age}{}常量std::string&getName（）const{return m_name；}int getAge（）const{returns m_age；}}；//公开继承Person类的BaseballPlayer:public Person{public:double m_battingAverage{}；int m_homeRuns{}；棒球运动员（双击平均值=0.0，int homeRuns=0）：m_battingAverage{battingAverage}，m_homeRuns{homeRuns.}{}}；int main（）{//创建新的BaseballPlayer对象BaseballPlayer joe{}；//为其分配一个名称（我们可以直接这样做，因为m_name是公共的）joe.m_name=“joe”；//打印出名称std:：cout<<joe.getName（）<<'\n'；//使用我们从Person基类return 0；}获得的getName（）函数它打印值：Joe这将编译并运行，因为Joe是BaseballPlayer，并且所有BaseballPlayer对象都有一个m_name成员变量和一个从Person类继承的getName（）成员函数。Employee派生的类现在让我们编写另一个也继承自Person的类。这一次，我们将编写一个Employee类。雇员“是”人，因此使用继承是适当的：//雇员从person类employee:public person{public:double m_hourlySalary{}公开继承；长m_employeeID{}；员工（双小时Salary=0.0，长employeeID=0）：m_hourlySalary{HourlySalage}，m_employeeID{employerID}{}void printNameAndSalary（）constd:：cout<<m_name<<“：”<<m_houllySalary<<'\n'；}}；Employee从Person继承m_name和m_age（以及两个访问函数），并添加另外两个成员变量和自己的成员函数。请注意，printNameAndSalary（）使用它所属的类（Employee:：m_hourlySalary）和父类（Person:：m_name）中的变量。这给了我们一个类似这样的派生图：请注意，Employee和BaseballPlayer没有任何直接关系，即使它们都继承自Person。下面是一个使用Employee:#include<iostream>#incluse<string>#inclassPerson{public:std:：stringm_name{}的完整示例；整数_页{}；个人（std:：string_view name=“”，int age=0）：m_name{name}，m_age{age}{}常量std::string&getName（）const{return m_name；}int getAge（）const{returns m_age；}}；//员工从Person类公开继承Employee:public Person{public:double m_hourlySalary{}；长m_employeeID{}；员工（双小时Salary=0.0，长employeeID=0）：m_hourlySalary{HourlySalage}，m_employeeID{employerID}{}void printNameAndSalary（）constd:：cout<<m_name<<“：”<<m_houllySalary<<'\n'；}}；int main（）{员工弗兰克{20.25，12345}；frank.m_name=“弗兰克”；//我们可以这样做，因为m_name是public frank.printNameAndSalary（）；返回0；}打印：Frank:20.25继承链可以从本身派生自另一个类的类继承。这样做时没有什么值得注意或特别的东西——一切都像上面的例子那样进行。例如，让我们编写一个Supervisor类。主管是员工，是个人。我们已经编写了一个Employee类，因此让我们使用它作为从中派生Supervisor:ClassSupervisor：public Employer{public://该Supervisor最多可以监督5个长为m_overviewsIDs[5]{}；}的员工；现在，我们的派生图如下所示：所有Supervisor对象都继承Employee和Person的函数和变量，并添加自己的m_overviewsID成员变量。通过构建这样的继承链，我们可以创建一组非常通用的可重用类（在顶部），并在每个继承级别上逐渐变得更具体。为什么这种继承有用？从基类继承意味着我们不必在派生类中重新定义来自基类的信息。我们通过继承自动接收基类的成员函数和成员变量，然后简单地添加所需的附加函数或成员变量。这不仅节省了工作，还意味着如果我们更新或修改基类（例如，添加新函数或修复错误），我们的所有派生类都将自动继承更改！例如，如果我们曾经向Person添加了一个新函数，那么Employee、Supervisor和BaseballPlayer将自动获得对它的访问权限。如果我们向Employme添加了一种新变量，那么Supervisor也将获得对它进行访问的权限。这允许我们以简单、直观和低维护的方式构造新类！结论继承允许我们通过让其他类继承其成员来重用类。在以后的课程中，我们将继续探索这是如何工作的。下一课24.3派生类的构造顺序返回目录上一课24.1继承简介

