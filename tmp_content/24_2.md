---
title: "聚合"
date: 2024-10-08T17:40:35+08:00
---

在上一课23.2——合成中，我们注意到对象合成是从简单对象创建复杂对象的过程。我们还讨论了一种类型的对象组合，称为组合。在组合关系中，整个对象负责部分的存在。在本课中，我们将查看对象合成的另一个子类型，称为聚合。聚合若要符合聚合的条件，整个对象及其部分必须具有以下关系：部分（成员）是对象（类）的一部分部分（如果需要）一次可以属于多个对象（类。然而，与合成不同，零件一次可以属于多个对象，并且整个对象不负责零件的存在和寿命。创建聚合时，聚合不负责创建部件。当聚合被销毁时，聚合不负责销毁部件。例如，考虑一个人与其家庭住址之间的关系。在这个例子中，为了简单起见，我们将说每个人都有一个地址。然而，这个地址一次可以属于多个人：例如，你和你的室友或重要的另一半。然而，该地址不是由该人管理的——该地址可能在该人到达那里之前就存在，并将在该人离开之后存在。此外，一个人知道他们住在什么地址，但地址不知道人们住在那里。因此，这是一种聚合关系。或者，考虑汽车和发动机。汽车发动机是汽车的一部分。尽管引擎属于汽车，但它也可以属于其他东西，如拥有汽车的人。汽车不对发动机的产生或损坏负责。虽然汽车知道它有一个引擎（为了到达任何地方，它必须这样做），但引擎并不知道它是汽车的一部分。在对物理对象建模时，使用术语“已销毁”可能有点冒险。有人可能会说，“如果一颗流星从天而降，压碎了汽车，难道汽车零部件不会也都被摧毁吗？”是的，当然。但那是流星的错。重要的一点是，汽车不对其部件的损坏负责（但外力可能是）。我们可以说聚合模型“有一个”关系（一个部门有教师，汽车有发动机）。与合成类似，聚合的各个部分可以是单数的，也可以是乘法的。实现聚合由于聚合类似于组合，因为它们都是部分-整体关系，因此它们的实现几乎相同，并且它们之间的区别主要是语义上的。在组合中，我们通常使用普通成员变量（或指针，其中分配和释放过程由组合类处理）将部件添加到组合中。在聚合中，我们还添加部件作为成员变量。然而，这些成员变量通常是引用或指针，用于指向在类范围之外创建的对象。因此，聚合通常要么将其要指向的对象作为构造函数参数，要么开始为空，然后通过访问函数或操作符添加子对象。由于这些部分存在于类的范围之外，因此当类被销毁时，指针或引用成员变量将被销毁（但不会删除）。因此，部件本身仍然存在。让我们更详细地看一个教师和系的例子。在这个例子中，我们将做几个简化：首先，该系将只容纳一名教师。其次，老师不知道他们是哪个系的一员#include<iostream>#include<string>#in包括<string_view>类教师{private:std:：string m_name{}；公共：教师（std:：string_view名称）：m_name{name}{}常量std::string&getName（）常量{return m_name；}}；class Department{private:const Teacher&m_tacher；//为了简单起见，该部门仅包含一名教师，但它可以包含许多公开教师：部门（const Teacher&Teacher）：m_tacher{Teacher}{}}；int main（）{//在部门教师bob{“bob”}的范围之外创建教师；//创建教师{//创建部门并使用构造函数参数将教师传递//给它。部门部门{bob}；}//department在此处超出范围并被销毁//bob仍然存在于此处，但departmentdoes not std:：cout<<bob.getName（）<<“still exists！\n”；返回0；}在这种情况下，bob是独立于部门创建的，然后传递给部门的构造函数。当department被销毁时，m_testacher引用被销毁，但教师本身没有被销毁，因此它仍然存在，直到稍后在main（）中独立销毁为止。为您正在建模的内容选择正确的关系尽管在上面的示例中，教师不知道他们为哪个部门工作似乎有点傻，但在给定的程序环境中，这可能是完全正确的。当您决定要实现哪种关系时，请实现满足您需求的最简单的关系，而不是看起来最适合现实生活环境的关系。例如，如果您正在编写车身车间模拟器，您可能希望将汽车和发动机实现为聚合，以便可以卸下发动机，并将其放在某处的架子上，供以后使用。然而，如果您正在编写赛车模拟，您可能希望将汽车和发动机实现为组合，因为在该上下文中，发动机永远不会存在于汽车外部。最佳实践实现最简单的关系类型，以满足程序的需要，而不是现实生活中看似正确的关系类型。汇总组合和聚合组合：通常使用普通成员变量如果类自己处理对象分配/释放，则可以使用指针成员负责创建/销毁部分聚合：通常使用指向或引用位于聚合类范围之外的对象的指针或引用成员不负责创建/摧毁部分值得注意的是，组合和聚合的概念可以在同一个类中自由混合。完全可以编写一个负责创建/销毁某些部分而不是其他部分的类。例如，我们的系班级可以有一个名字和一个老师。该名称可能会通过组合添加到该部，并将与该部一起创建和销毁。另一方面，教师将通过聚合添加到部门，并独立创建/销毁。虽然聚合可能非常有用，但它们也可能更危险，因为聚合不处理其部分的释放。解除分配由外部方执行。如果外部方不再具有指向被放弃部分的指针或引用，或者如果它只是忘记执行清理（假设类将处理该操作），则内存将泄漏。因此，组合应优于聚合。一些警告/Errata由于各种历史和上下文原因，与合成不同，聚合的定义并不精确——因此您可能会看到其他参考资料对它的定义与我们的定义不同。这很好，只是需要注意。最后一个注意事项：在第13.7课——结构、成员和成员选择简介中，我们将聚合数据类型（如结构和类）定义为将多个变量分组在一起的数据类型。您还可以在C++旅程中遇到术语聚合类，它被定义为没有提供的构造函数、析构函数或重载赋值的结构或类，具有所有公共成员，并且不使用继承——本质上是一个普通的旧数据结构。尽管命名相似，但聚合和聚合是不同的，不应混淆。std:：reference_wrapper在上面的部门/教师示例中，我们使用部门中的引用来存储教师。如果只有一个教师，这很好，但如果一个系有多个教师怎么办？我们希望将这些教师存储在某种类型的列表中（例如，std:：vector），但固定数组和各种标准库列表不能保存引用（因为列表元素必须是可赋值的，并且不能重新分配引用）。std：：vector<const Teacher&>m_tachers{}；//非法我们可以使用指针而不是引用，但这将打开存储或传递空指针的可能性。在部门/教师示例中，我们不希望允许空指针。为了解决这个问题，有std:：reference_wrapper。从本质上讲，std:：reference_wrapper是一个类似于引用的类，但也允许赋值和复制，因此它与std：：vector等列表兼容。好消息是，使用它并不需要真正了解它是如何工作的。您只需要知道三件事：std:：reference_wrapper位于<functional>头中。当您创建std:：reference_wrapper包装对象时，该对象不能是匿名对象（因为匿名对象具有表达式范围，这将使引用悬而未决）。当您希望将对象从std:：reference_wrapper中取回时，可以使用get（）成员函数。下面是一个在std:：vector:#include<functional>//std::reference_wrapper#incl包括<iostream>#incluse<vector>#in包括<string>intmain（）{std:∶string tom{“tom”}中使用std:；标准：：字符串berta{“berta”}；标准：：矢量<std:：reference_wrapper<std::string>>名称{tom，berta}；//这些字符串是通过引用存储的，而不是值std:：stringjim{“jim”}；names.emplace_back（吉姆）；for（auto-name:names）{//使用get（）成员函数获取引用的字符串。name.get（）+=“Beam”；}std:：cout<<jim<<'\n'；//打印Jim Beam返回0；}要创建const引用的向量，我们必须像so//一样在std:：string之前添加const//对std:∶string std::vector<std:；测验时间问题#1您是否更可能将以下内容实现为组合或聚合？a） 有颜色的球b）雇用多人的雇主c）大学里的部门yd）你的年龄e）一袋大理石如何解决a）组成：颜色是球的固有属性。b）聚合：雇主不会从任何员工开始，希望在破产时不会毁灭其所有员工。c）组成：部门不能在没有大学的情况下存在。d）组成：你的年龄是你的固有特性。e）聚合：包和里面的大理石有独立的存在。问题#2更新部门/教师示例，以便部门可以处理多个教师。应执行以下代码：#include<iostream>//。。。int main（）{//在部门教师t1{“Bob”}的范围之外创建教师；教师t2{“Frank”}；教师t3{“Beth”}；{//创建一个部门并将一些教师添加到it部门{}；//创建一个空的部门。add（t1）；部门.增加（t2）；部门.添加（t3）；标准：：cout<<部门；}//部门在此处超出范围并被销毁std:：cout<<t1.getName（）<<“仍然存在！\n”；std:：cout<<t2.getName（）<<“仍然存在！\n”；std:：cout<<t3.getName（）<<“仍然存在！\n”；返回0；}这应该打印：部门：Bob Frank Beth Bob仍然存在！弗兰克仍然存在！贝丝还活着！Show HintHint提示：将教师存储在std:：vectorsd:：vector<std::reference_wrapper<const Teacher>>m_tachers{}中；显示解决方案#include<functional>//std:：reference_wrapper#incluse<iostream>#incluce<string>#in包括<string_view>#inclass<vector>class教师{private:std::string m_name{}；公共：教师（std:：string_view名称）：m_name{name}{}常量std::string&getName（）常量{return m_name；}}；班级部门{private:std:：vector<std:：reference_wrapper<const Teacher>>m_tachers{}；public:Department（）=默认值；//通过常规引用传递。Department类的用户不应该关心//它是如何实现的。void add（const Teacher&Teacher）{m_tachers.emplace_back（Teacher）；}好友std:：ostream&operator<<（std::ostream＆out，const Department&Department）{out<<“部门：”；for（const auto&Teacher:Department.m_tachers）{out<<教师.get（）.getName（）<<''；}out<<<<'\n'；返回；}}；int main（）{//在部门教师t1{“Bob”}的范围之外创建教师；教师t2{“Frank”}；教师t3{“Beth”}；{//创建一个部门并将一些教师添加到it部门{}；//创建一个空的部门。add（t1）；部门.增加（t2）；部门.添加（t3）；标准：：cout<<部门；}//部门在此处超出范围并被销毁std:：cout<<t1.getName（）<<“仍然存在！\n”；std:：cout<<t2.getName（）<<“仍然存在！\n”；std:：cout<<t3.getName（）<<“仍然存在！\n”；返回0；}下一个lesson23.4关联返回目录上一个leson23.2组合

