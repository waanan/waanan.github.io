---
title: "std:：数组和枚举"
date: 2024-08-13T13:06:02+08:00
---

在第16.9课——使用枚举器的数组索引和长度中，我们讨论了数组和枚举。

既然在我们的工具包中已经有了constexpr-std:：array，我们将继续讨论并展示一些额外的技巧。

***
## 使用静态断言确保适当数量的数组初始值设定项

当使用CTAD初始化constexpr std:：数组时，编译器将根据初始值设定项的数量推断数组的长度。如果提供的初始值设定项少于应有的数量，则数组将比预期的短，并且索引它可能导致未定义的行为。

例如：

```C++
#include <array>
#include <iostream>

enum StudentNames
{
    kenny, // 0
    kyle, // 1
    stan, // 2
    butters, // 3
    cartman, // 4
    max_students // 5
};

int main()
{
    constexpr std::array testScores { 78, 94, 66, 77 }; // oops, only 4 values

    std::cout << "Cartman got a score of " << testScores[StudentNames::cartman] << '\n'; // undefined behavior due to invalid index

    return 0;
}
```

每当可以合理地检查constexpr std:：数组中的初始值设定项数量时，您可以使用静态断言执行此操作：

```C++
#include <array>
#include <iostream>

enum StudentNames
{
    kenny, // 0
    kyle, // 1
    stan, // 2
    butters, // 3
    cartman, // 4
    max_students // 5
};

int main()
{
    constexpr std::array testScores { 78, 94, 66, 77 };

    // Ensure the number of test scores is the same as the number of students
    static_assert(std::size(testScores) == max_students); // compile error: static_assert condition failed

    std::cout << "Cartman got a score of " << testScores[StudentNames::cartman] << '\n';

    return 0;
}
```

这样，如果稍后添加新的枚举器，但忘记向testScores添加相应的初始值设定项，则程序将无法编译。

您还可以使用静态断言来确保两个不同的constexpr std:：数组具有相同的长度。

***
## 使用constexpr数组实现更好的枚举输入和输出

在第13.5课——I/O操作符重载简介中，我们介绍了输入和输出枚举器名称的几种方法。为了帮助完成这项任务，我们有了将枚举数转换为字符串的助手函数，反之亦然。这些函数都有自己（重复）的字符串文本集，我们必须专门编码逻辑来检查每个函数：

```C++
constexpr std::string_view getPetName(Pet pet)
{
    switch (pet)
    {
    case cat:   return "cat";
    case dog:   return "dog";
    case pig:   return "pig";
    case whale: return "whale";
    default:    return "???";
    }
}

constexpr std::optional<Pet> getPetFromString(std::string_view sv)
{
    if (sv == "cat")   return cat;
    if (sv == "dog")   return dog;
    if (sv == "pig")   return pig;
    if (sv == "whale") return whale;

    return {};
}
```

这意味着如果我们要添加新的枚举器，我们必须记住更新这些函数。

让我们稍微改进一下这些函数。在枚举器的值从0开始并按顺序继续的情况下（这对于大多数枚举都是正确的），我们可以使用数组来保存每个枚举器的名称。

这允许我们做两件事：

```C++
#include <array>
#include <iostream>
#include <string>
#include <string_view>

namespace Color
{
    enum Type
    {
        black,
        red,
        blue,
        max_colors
    };

    // use sv suffix so std::array will infer type as std::string_view
    using namespace std::string_view_literals; // for sv suffix
    constexpr std::array colorName { "black"sv, "red"sv, "blue"sv };

    // Make sure we've defined strings for all our colors
    static_assert(std::size(colorName) == max_colors);
};

constexpr std::string_view getColorName(Color::Type color)
{
    // We can index the array using the enumerator to get the name of the enumerator
    return Color::colorName[color];
}

// Teach operator<< how to print a Color
// std::ostream is the type of std::cout
// The return type and parameter type are references (to prevent copies from being made)!
std::ostream& operator<<(std::ostream& out, Color::Type color)
{
    return out << getColorName(color);
}

// Teach operator>> how to input a Color by name
// We pass color by non-const reference so we can have the function modify its value
std::istream& operator>> (std::istream& in, Color::Type& color)
{
    std::string input {};
    std::getline(in >> std::ws, input);

    // Iterate through the list of names to see if we can find a matching name
    for (std::size_t index=0; index < Color::colorName.size(); ++index)
    {
        if (input == Color::colorName[index])
        {
            // If we found a matching name, we can get the enumerator value based on its index
            color = static_cast<Color::Type>(index);
            return in;
        }
    }

    // We didn't find a match, so input must have been invalid
    // so we will set input stream to fail state
    in.setstate(std::ios_base::failbit);

    // On an extraction failure, operator>> zero-initializes fundamental types
    // Uncomment the following line to make this operator do the same thing
    // color = {};
    return in;
}

int main()
{
    auto shirt{ Color::blue };
    std::cout << "Your shirt is " << shirt << '\n';

    std::cout << "Enter a new color: ";
    std::cin >> shirt;
    if (!std::cin)
        std::cout << "Invalid\n";
    else
        std::cout << "Your shirt is now " << shirt << '\n';

    return 0;
}
```

这将打印：

***
## 循环和枚举的基于范围

有时，我们会遇到这样的情况，即迭代枚举的枚举器是有用的。虽然我们可以使用具有整数索引的for循环来实现这一点，但这可能需要将整数索引静态强制转换为枚举类型。

```C++
#include <array>
#include <iostream>
#include <string_view>

namespace Color
{
    enum Type
    {
        black,
        red,
        blue,
        max_colors
    };

    // use sv suffix so std::array will infer type as std::string_view
    using namespace std::string_view_literals; // for sv suffix
    constexpr std::array colorName { "black"sv, "red"sv, "blue"sv };

    // Make sure we've defined strings for all our colors
    static_assert(std::size(colorName) == max_colors);
};

constexpr std::string_view getColorName(Color::Type color)
{
    return Color::colorName[color];
}

// Teach operator<< how to print a Color
// std::ostream is the type of std::cout
// The return type and parameter type are references (to prevent copies from being made)!
std::ostream& operator<<(std::ostream& out, Color::Type color)
{
    return out << getColorName(color);
}

int main()
{
    // Use a for loop to iterate through all our colors
    for (int i=0; i < Color::max_colors; ++i )
        std::cout << static_cast<Color::Type>(i) << '\n';

    return 0;
}
```

不幸的是，基于范围的for循环不允许迭代枚举的枚举器：

```C++
#include <array>
#include <iostream>
#include <string_view>

namespace Color
{
    enum Type
    {
        black,
        red,
        blue,
        max_colors
    };

    // use sv suffix so std::array will infer type as std::string_view
    using namespace std::string_view_literals; // for sv suffix
    constexpr std::array colorName { "black"sv, "red"sv, "blue"sv };

    // Make sure we've defined strings for all our colors
    static_assert(std::size(colorName) == max_colors);
};

constexpr std::string_view getColorName(Color::Type color)
{
    return Color::colorName[color];
}

// Teach operator<< how to print a Color
// std::ostream is the type of std::cout
// The return type and parameter type are references (to prevent copies from being made)!
std::ostream& operator<<(std::ostream& out, Color::Type color)
{
    return out << getColorName(color);
}

int main()
{
    for (auto c: Color::Type) // compile error: can't traverse enumeration
        std::cout << c < '\n';

    return 0;
}
```

有许多创造性的解决方案。由于我们可以在数组上使用基于范围的for循环，因此最简单的解决方案之一是创建一个包含每个枚举器的constexpr std:：数组，然后对其进行迭代。此方法仅在枚举器具有唯一值时有效。

```C++
#include <array>
#include <iostream>
#include <string_view>

namespace Color
{
    enum Type
    {
        black,     // 0
        red,       // 1
        blue,      // 2
        max_colors // 3
    };

    using namespace std::string_view_literals; // for sv suffix
    constexpr std::array colorName { "black"sv, "red"sv, "blue"sv };
    static_assert(std::size(colorName) == max_colors);

    constexpr std::array types { black, red, blue }; // A std::array containing all our enumerators
    static_assert(std::size(types) == max_colors);
};

constexpr std::string_view getColorName(Color::Type color)
{
    return Color::colorName[color];
}

// Teach operator<< how to print a Color
// std::ostream is the type of std::cout
// The return type and parameter type are references (to prevent copies from being made)!
std::ostream& operator<<(std::ostream& out, Color::Type color)
{
    return out << getColorName(color);
}

int main()
{
    for (auto c: Color::types) // ok: we can do a range-based for on a std::array
        std::cout << c << '\n';

    return 0;
}
```

在上面的示例中，由于Color:：types的元素类型是Color:∶type，因此变量c将被推导为Color::type，这正是我们想要的！

这将打印：

***
## 测验时间

定义名为Animal的命名空间。在它内部，定义一个包含以下动物的枚举：鸡、狗、猫、大象、鸭子和蛇。还创建一个名为Data的结构来存储每个动物的名称、腿的数量和它发出的声音。创建一个std:：Data数组，并为每个动物填写一个Data元素。

请用户输入动物的名称。如果名称与我们的一只动物的名称不匹配，请告诉他们。否则，打印该动物的数据。然后打印与输入不匹配的所有其他动物的数据。

例如：

问题#1

显示解决方案

