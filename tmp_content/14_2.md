---
title: "无范围枚举输入和输出"
date: 2024-03-08T13:20:57+08:00
---

在上一课（13.2——无范围枚举）中，我们提到枚举器是符号常量。我们没有告诉你们的是，枚举数是积分符号常量。因此，枚举类型实际上持有整数值。

这类似于使用字符的情况（4.11——字符）。考虑：

```C++
char ch { 'A' };
```

字符实际上只是一个1字节的整数值，字符“A”被转换为整数值（在本例中为65）并存储。

定义枚举器时，每个枚举器都会根据其在枚举器列表中的位置自动分配一个整数值。默认情况下，为第一个枚举器分配整数值0，并且每个后续枚举器的值都比前一个枚举器大一：

```C++
enum Color
{
    black, // assigned 0
    red, // assigned 1
    blue, // assigned 2
    green, // assigned 3
    white, // assigned 4
    cyan, // assigned 5
    yellow, // assigned 6
    magenta, // assigned 7
};

int main()
{
    Color shirt{ blue }; // This actually stores the integral value 2

    return 0;
}
```

可以显式定义枚举器的值。这些整数值可以是正值或负值，并且可以与其他枚举器共享相同的值。任何未定义的枚举器都被赋予比前一个枚举器大一的值。

```C++
enum Animal
{
    cat = -3,
    dog,         // assigned -2
    pig,         // assigned -1
    horse = 5,
    giraffe = 5, // shares same value as horse
    chicken,      // assigned 6 
};
```

注意，在这种情况下，马和长颈鹿被赋予了相同的值。当这种情况发生时，枚举器变得不明显——本质上，马和长颈鹿是可以互换的。尽管C++允许，但通常应避免将相同的值分配给同一枚举中的两个枚举器。

{{< alert success >}}
**最佳做法**

避免将显式值分配给枚举器，除非您有令人信服的理由这样做。

{{< /alert >}}

***
## 无范围枚举将隐式转换为整数值

考虑以下程序：

```C++
#include <iostream>

enum Color
{
    black, // assigned 0
    red, // assigned 1
    blue, // assigned 2
    green, // assigned 3
    white, // assigned 4
    cyan, // assigned 5
    yellow, // assigned 6
    magenta, // assigned 7
};

int main()
{
    Color shirt{ blue };

    std::cout << "Your shirt is " << shirt << '\n'; // what does this do?

    return 0;
}
```

由于枚举类型保存整数值，因此正如您所期望的那样，这会打印：

在函数调用中或与运算符一起使用枚举类型时，编译器将首先尝试查找与枚举类型匹配的函数或运算符。例如，当编译器尝试编译std:：cout<<shirt时，编译器将首先查看操作符<<是否知道如何将Color类型的对象（因为shirt的类型是Color）打印到std::cout。它没有。

如果编译器找不到匹配项，则编译器将隐式地将未限定范围的枚举或枚举器转换为其相应的整数值。因为std:：cout确实知道如何打印整数值，所以shirt中的值被转换为整数并打印为整数值2。

***
## 打印枚举器名称

在大多数情况下，将枚举打印为整数值（如2）不是我们想要的。相反，我们通常希望打印枚举器表示的任何内容的名称（蓝色）。但要做到这一点，我们需要某种方法将枚举（2）的整数值转换为与枚举器名称（“blue”）匹配的字符串。

在C++20中，C++没有任何简单的方法来实现这一点，因此我们必须自己寻找解决方案。幸运的是，这并不困难。这样做的典型方法是编写一个函数，该函数将枚举类型作为参数，然后输出相应的字符串（或将字符串返回给调用方）。

这样做的典型方法是根据每个可能的枚举器测试我们的枚举：

```C++
// Using if-else for this is inefficient
void printColor(Color color)
{
    if (color == black) std::cout << "black";
    else if (color == red) std::cout << "red";
    else if (color == blue) std::cout << "blue";
    else std::cout << "???";
}
```

然而，为此使用一系列if-else语句是低效的，因为它需要在找到匹配之前进行多次比较。执行相同操作的更有效的方法是使用switch语句。在下面的示例中，我们还将Color作为std:：string返回，以使调用方能够更灵活地对名称执行任何操作（包括打印它）：

```C++
#include <iostream>
#include <string>

enum Color
{
    black,
    red,
    blue,
};


// We'll show a better version of this for C++17 below
std::string getColor(Color color)
{
    switch (color)
    {
    case black: return "black";
    case red:   return "red";
    case blue:  return "blue";
    default:    return "???";
    }
}

int main()
{
    Color shirt { blue };

    std::cout << "Your shirt is " << getColor(shirt) << '\n';

    return 0;
}
```

这将打印：

这可能比if-else链执行得更好（switch语句往往比if-else链更有效），并且也更容易阅读。然而，这个版本仍然效率低下，因为我们需要在每次调用函数时创建并返回std:：string（这很昂贵）。

在C++17中，一个更有效的选项是用std:：string_view替换std:：string。stringview允许我们以一种复制成本低得多的方式返回字符串文本。

```C++
#include <iostream>
#include <string_view> // C++17

enum Color
{
    black,
    red,
    blue,
};

constexpr std::string_view getColor(Color color) // C++17
{
    switch (color)
    {
    case black: return "black";
    case red:   return "red";
    case blue:  return "blue";
    default:    return "???";
    }
}

int main()
{
    constexpr Color shirt{ blue };

    std::cout << "Your shirt is " << getColor(shirt) << '\n';

    return 0;
}
```

{{< alert success >}}
**相关内容**

Constexpr返回类型在第5.8课——Constexpr&consteval函数中介绍。

{{< /alert >}}

***
## 设定运算符<<如何打印枚举数

尽管上面的示例运行良好，但我们仍然必须记住我们创建的函数的名称，以获得枚举器名称。虽然这通常不是太繁琐，但如果有许多枚举，则可能会变得更麻烦。使用操作符重载（类似于函数重载的功能），我们实际上可以教操作符<<如何打印程序定义枚举的值！我们还没有解释这是如何工作的，所以现在认为它有点神奇：

```C++
#include <iostream>

enum Color
{
	black,
	red,
	blue,
};

// Teach operator<< how to print a Color
// Consider this magic for now since we haven't explained any of the concepts it uses yet
// std::ostream is the type of std::cout
// The return type and parameter type are references (to prevent copies from being made)!
std::ostream& operator<<(std::ostream& out, Color color)
{
	switch (color)
	{
	case black: return out << "black";
	case red:   return out << "red";
	case blue:  return out << "blue";
	default:    return out << "???";
	}
}

int main()
{
	Color shirt{ blue };
	std::cout << "Your shirt is " << shirt << '\n'; // it works!

	return 0;
}
```

这将打印：

我们在第21.4课——重载I/O操作符中讨论了I/O操作符的重载。现在，您可以复制此代码并将Color替换为自己的枚举类型。

{{< alert success >}}
**对于高级读者**

出于好奇，下面是上面的代码实际在做什么。当我们尝试使用std:：cout和运算符<<打印衬衫时，编译器将看到我们重载了运算符<<来处理Color类型的对象。然后使用std:：cout作为out参数，使用衬衫作为参数颜色来调用该重载操作符<<函数。由于out是对std:：cout的引用，因此像out<<“blue”这样的语句实际上只是将“blue“打印到std:∶cout。

{{< /alert >}}

***
## 枚举大小和基础类型（基）

枚举的枚举数是整型常量。用于表示枚举数的特定整型称为基础类型（或基）。

对于非范围枚举器，C++标准没有指定应将哪个特定的整型用作基础类型。大多数编译器将使用类型int作为基础类型（这意味着未限定范围的枚举将与int大小相同），除非需要更大的类型来存储枚举器值。

可以指定不同的基础类型。例如，如果您在某些带宽敏感的环境中工作（例如，通过网络发送数据），则可能需要指定较小的类型：

```C++
#include <cstdint>  // for std::int8_t
#include <iostream>

// Use an 8-bit integer as the enum underlying type
enum Color : std::int8_t
{
    black,
    red,
    blue,
};

int main()
{
    Color c{ black };
    std::cout << sizeof(c) << '\n'; // prints 1 (byte)

    return 0;
}
```

{{< alert success >}}
**最佳做法**

仅在必要时指定枚举的基类型。

{{< /alert >}}

{{< alert success >}}
**警告**

由于std:：int8_t和std:：uint8_t通常是char类型的类型别名，因此使用这两种类型之一作为枚举基很可能会导致枚举器打印为char值，而不是int值。

{{< /alert >}}

***
## 整数到非范围枚举数转换

虽然编译器将隐式地将未范围枚举数转换为整数，但它不会隐式地把整数转换为未范围枚举器。以下操作将产生编译器错误：

```C++
enum Pet // no specified base
{
    cat, // assigned 0
    dog, // assigned 1
    pig, // assigned 2
    whale, // assigned 3
};

int main()
{
    Pet pet { 2 }; // compile error: integer value 2 won't implicitly convert to a Pet
    pet = 3;       // compile error: integer value 3 won't implicitly convert to a Pet

    return 0;
}
```

有两种方法可以解决这个问题。

首先，可以使用static_cast强制编译器将整数转换为非范围枚举器：

```C++
enum Pet // no specified base
{
    cat, // assigned 0
    dog, // assigned 1
    pig, // assigned 2
    whale, // assigned 3
};

int main()
{
    Pet pet { static_cast<Pet>(2) }; // convert integer 2 to a Pet
    pet = static_cast<Pet>(3);       // our pig evolved into a whale!

    return 0;
}
```

稍后我们将看到一个示例，其中这可能是有用的。

第二，在C++17中，如果非范围枚举具有指定的基址，则编译器将允许您使用整数值来列表初始化非范围枚举：

```C++
enum Pet: int // we've specified a base
{
    cat, // assigned 0
    dog, // assigned 1
    pig, // assigned 2
    whale, // assigned 3
};

int main()
{
    Pet pet1 { 2 }; // ok: can brace initialize with integer
    Pet pet2 (2);   // compile error: cannot direct initialize with integer
    Pet pet3 = 2;   // compile error: cannot copy initialize with integer

    pet1 = 3;       // compile error: cannot assign with integer

    return 0;
}
```

***
## 无范围枚举器输入

由于Pet是程序定义的类型，因此该语言不知道如何使用std:：cin输入Pet：

```C++
#include <iostream>

enum Pet
{
    cat, // assigned 0
    dog, // assigned 1
    pig, // assigned 2
    whale, // assigned 3
};

int main()
{
    Pet pet { pig };
    std::cin >> pet; // compile error, std::cin doesn't know how to input a Pet

    return 0;
}
```

为了解决这个问题，我们可以读取整数，并使用static_cast将该整数转换为适当枚举类型的枚举器：

```C++
#include <iostream>

enum Pet
{
    cat, // assigned 0
    dog, // assigned 1
    pig, // assigned 2
    whale, // assigned 3
};

int main()
{
    std::cout << "Enter a pet (0=cat, 1=dog, 2=pig, 3=whale): ";

    int input{};
    std::cin >> input; // input an integer

    Pet pet{ static_cast<Pet>(input) }; // static_cast our integer to a Pet

    return 0;
}
```

{{< alert success >}}
**对于高级读者**

类似于我们如何教操作符<<输出上面的枚举类型，我们还可以教操作符>>如何输入枚举类型：

```C++
#include <iostream>

enum Pet
{
    cat, // assigned 0
    dog, // assigned 1
    pig, // assigned 2
    whale, // assigned 3
};

// Consider this magic for now
// We pass pet by reference so we can have the function modify its value
std::istream& operator>> (std::istream& in, Pet& pet)
{
    int input{};
    in >> input; // input an integer

    pet = static_cast<Pet>(input);
    return in;
}

int main()
{
    std::cout << "Enter a pet (0=cat, 1=dog, 2=pig, 3=whale): ";

    Pet pet{};
    std::cin >> pet; // input our pet using std::cin

    std::cout << pet << '\n'; // prove that it worked

    return 0;
}
```

再一次，现在认为这有点神奇（因为我们还没有解释它背后的概念），但您可能会发现它很方便。

在第17.6课——std:：array和枚举中，我们展示了操作符>>的改进版本，它允许通过文本（而不是int）输入。

{{< /alert >}}

***
## 测验时间

问题#1

正确或错误。枚举器可以是：

1. 给定整数值


显示解决方案

1. 未给定显式值


显示解决方案

1. 给定浮点值


显示解决方案

1. 给定负值


显示解决方案

1. 给定非唯一值


显示解决方案

1. 用先前枚举器的值初始化（例如，品红色=红色）


显示解决方案

