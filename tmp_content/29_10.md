---
title: "第27章总结和测验"
date: 2025-02-12T14:07:59+08:00
---

章节回顾

异常处理提供了一种机制，可以将错误或其他异常情况的处理与代码的典型控制流解耦。这允许更自由地在对给定情况最有用的时间和方式处理错误，减轻了返回代码导致的许多（如果不是全部）混乱。

throw语句用于引发异常。Try块查找由在其中编写或调用的代码引发的异常。这些异常被路由到catch块，catch块捕获特定类型的异常（如果它们匹配）并处理它们。默认情况下，捕获的异常被视为已处理。

异常将立即处理。如果引发异常，控件将跳到最近的封闭try块，查找可以处理该异常的catch处理程序。如果找到匹配的try/catch，则堆栈将展开到catch块的点，并在匹配的catch的顶部恢复控制。如果找不到try块或没有匹配的catch块，程序将调用std:：terminate，这将以未处理的异常错误结束。

可以引发任何数据类型的异常，包括类。

Catch块可以配置为捕获特定数据类型的异常，或者可以使用省略号（…）设置Catch all处理程序。捕获基类引用的catch块也将捕获派生类的异常。标准库抛出的所有异常都派生自std:：exception类（位于异常标头中），因此通过引用捕获std:：except将捕获所有标准库异常。what（）成员函数可用于确定引发了哪种类型的std:：异常。

在catch块内部，可能会引发新的异常。因为这个新的异常被抛出与该catch块关联的try块之外，所以它不会被抛出的catch块捕获。通过使用关键字throw本身，可以从catch块重新抛出异常。不要使用捕获的异常变量重新引发异常，否则可能会导致对象切片。

函数try块为您提供了一种捕获函数或关联的成员初始化列表中发生的任何异常的方法。这些通常仅与派生类构造函数一起使用。

永远不要从析构函数中引发异常。

noexcept异常说明符可用于表示函数没有抛出/没有失败。

如果对象具有noexcept-move构造函数，则std:：move_ifnoexcept将返回可移动的r值，否则它将返回可复制的l值。我们可以将noexcept说明符与std:：move_if_noexcept结合使用，以仅在存在强异常保证时使用移动语义（否则使用复制语义）。

最后，异常处理确实有成本。在大多数情况下，使用异常的代码将运行得稍微慢一些，并且处理异常的成本非常高。您应该仅使用异常来处理异常情况，而不是用于正常的错误处理情况（例如，无效输入）。

章节测验

下面是程序的一次运行应该输出的内容：

显示解决方案

