---
title: "内联函数和变量"
date: 2023-11-28T13:19:42+08:00
---

考虑这样的情况，您需要编写一些代码来执行一些离散的任务，例如读取用户的输入，或将某些内容输出到文件，或计算特定的值。在实现此代码时，基本上有两个选项：

编写函数提供了许多潜在的好处，如函数中的代码：

1. 在整个程序的上下文中更容易阅读和理解。
2. 更易于使用，因为您可以在不了解其实现方式的情况下调用该函数。
3. 更容易更新，因为函数中的代码可以在一个位置更新。
4. 更易于重用，因为函数自然是模块化的。


然而，使用函数的一个缺点是，每次调用函数时，都会发生一定数量的性能开销。考虑以下示例：

```C++
#include <iostream>

int min(int x, int y)
{
    return (x < y) ? x : y;
}

int main()
{
    std::cout << min(5, 6) << '\n';
    std::cout << min(3, 2) << '\n';
    return 0;
}
```

当遇到对min（）的调用时，CPU必须存储它正在执行的当前指令的地址（以便它知道以后返回到哪里）以及各种CPU寄存器的值（以便它们可以在返回时恢复）。然后必须实例化参数x和y，然后进行初始化。然后，执行路径必须跳到min（）函数中的代码。当函数结束时，程序必须跳回到函数调用的位置，并且必须复制返回值，以便可以输出它。必须为每个函数调用执行此操作。

对于大型和/或执行复杂任务的函数，与函数运行所需的时间相比，函数调用的开销通常微不足道。然而，对于小函数（如上面的min（）），开销成本可能大于实际执行函数代码所需的时间！在经常调用小函数的情况下，使用函数可能会导致在适当的位置编写相同的代码，从而导致显著的性能损失。

***
## 内联式扩展

幸运的是，C++编译器有一个技巧可以用来避免这种开销：内联扩展是一个函数调用被被调用函数定义中的代码替换的过程。

例如，如果编译器在上例中展开了min（）调用，则生成的代码如下所示：

```C++
#include <iostream>

int main()
{
    std::cout << ((5 < 6) ? 5 : 6) << '\n';
    std::cout << ((3 < 2) ? 3 : 2) << '\n';
    return 0;
}
```

注意，对函数min（）的两个调用已被min（）函数体中的代码替换（用参数的值替换参数）。这允许我们避免这些调用的开销，同时保留代码的结果。

***
## 内联代码的性能

除了消除函数调用的开销外，内联扩展还允许编译器更有效地优化结果代码——例如，因为表达式（（5<6）？5:6）现在是常量表达式，编译器可以将main（）中的第一条语句进一步优化为std:：cout<<5<<'\n'；。

然而，内联扩展有自己的潜在成本：如果被扩展的函数体比被替换的函数调用需要更多的指令，则每个内联扩展都将导致可执行文件变大。较大的可执行文件往往速度较慢（由于不适合内存缓存）。

关于函数是否会从内联中受益的决定（因为删除函数调用开销超过了更大的可执行文件的成本）并不简单。根据函数调用的相对成本、函数的大小以及可以执行的其他优化，内联扩展可能会导致性能改进、性能降低或根本不改变性能。

内联扩展最适合于简单、简短的函数（例如，不超过几个语句），特别是单个函数调用可以执行多次的情况（例如，循环内的函数调用）。

***
## 发生内联扩展时

每个函数都分为两类之一，其中对函数的调用：

1. 可以扩展（大多数功能都在此类别中）。
2. 无法展开。


大多数函数都属于“可以”类别：如果这样做是有益的，则可以扩展它们的函数调用。对于这一类别中的函数，现代编译器将评估每个函数和每个函数调用，以确定该特定函数调用是否将受益于内联扩展。编译器可能决定将任何、部分或所有函数调用扩展到给定函数。

{{< alert success >}}
**提示**

现代优化编译器决定何时内联扩展函数。

{{< /alert >}}

***
## inline关键字，历史记录

从历史上看，编译器要么没有能力确定内联扩展是否有益，要么不擅长内联扩展。由于这个原因，C++提供了关键字inline，它最初旨在用作向编译器提示函数将（可能）从内联扩展中受益的提示。

使用inline关键字声明的函数称为inline函数。

下面是使用inline关键字的示例：

```C++
#include <iostream>

inline int min(int x, int y) // inline keyword means this function is an inline function
{
    return (x < y) ? x : y;
}

int main()
{
    std::cout << min(5, 6) << '\n';
    std::cout << min(3, 2) << '\n';
    return 0;
}
```

然而，在现代C++中，inline关键字不再用于请求内联扩展函数。这有许多原因：

1. 使用内联请求内联扩展是过早优化的一种形式，误用实际上可能会损害性能。
2. inline关键字只是一个提示——编译器完全可以忽略内联函数的请求。如果您试图内联一个冗长的函数，这很可能是结果！编译器还可以自由地对不使用inline关键字作为其正常优化集的一部分的函数执行内联扩展。
3. inline关键字在错误的粒度级别定义。我们在函数定义上使用inline关键字，但内联扩展实际上是根据函数调用确定的。扩展某些函数调用可能是有益的，而扩展其他函数调用可能有害，并且没有语法会影响这一点。


现代优化编译器通常善于确定哪些函数应该内联生成——在大多数情况下比人类更好。因此，编译器可能会忽略或降低对内联的任何使用，以请求函数的内联扩展。

{{< alert success >}}
**最佳做法**

不要使用inline关键字来请求函数的内联扩展。

{{< /alert >}}

***
## inline关键字，modernly

在前面的章节中，我们提到不应该在头文件中实现函数（具有外部链接），因为当这些头包含在多个.cpp文件中时，函数定义将被复制到多个.ccp文件中。然后将编译这些文件，链接器将抛出一个错误，因为它将注意到您多次定义了相同的函数，这违反了一个定义规则。

在现代C++中，术语inline已经演变为“允许多个定义”。因此，内联函数是允许在多个文件中定义的函数。C++17引入了内联变量，这些变量允许在多个文件中定义。

内联函数和变量有两个主要要求：

1. 编译器需要能够在使用函数的每个转换单元中看到内联函数或变量的完整定义（前向声明本身并不足够）。如果还提供了转发声明，则定义可以发生在使用点之后。
2. 内联函数或变量的每个定义都必须相同，否则将导致未定义的行为。


链接器将把标识符的所有内联函数或内联变量定义合并到单个定义中（因此仍然满足一个定义规则的要求）。

内联函数和变量通常在头文件中定义，其中它们可以#包含在需要查看标识符的完整定义的任何代码文件的顶部。这确保标识符的所有内联定义都是相同的。

这对于仅标头库特别有用，这是一个或多个实现某些功能的标头文件（不包括.cpp文件）。仅标头库很受欢迎，因为没有需要添加到项目中才能使用的源文件，也没有需要链接的源文件。您只需#包含仅标头库，然后就可以使用它。

在大多数情况下，您不应该将函数或变量标记为内联，除非您在头文件中定义它们（并且它们尚未隐式内联）。

{{< alert success >}}
**相关内容**

我们在第7.9课中演示了内联变量的常见用法——在多个文件中共享全局常量（使用内联变量）。

{{< /alert >}}

{{< alert success >}}
**规则**

编译器需要能够看到内联函数或变量的完整定义，无论它在何处使用，并且所有这样的定义都必须相同（否则将导致未定义的行为）。

{{< /alert >}}

{{< alert success >}}
**对于高级读者**

以下是隐式内联的：

1. 在类、结构或联合类型定义内定义的函数（14.3——成员函数）。
2. Constexpr/consteval函数（5.8——Constexpr和consteval函数）。
3. 从函数模板隐式实例化的函数（10.16——函数模板实例化）。
4. Constexpr静态变量（但不是Constexpr非静态变量）。


{{< /alert >}}

{{< alert success >}}
**最佳做法**

避免使用inline关键字，除非您有特定的、令人信服的理由这样做（例如，您正在头文件中定义那些函数或变量）。

{{< /alert >}}

