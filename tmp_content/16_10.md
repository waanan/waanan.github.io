---
title: "第15章总结和测验"
date: 2024-06-24T18:56:16+08:00
---

***
## 章节回顾

在每个（非静态）成员函数内部，关键字this是保存当前隐式对象地址的常量指针。我们可以让函数通过引用返回*this，以启用方法链接，其中可以在单个表达式中的同一对象上调用多个成员函数。

更喜欢将类定义放在与类同名的头文件中。琐碎的成员函数（例如访问函数、具有空实体的构造函数等）可以在类定义中定义。

首选在与类同名的源文件中定义非平凡的成员函数。

在类类型内定义的类型称为嵌套类型（或成员类型）。类型别名也可以嵌套。

在类模板定义内定义的成员函数可以使用类模板本身的模板参数。在类模板定义之外定义的成员函数必须重新提供模板参数声明，并且应该（在同一个文件中）在类模板界定的正下方定义。

静态成员变量是由类的所有对象共享的静态持续时间成员。即使没有实例化类的对象，也存在静态成员。首选使用类名、范围解析操作符和成员名称访问它们。

使静态成员内联允许在类定义中初始化它们。

静态成员函数是可以在没有对象的情况下调用的成员函数。它们没有*this指针，并且不能访问非静态数据成员。

在类的主体中，可以使用友元声明（使用friend关键字）来告诉编译器，其他一些类或函数现在是友元。友元是被授予对另一个类的私有成员和受保护成员的完全访问权限的类或函数（成员或非成员）。友元函数是一个函数（成员或非成员），可以访问类的私有成员和受保护成员，就像它是该类的成员一样。友元类是可以访问另一个类的私有成员和受保护成员的类。

***
## 测验时间

问题#1

让我们创建一个随机怪物生成器。这个应该很有趣。

a） 首先，让我们创建一个名为MonsterType的怪物类型的范围枚举。包括以下怪物类型：龙、地精、食人魔、兽人、骷髅、巨魔、吸血鬼和僵尸。添加额外的maxMonsterTypes枚举器，以便我们可以计算有多少个枚举器。

显示解决方案

b） 现在，让我们创建我们的怪物类。我们的怪物将有4个属性（成员变量）：类型（MonsterType）、名称（std:：string）、咆哮（std::string）和生命点数（int）。

显示解决方案

c） 枚举类MonsterType特定于Monster，因此请在Monster中使MonsterType成为嵌套的未范围枚举，并将其重命名为Type。

显示解决方案

d） 创建允许您初始化所有成员变量的构造函数。

应编译以下程序：

```C++
int main()
{
	Monster skeleton{ Monster::skeleton, "Bones", "*rattle*", 4 };

	return 0;
}
```

显示解决方案

e） 现在，我们希望能够打印我们的怪物，以便验证它的正确性。编写两个函数：一个名为getTypeString（），它将怪物的类型返回为字符串，另一个称为print（），与下面示例程序中的输出相匹配。

应编译以下程序：

```C++
int main()
{
	Monster skeleton{ Monster::skeleton, "Bones", "*rattle*", 4 };
	skeleton.print();

	Monster vampire{ Monster::vampire, "Nibblez", "*hiss*", 0 };
	vampire.print();

	return 0;
}
```

并打印：

显示解决方案

f） 现在我们可以创建一个随机怪物生成器。让我们考虑一下我们的MonsterGenerator将如何工作。理想情况下，我们将要求它为我们提供一个Monster，它将为我们创建一个随机的Monster。因为MonsterGenerator没有任何状态，这是名称空间的一个很好的候选。

创建MonsterGenerator命名空间。在命名的generate（）中创建函数。这应该会返回一个怪物。现在，让它返回怪物{怪物：：骷髅，“骨头”，“响尾蛇*”，4}；

应编译以下程序：

```C++
int main()
{
	Monster m{ MonsterGenerator::generate() };
	m.print();

	return 0;
}
```

并打印：

显示解决方案

g） 向MonsterGenerator命名空间添加另外两个函数。getName（int）将接受0到5（包括0和5）之间的数字，并返回您选择的名称。getRoar（int）还将获取0到5（包括0和5）之间的数字，并返回您选择的咆哮声。还要更新generate（）函数以调用getName（0）和getRoar（0）。

应编译以下程序：

```C++
int main()
{
	Monster m{ MonsterGenerator::generate() };
	m.print();

	return 0;
}
```

并打印：

您的姓名和声音将因您选择的内容而异。

显示解决方案

h） 现在，我们将随机化我们生成的怪物。从8.15中抓取“Random.h”代码——全局随机数（Random.h），并将其保存为Random.h.然后使用Random:：get（）生成随机怪物类型、随机名称、随机咆哮和随机生命值（介于1和100之间）。

应编译以下程序：

```C++
#include "Random.h"

int main()
{
	Monster m{ MonsterGenerator::generate() };
	m.print();

	return 0;
}
```

并打印如下内容：

显示解决方案

