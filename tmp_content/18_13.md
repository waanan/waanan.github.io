---
title: "第17章总结和测验"
date: 2024-08-13T13:06:02+08:00
---

***
## 章节回顾

固定大小的数组（或固定长度的数组）要求在实例化时知道数组的长度，并且该长度不能在以后更改。C样式数组和std:：array都是固定大小的数组。动态数组可以在运行时调整大小。vector是一个动态数组。

std:：数组的长度必须是常量表达式。通常，为长度提供的值将是整型文字、constexpr变量或非范围枚举器。

std:：array是聚合。这意味着它没有构造函数，而是使用聚合初始化进行初始化。

尽可能将std:：array定义为constexpr。如果您的std:：array不是constexpr，请考虑改用std:：vector。

使用类模板参数演绎（CTAD）让编译器从其初始值设定项推断std:：数组的类型和长度。

std:：array实现为模板结构，其声明如下：

```C++
template<typename T, std::size_t N> // N is a non-type template parameter
struct array;
```

表示数组长度（N）的非类型模板参数的类型为std:：size_t。

要获取std:：数组的长度，请执行以下操作：

1. 我们可以使用size（）成员函数询问std:：array对象的长度（该函数将长度返回为无符号size_type）。
2. 在C++17中，我们可以使用std:：size（）非成员函数（对于std:∶array，该函数仅调用size（.）成员函数，从而将长度返回为无符号size_type）。
3. 在C++20中，我们可以使用std:：ssize（）非成员函数，该函数将长度返回为一个大的有符号整数类型（通常为std:：ptrdiff_t）。


这三个函数都将以constexpr值的形式返回长度，除非在通过引用传递的std:：数组上调用。P2280在C++23中解决了此缺陷。

要索引std:：数组，请执行以下操作：

1. 使用下标运算符（运算符[]）。在这种情况下不进行边界检查，传入无效索引将导致未定义的行为。
2. 使用at（）成员函数，该函数通过运行时边界检查进行订阅。我们建议避免使用此函数，因为我们通常希望在索引之前进行边界检查，或者希望进行编译时边界检查。
3. 使用std:：get（）函数模板，它将索引作为非类型模板参数，并执行编译时边界检查。


可以使用具有模板参数声明模板的函数模板将具有不同元素类型和长度的std:：array传递给函数。或者在C++20中，使用模板<typename T，auto N>。

按值返回std:：array将制作数组和所有元素的副本，但如果数组很小，并且元素的复制成本不高，则这可能没问题。在某些情况下，改用out参数可能是更好的选择。

当使用结构、类或数组初始化std:：数组，并且不为每个初始值设定项提供元素类型时，您将需要一对额外的大括号，以便编译器正确解释要初始化的内容。这是聚合初始化的工件，在这些情况下，其他标准库容器类型（使用列表构造函数）不需要双大括号。

C++中的聚合支持一个名为大括号省略的概念，该概念为何时可以省略多个大括号制定了一些规则。通常，在使用标量（单个）值初始化std:：数组时，或者在使用类类型或数组进行初始化时，可以省略大括号，其中类型是用每个元素显式命名的。

不能有引用数组，但可以有std:：reference_wrapper数组，其行为类似于可修改的左值引用。

关于std:：reference_wrapper，有几点值得注意：

1. Operator=将重置std:：reference_wrapper（更改正在引用的对象）。
2. std:：reference_wrapper<T>将隐式转换为T&。
3. get（）成员函数可用于获取T&。当我们想要更新被引用对象的值时，这很有用。


提供了std:：ref（）和std:：cref（）函数作为快捷方式来创建std::reference_wrapper和const std:∶reference_ wrapper包装的对象。

尽可能使用static_assert来确保使用CTAD的constexpr std:：数组具有正确数量的初始值设定项。

C风格的数组继承自C语言，并内置于C++的核心语言中。由于C样式数组是核心语言的一部分，因此它们有自己的特殊声明语法。在C样式数组声明中，我们使用方括号（[]）来告诉编译器声明的对象是C样式数组。在方括号内，我们可以选择提供数组的长度，这是类型为std:：size_t的整数值，它告诉编译器数组中有多少个元素。C样式数组的长度必须是常量表达式。

C样式数组是聚合，这意味着可以使用聚合初始化来初始化它们。当使用初始值设定项列表来初始化C样式数组的所有元素时，最好省略长度，并让编译器计算数组的长度。

C型阵列可以通过运算符[]进行索引。C样式数组的索引可以是有符号或无符号整数，也可以是无范围枚举。这意味着C样式数组不会受到标准库容器类所具有的所有符号转换索引问题的影响！

C样式数组可以是const或constexpr。

要获取C样式数组的长度，请执行以下操作：

1. 在C++17中，我们可以使用std:：size（）非成员函数，该函数将长度返回为无符号的std:：size_t。
2. 在C++20中，我们可以使用std:：ssize（）非成员函数，该函数将长度返回为一个大的有符号整数类型（通常为std:：ptrdiff_t）。


在大多数情况下，当在表达式中使用C样式数组时，数组将隐式转换为指向元素类型的指针，并用第一个元素的地址（索引为0）初始化。通俗地说，这称为阵列衰减（或简称为衰减）。

指针算术是一种功能，它允许我们将某些整数算术运算符（加法、减法、增量或减法）应用于指针，以产生新的内存地址。给定某个指针ptr，ptr+1返回内存中下一个对象的地址（基于所指向的类型）。

从数组（元素0）的开头进行索引时使用下标，以便数组索引与元素对齐。在从给定元素进行相对定位时使用指针算法。

C样式字符串只是C样式数组，其元素类型为char或constchar。因此，C样式字符串将衰减。

数组的维数是选择元素所需的索引数。

仅包含一维的数组称为一维数组或一维数组（有时缩写为一维数组）。数组数组被称为二维数组（有时缩写为2d数组），因为它有两个下标。具有多个维度的数组称为多维数组。展平阵列是降低阵列维数的过程（通常降到单个维数）。

在C++23中，std:：mdspan是一个视图，为连续的元素序列提供多维数组接口。

***
## 测验时间

问题#1

这些片段中的每一个都有什么问题，您将如何修复它？

a）

```C++
#include <array>
#include <iostream>

int main()
{
    std::array arr { 0, 1, 2, 3 };

    for (std::size_t count{ 0 }; count <= std::size(arr); ++count)
    {
        std::cout << arr[count] << ' ';
    }

    std::cout << '\n';

    return 0;
}
```

显示解决方案

b）

```C++
#include <iostream>

void printArray(int array[])
{
    for (int element : array)
    {
        std::cout << element << ' ';
    }
}

int main()
{
    int array[] { 9, 7, 5, 3, 1 };

    printArray(array);

    std::cout << '\n';

    return 0;
}
```

显示解决方案

c）

```C++
#include <array>
#include <iostream>

int main()
{
    std::cout << "Enter the number of test scores: ";
    std::size_t length{};
    std::cin >> length;

    std::array<int, length> scores;

    for (std::size_t i { 0 } ; i < length; ++i)
    {
        std::cout << "Enter score " << i << ": ";
        std::cin >> scores[i];
    }
    return 0;
}
```

显示解决方案

问题#2

在这次测验中，我们将实现罗斯科的药水商店，这是全国最好的药水店！这将是一个更大的挑战。

实现输出以下内容的程序：

玩家从随机数量的黄金开始，在80到120之间。

听起来很有趣吗？让我们开始吧！因为这很难一次性实现，所以我们将分步骤开发它。

>步骤#1

创建一个药水命名空间，其中包含一个名为Type的枚举，该枚举包含药水类型。创建两个std:：array：一个int数组保存药剂成本，一个std::string_view数组保存药剂名称。

还要编写一个名为shop（）的函数，该函数枚举所有魔药列表，并打印它们的编号、名称和成本。

程序应输出以下内容：

显示提示

显示解决方案

>步骤#2

创建一个玩家类来存储玩家的名字、药剂清单和黄金。添加罗斯科商场的介绍和告别文本。获得玩家的名字，并随机化他们的黄金。

使用第8.15课“全局随机数”（Random.h）中的“Random.h”文件来简化随机化。

程序应输出以下内容：

显示解决方案

>步骤#3

添加购买药剂的能力，处理无效输入（将任何无关输入视为失败）。在玩家离开后打印他们的库存。该程序应在此步骤后完成。

确保测试以下情况：

1. 用户输入了无效的药水编号（例如“d”）
2. 用户输入有效的药水编号，但输入无关（例如2d、25）


我们在第9.5课中讨论了无效输入处理——std:：cin和处理无效输入。

显示提示

显示提示

显示解决方案

问题#3

假设我们想编写一个使用标准牌组的纸牌游戏。为了做到这一点，我们需要某种方法来表示这些卡片，以及一副副卡片。让我们构建该功能。

我们将在下一个测试问题中使用它来实际实现游戏。

>步骤#1

一副牌有52张独特的牌（4套牌的13个牌列）。为卡牌等级（王牌、2、3、4、5、6、7、8、9、10、杰克、皇后、国王）和套牌（梅花、钻石、红桃、黑桃）创建枚举。

显示解决方案

>步骤#2

每个卡将由一个名为card的结构表示，该结构包含一个等级和一个套装成员。创建结构并将枚举移到其中。

显示解决方案

>步骤#3

接下来，让我们为Card结构添加一些有用的函数。首先，重载操作符<<以打印卡排名和适合的2个字母的代码（例如，黑桃插孔将打印为JS）。您可以通过完成以下功能来完成此操作：

```C++
struct Card
{
    // Your other stuff here

    friend std::ostream& operator<<(std::ostream& out, const Card &card)
    {
        out << // print your card rank and suit here
        return out;
    }
};
```

其次，添加一个返回卡的值的函数。将ace视为值11。最后，添加Rank和ofSuit的std:：数组（分别命名为allRanks和allSuits），以便可以迭代它们。因为它们是结构（而不是命名空间）的一部分，所以将它们设置为静态的，以便它们只实例化一次（而不是与每个对象一起实例化）。

应编译以下内容：

```C++
int main()
{
    // Print one card
    Card card { Card::rank_5, Card::suit_heart };
    std::cout << card << '\n';

    // Print all cards
    for (auto suit : Card::allSuits)
        for (auto rank : Card::allRanks)
            std::cout << Card { rank, suit } << ' ';
    std::cout << '\n';

    return 0;
}
```

并产生以下输出：

显示解决方案

>步骤#4

接下来，让我们创建一副牌。创建一个名为Deck的类，该类包含卡的std:：数组。你可以假设一副牌是52张牌。

甲板应具有三个功能：

首先，默认构造函数应该初始化卡的数组。您可以使用类似于上例main（）函数中的ranged for循环来遍历所有套装和等级。

其次，添加dealCard（）函数，该函数按值返回Deck中的下一张牌。由于std:：array是一个固定大小的数组，请考虑如何跟踪下一张卡的位置。如果在Deck遍历所有卡时调用该函数，则应该断言出来。

第三，编写一个shuffle（）成员函数来洗牌组。为了简化这一过程，我们将获得std:：shuffle:的帮助

```C++
#include <algorithm> // for std::shuffle
#include "Random.h"  // for Random::mt

    // Put this line in your shuffle function to shuffle m_cards using the Random::mt Mersenne Twister
    // This will rearrange all the Cards in the deck randomly
    std::shuffle(m_cards.begin(), m_cards.end(), Random::mt);
```

shuffle（）函数也应该重置，但您要跟踪下一张牌回到牌组开始的位置。

应运行以下程序：

```C++
int main()
{
    Deck deck{};
    std::cout << deck.dealCard() << ' ' << deck.dealCard() << ' ' << deck.dealCard() << '\n';

    deck.shuffle();
    std::cout << deck.dealCard() << ' ' << deck.dealCard() << ' ' << deck.dealCard() << '\n';

    return 0;
}
```

并产生以下输出（最后3张卡应随机）：

显示解决方案

问题#4

好的，现在让我们使用我们的卡和甲板来实现Blackjack的简化版本！如果你还不熟悉21点，维基百科上关于21点的文章有一个摘要。

以下是我们版本的21点游戏的规则：

1. 经销商获得一张卡开始（在现实生活中，经销商获得两张，但一张面朝下，因此在这一点上并不重要）。
2. 玩家得到两张牌开始。
3. 球员先走。
4. 玩家可以反复“命中”或“站立”。
5. 如果玩家“站”起来，他们的回合结束，他们的分数是根据他们被发的牌来计算的。
6. 如果玩家“命中”，他们将获得另一张牌，并且该牌的值将添加到他们的总分中。
7. a通常计为1或11（总得分以更好的为准）。为了简单起见，这里我们将其计为11。
8. 如果球员得分超过21分，他们就会失败并立即输掉比赛。
9. 玩家完成后，轮到经销商。
10. 经销商反复抽签，直到得分达到17分或更高，此时他们必须停止抽签。
11. 如果庄家超过21分，他们破产，玩家立即获胜。
12. 否则，如果玩家的得分高于经销商，则玩家获胜。否则，玩家将输掉比赛（为了简单起见，我们将考虑平局，因为经销商赢了）。


在Blackjack的简化版本中，我们不会跟踪玩家和庄家已经发了哪些特定的牌。我们将只跟踪玩家和庄家的卡的价值总和。这使事情变得简单。

从您在之前的测试中编写的代码开始（或使用我们的参考解决方案）。

>步骤#1

创建一个名为Player的结构，该结构将表示我们游戏中的参与者（经销商或玩家）。因为在这个游戏中，我们只关心玩家的分数，所以这个结构只需要一个成员。

编写一个函数，将（最终）玩一轮21点。目前，该函数应该为经销商绘制一张随机卡，为玩家绘制两张随机卡。它应该返回一个布尔值，指示谁的分数更高。

代码应输出以下内容：

显示解决方案

>步骤#2

添加一个包含两个常量的Settings命名空间：玩家破解的值，以及庄家必须停止抽牌的值。

添加处理经销商轮流的逻辑。庄家会抽牌，直到他们达到17，然后他们必须停止。如果他们失败了，玩家就赢了。

下面是一些示例输出：

显示解决方案

>步骤#3

最后，为玩家的回合添加逻辑。这将完成游戏。

下面是一些示例输出：

显示解决方案

问题#5

a） 描述如何修改上述程序以处理aces可以等于1或11的情况。

需要注意的是，我们只跟踪卡的总数，而不是用户拥有的特定卡。

显示解决方案

b） 在实际的21点中，如果玩家和庄家有相同的分数（并且玩家没有破产），结果是平局，双方都不赢。请描述您将如何修改上述程序以解决此问题。

显示解决方案

c） 额外学分：在21点游戏中实现以上两个想法。请注意，您需要出示庄家的初始牌和玩家的初始两张牌，以便他们知道自己是否有王牌。

下面是一个输出示例：

显示解决方案

