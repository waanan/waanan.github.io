---
title: "std:：array简介"
date: 2024-08-13T13:06:02+08:00
---

在第16.1课——容器和数组简介中，我们介绍了容器和数组。总结如下：

1. 容器为未命名对象（称为元素）的集合提供存储。
2. 数组在内存中连续分配其元素，并允许通过下标快速、直接访问任何元素。
3. C++有三种常用的不同数组类型：std:：vector、std:∶array和C样式数组。


在第16.10课——std:：vector resizing and capacity中，我们提到数组分为两类：

1. 固定大小的数组（也称为固定长度数组）要求在实例化时知道数组的长度，并且该长度不能在以后更改。C样式数组和std:：array都是固定大小的数组。
2. 动态数组可以在运行时调整大小。vector是一个动态数组。


在前一章中，我们重点讨论了std:：vector，因为它速度快，相对容易使用，并且用途广泛。这使得它成为我们需要数组容器时的首选类型。

***
## 那么，为什么不对所有内容都使用动态数组呢？

动态阵列功能强大且方便，但与生活中的一切一样，它们在提供的好处方面做出了一些权衡。

1. 与固定大小的数组相比，std:：vector的性能稍差。在大多数情况下，您可能不会注意到差异（除非您正在编写导致大量无意重新分配的草率代码）。
2. std:：vector仅在非常有限的上下文中支持constexpr。


在现代C++中，真正重要的是后一点。Constexpr数组提供了编写更健壮的代码的能力，并且还可以由编译器进行更高的优化。每当我们可以使用constexpr数组时，我们都应该——如果我们需要constexpr-array，std:：array就是我们应该使用的容器类。

{{< alert success >}}
**最佳做法**

对constexpr数组使用std:：array，对非常量表达式数组使用std:：vector。

{{< /alert >}}

***
## 定义std:：数组

std:：array在<array>标头中定义。它的工作原理类似于std:：vector，正如您将看到的，两者之间的相似之处多于差异。

一个区别是我们如何声明std:：array：

```C++
#include <array>  // for std::array
#include <vector> // for std::vector

int main()
{
    std::array<int, 5> a {};  // a std::array of 5 ints

    std::vector<int> b(5);    // a std::vector of 5 ints (for comparison)

    return 0;
}
```

我们的std:：array声明有两个模板参数。第一个（int）是定义数组元素类型的类型模板参数。第二个（5）是定义数组长度的整型非类型模板参数。

{{< alert success >}}
**相关内容**

我们在第11.10课-非类型模板参数中介绍了非类型模板的参数。

{{< /alert >}}

***
## std:：数组的长度必须是常量表达式

与可以在运行时调整大小的std:：vector不同，std:数组的长度必须是常量表达式。通常，为长度提供的值将是整型文字、constexpr变量或非范围枚举器。

```C++
#include <array>

int main()
{
    std::array<int, 7> a {}; // Using a literal constant

    constexpr int len { 8 };
    std::array<int, len> b {}; // Using a constexpr variable

    enum Colors
    {
         red,
         green,
         blue,
         max_colors
    };

    std::array<int, max_colors> c {}; // Using an enumerator

#define DAYS_PER_WEEK 7
    std::array<int, DAYS_PER_WEEK> d {}; // Using a macro (don't do this, use a constexpr variable instead)

    return 0;
}
```

请注意，非常量变量和运行时常量不能用于长度：

```C++
#include <array>
#include <iostream>

void foo(const int length) // length is a runtime constant
{
    std::array<int, length> e {}; // error: length is not a constant expression
}

int main()
{
    // using a non-const variable
    int numStudents{};
    std::cin >> numStudents; // numStudents is non-constant

    std::array<int, numStudents> {}; // error: numStudents is not a constant expression

    foo(7);

    return 0;
}
```

{{< alert success >}}
**警告**

也许令人惊讶的是，可以将std:：数组的长度定义为0:

```C++
#include <array>
#include <iostream>

int main()
{
    std::array<int, 0> arr {}; // creates a zero-length std::array
    std::cout << arr.empty();  // true if arr is zero-length

    return 0;
}
```

零长度std:：数组是一个没有数据的特例类。因此，调用访问零长度std:：数组的数据的任何成员函数（包括运算符[]）都将产生未定义的行为。

可以使用empty（）成员函数测试std:：数组是否为零长度，如果数组长度为零，则返回true，否则返回false。

{{< /alert >}}

***
## std:：数组的聚合初始化

也许令人惊讶的是，std:：array是一个聚合。这意味着它没有构造函数，而是使用聚合初始化进行初始化。作为快速回顾，聚合初始化允许我们直接初始化聚合的成员。为此，我们提供了一个初始值设定项列表，这是一个用逗号分隔的初始化值的大括号括起来的列表。

```C++
#include <array>

int main()
{
    std::array<int, 6> fibonnaci = { 0, 1, 1, 2, 3, 5 }; // copy-list initialization using braced list
    std::array<int, 5> prime { 2, 3, 5, 7, 11 };         // list initialization using braced list (preferred)

    return 0;
}
```

每个初始化表单都按顺序初始化数组成员，从元素0开始。

如果在没有初始值设定项的情况下定义了std:：数组，则元素将被默认初始化。在大多数情况下，这将导致元素未初始化。

因为我们通常希望初始化元素，所以在没有初始化器的情况下定义std:：数组时，应该对其进行值初始化（使用空大括号）。

```C++
#include <array>
#include <vector>

int main()
{
    std::array<int, 5> a;   // Members default initialized (int elements are left uninitialized)
    std::array<int, 5> b{}; // Members value initialized (int elements are zero initialized) (preferred)

    std::vector<int> v(5);  // Members value initialized (int elements are zero initialized) (for comparison)

    return 0;
}
```

如果初始化器列表中提供的初始化器多于定义的数组长度，编译器将出错。如果初始化器列表中提供的初始化器少于定义的数组长度，则没有初始化器的其余元素将被值初始化：

```C++
#include <array>

int main()
{
    std::array<int, 4> a { 1, 2, 3, 4, 5 }; // compile error: too many initializers
    std::array<int, 4> b { 1, 2 };          // b[2] and b[3] are value initialized

    return 0;
}
```

{{< alert success >}}
**相关内容**

在第13.8课——结构聚合初始化中，我们讨论了结构的聚合初始化。

{{< /alert >}}

***
## Const和constexpr std:：数组

std:：数组可以是常量：

```C++
#include <array>

int main()
{
    const std::array<int, 5> prime { 2, 3, 5, 7, 11 };

    return 0;
}
```

即使const std:：数组的元素没有显式标记为const，它们仍然被视为const（因为整个数组是const）。

std:：array还完全支持constexpr:

```C++
#include <array>

int main()
{
    constexpr std::array<int, 5> prime { 2, 3, 5, 7, 11 };

    return 0;
}
```

对constexpr的这种支持是使用std:：array的关键原因。

{{< alert success >}}
**最佳做法**

尽可能将std:：array定义为constexpr。如果您的std:：array不是constexpr，请考虑改用std:：vector。

{{< /alert >}}

***
## std:：数组C++17的类模板参数推导（CTAD）

在C++17中使用CTAD（类模板参数推导），我们可以让编译器从初始值设定项列表中推导std:：数组的元素类型和数组长度：

```C++
#include <array>
#include <iostream>

int main()
{
    constexpr std::array a1 { 9, 7, 5, 3, 1 }; // The type is deduced to std::array<int, 5>
    constexpr std::array a2 { 9.7, 7.31 };     // The type is deduced to std::array<double, 2>

    return 0;
}
```

只要可行，我们都喜欢这种语法。如果编译器不支持C++17，则需要显式提供类型和长度模板参数。

CTAD不支持部分省略模板参数（从C++23开始），因此无法使用核心语言功能仅省略std:：数组的长度或类型：

```C++
#include <iostream>

int main()
{
    constexpr std::array<int> a2 { 9, 7, 5, 3, 1 };     // error: too few template arguments (length missing)
    constexpr std::array<5> a2 { 9, 7, 5, 3, 1 };       // error: too few template arguments (type missing)

    return 0;
}
```

{{< alert success >}}
**最佳做法**

使用类模板参数演绎（CTAD）让编译器从其初始值设定项推断std:：数组的类型和长度。

{{< /alert >}}

***
## 使用std:：to_array C++20仅省略数组长度

然而，TAD（模板参数推导，用于函数模板解析）支持部分省略模板参数。自C++20以来，可以通过使用std:：to_array helper函数来省略std:数组的数组长度：

```C++
#include <array>
#include <iostream>

int main()
{
    constexpr auto myArray1 { std::to_array<int, 5>({ 9, 7, 5, 3, 1 }) }; // Specify type and size
    constexpr auto myArray2 { std::to_array<int>({ 9, 7, 5, 3, 1 }) };    // Specify type only, deduce size
    constexpr auto myArray3 { std::to_array({ 9, 7, 5, 3, 1 }) };         // Deduce type and size

    return 0;
}
```

不幸的是，使用std:：to_array比直接创建std:：数组代价更高，因为它涉及创建一个临时std:：数组，然后该数组用于复制和初始化所需的std:∶数组。由于这个原因，std:：to_array应该仅在无法从初始值设定项有效确定类型的情况下使用，并且应该在多次创建数组时（例如在循环中）避免使用。

例如，由于无法指定short类型的文本，因此可以使用以下命令创建短值的std:：数组（而不必显式指定std:∶数组的长度）：

```C++
#include <array>
#include <iostream>

int main()
{
    constexpr auto shortArray { std::to_array<short>({ 9, 7, 5, 3, 1 }) };
    std::cout << sizeof(shortArray[0]) << '\n';

    return 0;
}
```

***
## 使用运算符[]访问数组元素

就像std:：vector一样，访问std:数组元素的最常见方法是使用下标操作符（操作符[]）：

```C++
#include <array> // for std::array
#include <iostream>

int main()
{
    constexpr std::array<int, 5> prime{ 2, 3, 5, 7, 11 };

    std::cout << prime[3]; // print the value of element with index 3 (7)
    std::cout << prime[9]; // invalid index (undefined behavior)

    return 0;
}
```

作为提示，运算符[]不执行边界检查。如果提供了无效的索引，将导致未定义的行为。

在下一课中，我们将讨论其他几种索引std:：数组的方法。

***
## 测验时间

问题#1

std:：数组使用哪种类型的初始化？

显示解决方案

如果不提供初始化值，为什么要显式地对std:：array进行值初始化？

显示解决方案

问题#2

定义一个std:：数组，该数组将保持一年中每天的高温（精确到十分之一度）。

显示解决方案

问题#3

使用以下值初始化std:：数组：'h'，'e'，'l'，'1'，'o'。打印索引为1的元素的值。

显示解决方案

