---
title: "第21章项目"
date: 2024-08-20T12:01:51+08:00
---

读者Avtem构思和合作该项目的秘诀。

***
## 项目时间

让我们实现经典的游戏15拼图！

在15拼图中，您从随机的4×4网格瓷砖开始。15个平铺具有数字1到15。缺少一个互动程序。

例如：

在这个拼图中，丢失的瓦片在左上角。

游戏的每一回合，您都会选择与丢失的互动程序相邻的一个互动程序，并将其滑入丢失互动程序占用的位置。

游戏的目标是滑动互动程序，直到它们按数字顺序排列，丢失的互动程序位于右下角：

你可以在这个网站上玩几轮。它将帮助您了解这个游戏是如何工作的，以及应该如何实现。

在我们的游戏版本中，每个回合用户都将输入一个字母的命令。有5个有效命令：

1. w-向上滑动平铺
2. a-向左滑动平铺
3. s-向下滑动平铺
4. d-向右滑动平铺
5. q-退出游戏


因为这将是一个较长的计划，我们将分阶段开发它。

还有一件事：在每个步骤中，我们将展示两件事：目标和任务。目标定义了步骤试图实现的结果，以及任何其他相关信息。这些任务提供了关于如何实现目标的详细信息和提示。

任务最初将隐藏在视图中，以鼓励您查看是否可以仅使用目标和示例输出或示例程序来完成每个步骤。如果您不确定如何开始，或者感觉卡住了，可以取消隐藏任务。它们应该有助于你向前迈进。

>步骤#1

因为这将是一个更大的程序，让我们从设计练习开始。

目标：记录该计划的关键要求，并计划如何在高水平上构建您的计划。我们将分三个部分来完成这项工作。

A） 您的程序需要做哪些顶级的事情？下面是一些入门指南：

董事会事项：

1. 显示游戏板
2. …


用户事项：

1. 从用户获取命令
2. …


显示解决方案

B） 您将使用哪些主类或命名空间来实现步骤1中概述的项？此外，main（）函数将做什么？

您可以创建图表，或使用两个类似的表：



显示解决方案

C） （额外学分）你能想出任何帮助器类或功能来使实现上述内容更容易或更具内聚性吗？

显示解决方案

如果你做这个练习有困难，那没关系。这里的目标主要是让你在开始做之前考虑你将要做什么。

现在，是时候开始实施了！

>步骤#2

目标：能够在屏幕上显示单个平铺。

我们的游戏板是一个4×4网格的瓷砖，可以四处滑动。因此，具有一个Tile类将非常有用，该类表示4×4网格上的一个编号瓷砖或丢失的瓷砖。每个磁贴应能够：

1. 被给予一个数字或被设置为缺少的平铺
2. 确定是否是缺少的平铺。
3. 以适当的间距绘制到控制台（以便在显示板时平铺将对齐）。请参阅下面的示例输出，以了解指示平铺间隔的示例。


显示任务

以下代码应编译并生成输出结果，您可以在代码下面看到：

```C++
int main()
{
    Tile tile1{ 10 };
    Tile tile2{ 8 };
    Tile tile3{ 0 }; // the missing tile
    Tile tile4{ 1 };

    std::cout << "0123456789ABCDEF\n"; // to make it easy to see how many spaces are in the next line
    std::cout << tile1 << tile2 << tile3 << tile4 << '\n';
    
    std::cout << std::boolalpha << tile1.isEmpty() << ' ' << tile3.isEmpty() << '\n';
    std::cout << "Tile 2 has number: " << tile2.getNum() << "\nTile 4 has number: " << tile4.getNum() << '\n';
    
    return 0;
}
```

预期输出（注意空格）：

显示解决方案

>步骤#3

目标：创建一个求解的板（4×4网格的瓷砖）并在屏幕上显示。

定义表示4×4网格平铺的Board类。新创建的Board对象应处于已求解状态。要显示线路板，首先打印g_consoleLines（在下面的代码段中定义）空行，然后打印线路板本身。这样做将确保任何先前的输出都被推出视图之外，以便在控制台上仅看到当前板。

为什么在已解决状态下启动董事会？当您购买这些谜题的物理版本时，谜题通常从已解决状态开始——在尝试解决它们之前，您必须手动将它们混合（通过滑动瓷砖）。我们将在程序中模拟该过程（我们将在未来的步骤中进行混合）。

显示任务

应运行以下程序：

```C++
// Increase amount of new lines if your board isn't
// at the very bottom of the console
constexpr int g_consoleLines{ 25 };

// Your code goes here

int main()
{
    Board board{};
    std::cout << board;

    return 0;
}
```

并输出以下内容：

显示解决方案

>步骤#4

目标：在这一步中，我们将允许用户重复输入游戏命令，处理无效输入，并实现退出游戏命令。

以下是我们的游戏将支持的5个命令（每个命令都将作为单个字符输入）：

1. “w”-向上滑动平铺
2. “a”-向左滑动平铺
3. “s”-向下滑动平铺
4. “d”-向右滑动平铺
5. 'q'-退出游戏


当用户运行游戏时，应发生以下情况：

1. 应将（解决）板打印到控制台。
2. 程序应该反复从用户那里获得有效的游戏命令。如果用户输入了无效的命令或无关的输入，请忽略它。


对于每个有效的游戏命令：

1. 打印“有效命令：”和用户输入的字符。
2. 如果该命令是quit命令，请同时打印“\n\n再见！\n\n”，然后退出应用程序。


因为我们的用户输入例程不需要维护任何状态，所以在名为UserInput的命名空间中实现它们。

显示任务

程序的输出应与以下内容匹配：

显示解决方案

>步骤#5

目标：实现一个帮助器类，使我们更容易处理定向命令。

实现上一步后，我们可以接受来自用户的命令（作为字符“w”、“a”、“s”、“d”和“q”）。在我们的代码中，这些字符本质上是神奇的数字。虽然可以在UserInput命名空间和函数main（）中处理这些命令，但我们不想在整个程序中传播它们。例如，Board类应该不知道“s”的含义。

实现一个名为Direction的助手类，它将允许我们创建表示基本方向（向上、向左、向下或向右）的对象。操作符-应返回相反的方向，并且操作符<<应将方向打印到控制台。我们还需要一个成员函数，该函数将返回包含随机方向的Direction对象。最后，向命名空间UserInput添加一个函数，该函数将定向游戏命令（'w'、'a'、's'或'd'）转换为Direction对象。

我们可以越多地使用Direction而不是定向游戏命令，我们的代码就越容易阅读和理解。

显示任务

最后，修改在上一步中编写的程序，使输出与以下内容匹配：

显示解决方案

>步骤#6

目标：实现一个助手类，它将使我们更容易索引游戏板中的分幅。

我们的游戏板是Tile的4×4网格，我们将其存储在board类的二维数组成员m_tiles中。我们将使用给定的平铺的{x，y}坐标来访问它。例如，左上方的平铺具有坐标{0,0}。其右侧的平铺具有坐标{1,0}（x变为1，y保持为0）。下一个平铺具有坐标{1,1}。

由于我们将大量使用坐标，因此创建一个名为Point的助手类，该类存储一对{x，y}坐标。我们应该能够比较两个Point对象的相等性和不相等性。还实现一个名为getAdjacentPoint的成员函数，该函数以Direction对象作为参数，并返回该方向上的Point。例如，点{1，1}.getAdjacentPoint（方向：：right）==点{2，1}。

显示任务

保存前一步中的main（）函数，因为在下一步中您将再次需要它。

对于每个测试用例，应运行并打印以下代码：

```C++
// Your code goes here

// Note: save your main() from the prior step, as you'll need it again in the next step
int main()
{
    std::cout << std::boolalpha;
    std::cout << (Point{ 1, 1 }.getAdjacentPoint(Direction::up)    == Point{ 1, 0 }) << '\n';
    std::cout << (Point{ 1, 1 }.getAdjacentPoint(Direction::down)  == Point{ 1, 2 }) << '\n';
    std::cout << (Point{ 1, 1 }.getAdjacentPoint(Direction::left)  == Point{ 0, 1 }) << '\n';
    std::cout << (Point{ 1, 1 }.getAdjacentPoint(Direction::right) == Point{ 2, 1 }) << '\n';
    std::cout << (Point{ 1, 1 } != Point{ 2, 1 }) << '\n';
    std::cout << (Point{ 1, 1 } != Point{ 1, 2 }) << '\n';
    std::cout << !(Point{ 1, 1 } != Point{ 1, 1 }) << '\n';

    return 0;
}
```

显示解决方案

>步骤#7

目标：添加玩家在板上滑动瓷砖的能力。

首先，我们应该仔细看看滑动瓷砖的实际工作原理：

给定如下所示的谜题状态：

当用户在键盘上输入“w”时，唯一可以向上移动的互动程序是互动程序2。

移动平铺后，板如下所示：

因此，本质上发生的是我们将空的磁贴与磁贴2交换。

让我们概括一下这个过程。当用户输入定向命令时，我们需要：

1. 找到空磁贴。
2. 从空平铺中，找到与用户输入方向相反的相邻平铺。
3. 如果相邻平铺有效（不脱离栅格），请交换空平铺和相邻平铺。
4. 如果相邻平铺无效，则不执行任何操作。


通过将成员函数moveFile（Direction）添加到类Board来实现这一点。从第5步开始，将其添加到游戏循环中。如果用户成功滑动平铺，则游戏应重新绘制更新的棋盘。

显示任务

显示解决方案

>步骤#8

目标：在这一步中，我们将完成游戏。随机化游戏板的初始状态。此外，还可以检测用户何时获胜，然后我们可以打印一条获胜消息并退出游戏。

我们需要注意如何随机化我们的谜题，因为并不是每个谜题都是可以解决的。例如，没有办法解决这个难题：

如果我们只是盲目地随机化谜题中的数字，有可能我们会产生这样一个无法解决的谜题。对于物理版本的谜题，我们将通过在随机方向上滑动瓷砖来随机化谜题，直到瓷砖充分混合。这样一个随机谜题的解决方案是将每个平铺沿与其滑动方向相反的方向滑动，以首先随机化它。因此，以这种方式随机化谜题总是生成可解谜题。

我们可以让我们的程序以相同的方式随机化董事会。

一旦用户解决了难题，程序应打印“\n\n您赢了！\n\n”，然后正常退出。

显示任务

下面是我们的15个益智游戏的完整解决方案：

显示解决方案

{{< alert success >}}
**作者注释**

如果你没有很多预先设计程序的经验，你可能会发现这有点困难。这是预料之中的。你把它做好并不重要，重要的是你的参与和学习。

在随后的步骤中，我们将更详细地介绍所有这些项目，因此如果您感到完全迷失，请跳过这一步。

{{< /alert >}}

