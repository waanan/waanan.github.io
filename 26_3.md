---
title: "虚拟析构函数、虚拟分配和重写虚拟化"
date: 2024-11-04T13:14:53+08:00
---

***
## 虚拟析构函数尽管C++为类提供了默认析构函数（如果您不自己提供），但有时您会希望提供自己的析构函数，特别是当类需要释放内存时。如果处理继承，则应该始终使析构函数成为虚拟的。考虑以下示例：#include<iostream>class-Base{public:~Base（）//注意：not-virtual{std:：cout<<“Calling~Base）\n”；}}；派生类：public Base{private:int*m_array{}；public:Derived（int length）：m_array{new int[length]}{}~Deriveed（）//注意：不是虚拟的（编译器可能会警告您这一点）{std:：cout<<“调用~Derive（）\n”；delete[]m_array；}}；int main（）{派生*派生{新派生（5）}；基*基{派生}；删除基数；返回0；}注意：如果编译上面的示例，编译器可能会警告您有关非虚拟析构函数的信息（这是本例中有意设置的）。您可能需要禁用将警告视为错误的编译器标志才能继续。由于base是base指针，因此在删除base时，程序会查看base析构函数是否是虚拟的。它不是，因此它假设它只需要调用Base析构函数。我们可以从上面的示例打印的事实中看到这一点：调用~Base（）然而，我们确实希望delete函数调用Derived的析构函数（它将依次调用Base的析构词），否则m_array将不会被删除。我们通过将Base的析构函数设置为virtual:#include<iostream>ClassBase{public:virtual~Base（）//注意：virtual{std:：cout<<“Calling~Base）\n”；}}；派生类：public Base{private:int*m_array{}；public:Derived（int length）：m_array{new int[length]}{}virtual~Deriveed（）//注意：virtual{std:：cout<<“调用~Derive（）\n”；删除[]m_array；}}；int main（）{派生*派生{新派生（5）}；基*基{派生}；删除基数；返回0；}现在，该程序产生以下结果：调用~Derived（）调用~Base（）规则无论何时处理继承，都应该将任何显式析构函数设置为虚拟的。与普通虚拟成员函数一样，如果基类函数是虚拟的，则所有派生重写都将被视为虚拟的，无论它们是否被指定为虚拟的。没有必要仅为了将其标记为虚拟而创建空的派生类析构函数。请注意，如果希望基类具有一个否则为空的虚析构函数，则可以这样定义析构函数：virtual~base（）=default；//生成虚拟默认析构函数虚拟赋值可以使赋值运算符成为虚拟的。然而，与析构函数的情况不同，虚拟化赋值操作符总是一个好主意，虚拟化分配操作符确实打开了一个充满蠕虫的袋子，并进入了本教程范围之外的一些高级主题。因此，为了简单起见，我们建议您暂时将任务保留为非虚拟任务。忽略虚拟化很少您可能希望忽略函数的虚拟化。例如，考虑以下代码：#include<string_view>ClassBase{public:virtual~Base（）=default；virtualstd:：string_view getName（）const{return“Base”；}}；派生类：public Base{public:virtual std:：string_view getName（）const{return“Derived”；}}；在某些情况下，您可能希望指向Derived对象的Base指针调用Base:：getName（），而不是Derived:：getName（）。为此，只需使用范围解析操作符：#include<iostream>intmain（）{Derived-Derived{}；常量基（&B）{派生}；//调用Base:：getName（），而不是虚拟化的Derived:：getName（）std:：cout<<Base。基：：getName（）<<'\n'；返回0；}您可能不会经常使用它，但知道它至少是可能的是好的。我们应该让所有的析构函数都是虚拟的吗？这是新程序员常见的问题。如上面的示例所述，如果基类析构函数未标记为virtual，则如果程序员稍后删除指向派生对象的基类指针，则程序有泄漏内存的风险。避免这种情况的一种方法是将所有析构函数标记为虚拟的。但你应该吗？说“是”很容易，因此您以后可以使用任何类作为基类——但这样做会降低性能（将虚拟指针添加到类的每个实例）。因此，你必须平衡成本，以及你的意图。我们建议如下：如果类没有显式地设计为基类，那么通常最好没有虚拟成员和虚拟析构函数。该类仍然可以通过组合使用。如果类被设计为用作基类和/或具有任何虚函数，则它应该始终具有虚析构函数。如果决定使类不可继承，那么下一个问题是是否可以强制执行这一点。传统智慧（正如备受推崇的C++专家Herb Sutter最初提出的那样）建议避免非虚拟析构函数内存泄漏情况，如下所示：“基类析构函数应该是公共的和虚拟的，或者是受保护的和非虚拟的。”不能使用基类指针删除具有受保护析构函数的基类，这阻止了通过基类指针来删除派生类对象。不幸的是，这也阻止了公共对基类析构函数的任何使用。这意味着：我们不应该动态地分配基类对象，因为我们没有常规的方法来删除它们（有非常规的变通方法，但很恶心）。我们甚至不能静态地分配基类对象，因为当它们超出范围时，析构函数是不可访问的。换句话说，使用这种方法，为了使派生类安全，我们必须使基类本身实际上不可用。既然最后一个说明符已经引入到语言中，我们的建议如下：如果希望从继承类，请确保析构函数是虚拟的和公共的。如果您不想从中继承您的类，请将您的类标记为final。这将首先防止其他类从中继承，而不会对类本身施加任何其他使用限制。下一课25.5早绑定和晚绑定返回目录上一课25.3重写和最终说明符，以及协变返回类型

