---
title: "早绑定和晚绑定"
date: 2024-11-04T13:14:53+08:00
---

在这一课和下一课中，我们将更深入地了解虚拟函数是如何实现的。虽然这些信息对于有效使用虚拟函数并不是严格必要的，但它很有趣。然而，您可以将这两部分视为可选阅读。执行C++程序时，它从main（）的顶部开始按顺序执行。当遇到函数调用时，执行点跳到被调用函数的开头。CPU如何知道这样做？编译程序时，编译器会将C++程序中的每个语句转换为一行或多行机器语言。机器语言的每一行都被赋予自己唯一的序列地址。对于函数来说，这没有什么不同——当遇到函数时，它被转换为机器语言，并给出下一个可用的地址。因此，每个函数最终都有一个唯一的地址。绑定和分发我们的程序包含许多名称（标识符、关键字等）。每个名称都有一组相关的属性：例如，如果名称表示变量，则该变量具有类型、值、内存地址等。例如，当我们说int x时，我们告诉编译器将名称x与类型int相关联。稍后，如果我们说x=5，则编译器可以使用此关联来类型检查赋值，以确保它有效。在一般编程中，绑定是将名称与此类属性相关联的过程。函数绑定（或方法绑定）是确定与函数调用关联的函数定义的过程。实际调用绑定函数的过程称为调度。在C++中，术语绑定的使用更随意（而分派通常被认为是绑定的一部分）。我们将探索下面这些术语的C++用法。术语绑定是一个重载术语。在其他上下文中，绑定可以指：对objectstd:：bindLanguage bindingEarly binding的引用的绑定编译器遇到的大多数函数调用都是直接函数调用。直接函数调用是直接调用函数的语句。例如：#include<iostream>struct-Foo{void printValue（int value）{std:：cout<<value；}}；void printValue（int value）{std:：cout<<value；}int main；f.打印值（5）；//直接调用Foo:：printValue（int）函数返回0；}在C++中，当直接调用非成员函数或非虚成员函数时，编译器可以确定哪个函数定义应与调用匹配。这有时称为早期绑定（或静态绑定），因为它可以在编译时执行。然后，编译器（或链接器）可以生成机器语言指令，告诉CPU直接跳到函数的地址。对于高级读者，如果我们查看为调用printValue（5）生成的汇编代码（使用clang x86-64），我们会看到类似这样的内容：mov edi，5；将参数5复制到edi寄存器中，为函数调用printValue（int）做准备；直接调用printValue（int）您可以清楚地看到，这是对printValue（int）的直接函数调用。对重载函数和函数模板的调用也可以在编译时解析：#include<iostream>template<typename T>void printValue（T value）{std:：cout<<value<<'\n'；}void printValue（double value）}std::cout<<value<<<'\n'；}void PrinntValue 0；}让我们来看一个使用早期绑定的简单计算器程序：#include<iostream>intadd（intx，inty）{return x+y；}intsubtract（intX，inty；std:：cout<<“输入数字：”；标准：：cin>>x；整数y{}；std:：cout<<“输入另一个数字：”；标准：：cin>>y；整数运算{}；std:：cout<<“输入运算（0=加法，1=减法，2=乘法）：”；标准：：cin>>op；整数结果{}；switch（op）{//使用早期绑定直接调用目标函数case 0:result=add（x，y）；break；case 1:result=subtract（x，y）；brreak；case2:result=multiply（x，y:break）；default:std:：cout<<“Invalid operator\n”；return 1；}std:cout<<<“答案是：”<<result<<'\n'；返回0；}由于add（）、subtract（）和multiply（）都是对非成员函数的直接函数调用，因此编译器将在编译时将这些函数调用与其各自的函数定义相匹配。注意，由于switch语句，直到运行时才确定实际调用的函数。然而，这是一个执行路径问题，而不是绑定问题。延迟绑定在某些情况下，函数调用直到运行时才能解析。在C++中，这有时被称为后期绑定（或者在虚拟函数解析的情况下，称为动态调度）。作者的注释在一般编程术语中，术语“后期绑定”通常意味着被调用的函数不能仅基于静态类型信息来确定，而必须使用动态类型信息来解析。在C++中，该术语的使用倾向于更松散地表示编译器或链接器在实际进行函数调用的点不知道所调用的实际函数的任何函数调用。在C++中，获得后期绑定的一种方法是使用函数指针。为了简单地回顾函数指针，函数指针是一种指向函数而不是变量的指针。函数指针指向的函数可以通过使用指针上的函数调用运算符（）来调用。例如，下面的代码通过函数指针调用printValue（）函数：#include<iostream>void printValue（int value）{std:：cout<<value<<'\n'；}int main（）{auto-fcn{printValue}；//创建函数指针并使其指向函数printValue fcn（5）；//通过函数指针间接调用printValue返回0；}通过函数指针调用函数也称为间接函数调用。在实际调用fcn（5）的点上，编译器在编译时不知道正在调用什么函数。相反，在运行时，对函数指针所持有的地址中存在的任何函数进行间接函数调用。对于高级读取器，如果我们查看为调用fcn（5）生成的汇编代码（使用clang x86-64），我们会看到如下内容：lea-rax，[rip+printValue（int）]；确定printValue的地址，并将其放入rax寄存器mov qword ptr[rbp-8]，rax；将rax寄存器中的值移动到与变量fcn-mov-edi相关联的存储器中，5；将参数5复制到edi寄存器中，以准备函数调用qword ptr[rbp-8]；在变量fcn保存的地址处调用函数。可以清楚地看到，这是通过其地址对printValue（int）的间接函数调用。下面的计算器程序在功能上与上面的计算器示例相同，只是它使用函数指针而不是直接函数调用：#include<iostream>intadd（intx，inty）{return x+y；}intsubtract（intX，inty；std:：cout<<“输入数字：”；标准：：cin>>x；整数y{}；std:：cout<<“输入另一个数字：”；标准：：cin>>y；整数运算{}；std:：cout<<“输入运算（0=加法，1=减法，2=乘法）：”；标准：：cin>>op；使用FcnPtr=int（*）（int，int）；//别名丑陋函数指针类型FcnPtr fcn{nullptr}；//创建一个函数指针对象，最初设置为nullptr//将fcn设置为指向用户选择的开关（op）的函数{case 0:fcn=add；break；case 1:fcn=subtract；break.case 2:fcn=multiply；break；default:std:：cout<<“无效运算符\n”；return 1；}//调用fcn指向的函数，并将x和y作为参数std::cout<<<“答案是：”<<fcn（x，y）<<'\n'；返回0；}在这个例子中，我们没有直接调用add（）、subtract（）或multiply（）函数，而是将fcn设置为指向希望调用的函数。然后通过指针调用函数。编译器无法使用早期绑定来解析函数调用fcn（x，y），因为它无法确定在编译时fcn将指向哪个函数！后期绑定的效率稍低，因为它涉及额外的间接级别。通过早期绑定，CPU可以直接跳到函数的地址。对于后期绑定，程序必须读取指针中保存的地址，然后跳到该地址。这涉及一个额外的步骤，使其稍微慢一些。然而，后期绑定的优点是它比早期绑定更灵活，因为在运行时才需要决定调用什么函数。在下一课中，我们将了解如何使用后期绑定来实现虚拟函数。下一个lesson25.6虚拟表返回内容表上一个leson25.4虚拟析构函数、虚拟赋值和重写虚拟化

