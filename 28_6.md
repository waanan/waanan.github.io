---
title: "第26章总结和测验"
date: 2025-01-22T20:47:14+08:00
---

模板允许我们使用占位符类型编写函数或类，以便我们可以使用不同的类型模板化相同版本的函数或类。已实例化的函数或类称为函数或类实例。

所有模板函数或类都必须以模板参数声明开头，该声明告诉编译器下面的函数或类是模板函数或类别。在模板参数声明中，指定模板类型参数或表达式参数。模板类型参数只是占位符类型，通常命名为T、T1、T2或其他单字母名称（例如S）。表达式参数通常是整型，但可以是函数、类对象或成员函数的指针或引用。

拆分模板类定义和成员函数定义不像普通类那样工作——不能将类定义放在头文件中，不能将成员函数定义放在.cpp文件中。通常最好将它们全部保存在头文件中，成员函数定义位于类的下面。

当我们想要覆盖特定类型的模板化函数或类的默认行为时，可以使用模板专门化。如果覆盖所有类型，则称为完全专门化。类还支持部分专门化，其中只有一些模板化参数是专门化的。函数不能部分专用化。

C++标准库中的许多类都使用模板，包括std:：array和std:∶vector。模板通常用于实现容器类，因此容器可以编写一次，并与任何适当的类型一起使用。

测验时间

```C++
int main()
{
	Pair1<int> p1 { 5, 8 };
	std::cout << "Pair: " << p1.first() << ' ' << p1.second() << '\n';

	const Pair1<double> p2 { 2.3, 4.5 };
	std::cout << "Pair: " << p2.first() << ' ' << p2.second() << '\n';

	return 0;
}
```

并打印：

显示解决方案

注意：我们将这个类命名为与前一个类不同的名称，因为C++当前不允许“重载”仅在模板参数的数量或类型上不同的类。

以下程序应工作：

```C++
int main()
{
	Pair<int, double> p1 { 5, 6.7 };
	std::cout << "Pair: " << p1.first() << ' ' << p1.second() << '\n';

	const Pair<double, int> p2 { 2.3, 4 };
	std::cout << "Pair: " << p2.first() << ' ' << p2.second() << '\n';

	return 0;
}
```

并打印：

提示：要使用两种不同的类型定义模板，请在模板参数声明中用逗号分隔这两种类型。有关详细信息，请参见第11.8课-具有多个模板类型的函数模板。

显示解决方案

应运行以下程序：

```C++
int main()
{
	StringValuePair<int> svp { "Hello", 5 };
	std::cout << "Pair: " << svp.first() << ' ' << svp.second() << '\n';

	return 0;
}
```

并打印：

提示：当您从StringValuePair构造函数调用Pair构造函数时，不要忘记将模板参数作为Pair类名的一部分。

显示解决方案

