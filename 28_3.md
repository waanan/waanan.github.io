---
title: "类模板专用化"
date: 2025-01-22T20:47:14+08:00
---

在上一课26.3——函数模板专门化中，我们看到了如何专门化函数，以便为特定数据类型提供不同的功能。事实证明，不仅可以专门化函数，还可以专门化类！考虑这样一种情况，您需要一个存储8个对象的类。下面是一个简化的类模板：#include<iostream>template<typenameT>classStorage8{private:TM_array[8]；public:void set（int index，const T&value）{m_array[索引]=value；}const T&get（int indexe）const{return m_array[索引]；}}；int main（）{//为整数Storage8<int>intStorage定义一个Storage8；for（int count{0}；count<8；++count）intStorage.set（count，count）；对于（int计数{0}；计数<8；++计数）标准：：cout<<intStorage.get（计数）<<'\n'；//为bool Storage8<bool>boolStorage定义Storage8；for（int count{0}；count<8；++count）boolStorage.set（count，count&3）；标准：：cout<<std:：boolalpha；for（int计数{0}；计数<8；++计数）{std:：cout<<boolStorage.get（计数）<<'\n'；}返回0；}此示例打印：0 1 2 3 4 5 6 7 false true true false true-true虽然该类完全是功能性的，但Storage8<bool>的实现效率比它需要的要低。由于所有变量都必须有地址，并且CPU不能寻址任何小于一个字节的内容，因此所有变量的大小都必须至少为一个字节。因此，bool类型的变量最终使用整个字节，即使从技术上讲，它只需要一个位来存储其true或false值！因此，布尔值是1位有用的信息和7位浪费的空间。我们的Storage8<bool>类包含8个bool，相当于1个字节的有用信息和7个字节的浪费空间。事实证明，使用一些基本的位逻辑，可以将所有8个布尔值压缩为单个字节，从而完全消除浪费的空间。然而，为了做到这一点，当与类型bool一起使用时，我们需要修改该类，将8个bool的数组替换为大小为单个字节的变量。虽然我们可以创建一个全新的类来这样做，但这有一个主要的缺点：我们必须给它一个不同的名称。然后，程序员必须记住，Storage8<T>是用于非布尔类型的，而Storage8Tool（或我们命名的新类）是用于布尔的。这是我们宁愿避免的不必要的复杂性。幸运的是，C++为我们提供了一种更好的方法：类模板专门化。类模板专门化Class模板专门化允许我们专门化特定数据类型（或数据类型，如果有多个模板参数）的模板类。在这种情况下，我们将使用类模板专门化来编写Storage8<bool>的定制版本，该版本将优先于通用Storage8>T>类。类模板专门化被视为完全独立的类，即使它们是以与模板化类相同的方式实例化的。这意味着我们可以改变关于专门化类的任何东西，包括它的实现方式，甚至它公开的函数，就像它是一个独立的类一样。就像所有模板一样，编译器必须能够看到专门化的完整定义才能使用它。此外，定义类模板专门化需要首先定义非专门化的类。下面是专用Storage8<bool>类的一个示例：#include<cstdint>//首先定义我们的非专用类模板模板Storage8{private:T m_array[8]；public:void set（int index，const T&value）{m_arry[index]=value；}const T&get（int indexe）const{return m_array[index]；}}；//现在定义我们的专用类模板模板<>//下面是一个没有模板参数的模板类类Storage8<bool>//我们专门为bool{//下面是标准的类实现细节private:std:：uint8_tm_data{}；public://不要担心这些函数的实现细节void set（int index，bool value）{//确定要设置/取消设置的位//这将在我们感兴趣的位中放入1，以打开/关闭自动掩码{1<<index}；if（value）//如果我们正在设置位m_data|=mask；//使用按位或打开该位，否则//如果要关闭m_data，请使用~mask；//按位和反转掩码来关闭该位}布尔get（int索引）{//确定要获取的自动掩码{1<<索引}；//按位，并获得我们感兴趣的位的值//然后隐式转换为布尔返回（m_data&mask）；}}；//与前面的示例相同，int main（）{//为整数定义Storage8（实例化Storage8<T>，其中T=int）Storage8<int>intStorage；for（int count{0}；count<8；++count）{intStorage.set（count，count；对于（整数计数{0}；计数<8；++count）{boolStorage.set（计数，计数&3）；}标准：：cout<<std:：boolalpha；for（int计数{0}；计数<8；++计数）{std:：cout<<boolStorage.get（计数）<<'\n'；}返回0；}首先，请注意，我们的专用类模板以模板<>开始。template关键字告诉编译器后面是模板，空的尖括号表示没有任何模板参数。在这种情况下，没有任何模板参数，因为我们将唯一的模板参数（t）替换为特定类型（bool）。接下来，我们将<bool>添加到类名中，表示我们专门化了类Storage8的bool版本。所有其他更改都只是类实现细节。为了使用该类，您不需要理解位逻辑是如何工作的（尽管您可以查看O.2--按位运算符，如果您想弄清楚它，但需要了解按位运算符的工作原理）。请注意，该专门化类使用std:：uint8_t（1字节无符号int），而不是8布尔（8字节）的数组。现在，当我们实例化对象类型Storage<T>时，其中T不是bool，我们将获得从通用模板化Storage8<T>类模板化的版本。当我们实例化Storage8<bool>类型的对象时，我们将获得刚刚创建的专用版本。请注意，我们保持了两个类的公开接口相同——虽然C++为我们提供了根据需要添加、删除或更改Storage8<bool>函数的自由支配权，但保持一致的接口意味着程序员可以以完全相同的方式使用这两个类。正如您所料，这将打印与使用Storage8<bool>的非专用版本的上一个示例相同的结果：0 1 2 3 4 5 7 false true true false TrueTrue Specializing成员函数在上一课中，我们介绍了以下示例：#include<iostream>template<typename T>class Storage{private:T m_value{}；公共：存储（T值）：m_value{value}{}void print（）{std:：cout<<m_value<<'\n'；}}；int main（）{//定义一些存储单元存储i{5}；存储d{6.7}；//打印出一些值i.Print（）；d.打印（）；}我们的愿望是专门化print（）函数，以便它以科学记数法打印双精度。使用类模板专门化，我们可以为Storage定义一个专门化的类：#include<iostream>template<typenameT>ClassStorage{private:T m_value{}；公共：存储（T值）：m_value{value}{}void print（）{std:：cout<<m_value<<'\n'；}}；//存储的显式类模板专门化<double>//请注意，这是多么冗余的模板<>类Storage<double>{private:double m_value{}；public：存储（双值）：m_value{value}{}void print（）；}；//我们将在类外部定义它，原因很快就会变得很明显//这是一个普通（非专用）成员函数定义（用于专用类Storage的成员函数打印<double>）void Storage<double>：：print（）{std:：cout<<std::scientific<<m_value<<'\n'；}int main（）{//定义一些存储单元Storage i{5}；存储d{6.7}；//使用显式专门化存储<double>//打印出一些值i.Print（）；//调用存储<int>：：print（从存储中实例化<T>）d.print（）；//调用Storage<double>：：print（从Storage的显式专门化调用）}然而，请注意这里有多少冗余。我们复制了整个类定义，以便可以更改一个成员函数！幸运的是，我们可以做得更好。C++不要求我们显式专用化Storage<double>来显式专用化Storage<dowle>：：print（）。相反，我们可以让编译器从存储<T>中隐式专门化存储<double>，并提供仅存储<double>：：print（）的显式专门化！如下所示：#include<iostream>template<typenameT>classStorage{private:TM_value{}；公共：存储（T值）：m_value{value}{}void print（）{std:：cout<<m_value<<'\n'；}}；//这是专门化的成员函数定义//显式函数专门化不是隐式内联的，因此如果放在头文件模板中，则使此内联<>void Storage<double>：：print（）{std:：cout<<std::scientic<<m_value<<'\n'；}int main（）{//定义一些存储单元Storage i{5}；存储d{6.7}；//将导致存储<double>隐式实例化//打印出一些值i.Print（）；//调用存储<int>：：print（从存储中实例化<T>）d.print（）；//调用Storage<double>：：print（从Storage的显式专门化调用<double>：：print（））}就这样！如前一课（26.3——函数模板专门化）中所述，显式函数专门化不是隐式内联的，因此如果在头文件中定义存储<double>：：print（），我们应该将其专门化标记为内联。定义类模板专门化的位置为了使用专门化，编译器必须能够看到非专门化类和专门化类的完整定义。如果编译器只能看到非专用类的定义，则它将使用该定义而不是专用化。由于这个原因，专门化的类和函数通常在非专门化类的定义下方的头文件中定义，因此包括单个头文件包括非专门化的类别和任何专门化。这确保了只要还可以看到非专门化类，就始终可以看到专门化。如果仅在单个翻译单元中需要专门化，则可以在该翻译单元的源文件中定义它。由于其他翻译单位将无法看到专门化的定义，他们将继续使用非专门化版本。注意不要将专门化放在其自己的单独头文件中，目的是将专门化的头包含在需要专门化的任何翻译单元中。设计基于头文件的存在或不存在而透明地更改行为的代码是一个坏主意。例如，如果您打算使用专门化，但忘记包含专门化的标头，则最终可能会使用非专门化版本。如果您打算使用非专门化，那么如果其他报头将专门化包含为可传递的include，您可能最终还是会使用专门化。下一课26.5部分模板专业化返回目录上一课26.3功能模板专业化

