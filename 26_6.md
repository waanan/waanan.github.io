---
title: "纯虚拟函数、抽象基类和接口类"
date: 2024-11-04T13:14:53+08:00
---

纯虚拟（抽象）函数和抽象基类到目前为止，我们编写的所有虚拟函数都有一个主体（定义）。然而，C++允许您创建一种特殊的虚拟函数，称为完全没有实体的纯虚拟函数（或抽象函数）！纯虚函数仅充当占位符，该占位符旨在由派生类重新定义。为了创建纯虚函数，而不是定义函数体，我们只需将值0分配给函数。#include<string_view>ClassBase{public:std:：string_view sayHi（）const{return“Hi”；}//a normal non-virtual function virtual std::string_view getName（）const{return“Base”；{//a nomall virtual function virtual int getValue（）const=0；//纯虚函数int doSomething（）=0；//编译错误：无法将非虚函数设置为0}；当我们向类中添加纯虚函数时，我们实际上是在说，“由派生类来实现该函数”。使用纯虚函数有两个主要后果：首先，任何具有一个或多个纯虚函数的类都成为抽象基类，这意味着它不能被实例化！考虑如果我们可以创建Base:intmain（）{Base-Base{}；//的实例，会发生什么情况我们不能实例化抽象基类，但为了示例起见，假设这是允许的base.getValue（）；//这有什么用？返回0；}因为没有getValue（）的定义，所以base.getValue（？其次，任何派生类都必须为此函数定义主体，否则该派生类也将被视为抽象基类。一个纯虚函数的例子让我们来看一个纯虚拟函数的例子。在上一课中，我们编写了一个简单的Animal基类，并从中派生了一个Cat和一个Dog类。下面是我们留下的代码：#include<string>#incl包括<string_view>classAnimal{protected:std:：string m_name{}；//我们将此构造函数设置为受保护的，因为//我们不希望人们直接创建Animal对象，//但我们仍然希望派生类能够使用它。Animal（std:：string_view-name）：m_name{name}{}public:const std::string&getName（）const{return m_name；}virtual std::string_view speak；类Cat:public Animal{public:Cat（std:：string_view名称）：Animal}name}{}std::string_view speak（）常量覆盖{return“喵”；}}；类Dog:public Animal{public:Dog（std:：string_view-name）：动物{name}{}标准：：string-view-speak（）常量覆盖{return“Woof”；}}；我们通过保护构造函数来防止人们分配Animal类型的对象。然而，仍然可以创建不重新定义函数speak（）的派生类。例如：#include<iostream>#incluse<string>#inclassAnimal{protected:std:：string m_name{}；//我们将此构造函数设置为受保护的，因为//我们不希望人们直接创建Animal对象，//但我们仍然希望派生类能够使用它。Animal（std:：string_view-name）：m_name{name}{}public:const std::string&getName（）const{return m_name；}virtual std::string_view speak；class Cow:public Animal{public:Cow（std:：string_view-name）:Animal{name}{}//我们忘记重新定义speak}；int main（）{奶牛{“Betsy”}；标准：：cout<<cow.getName（）<<“说”<<cow.speak（）<<'\n'；返回0；}这将打印：Betsy说？？？发生了什么事？我们忘了重新定义函数speak（），太牛了。Speak（）解析为Animal.Speak（），这不是我们想要的。这个问题的更好的解决方案是使用纯虚拟函数：#include<string>#incluse<string view>class Animal//this Animal是一个抽象基类{protected:std:：string m_name{}；public:Animal（std:：string_view name）：m_name{name}{}常量std:：string&getName（）const{return m_name；}虚拟标准：：string_view speak（）const=0；//请注意，speak现在是一个纯虚拟函数virtual~Animal（）=default；}；这里有几点需要注意。首先，speak（）现在是一个纯虚函数。这意味着Animal现在是一个抽象基类，不能被实例化。因此，我们不需要再保护构造函数（尽管它不会造成伤害）。其次，因为我们的Cow类是从Animal派生的，但我们没有定义Cow:：speak（），所以Cow也是一个抽象基类。现在，当我们试图编译这段代码时：#include<iostream>#incluse<string>#inclassAnimal//这个Animal是一个抽象基类{protected:std:：string m_name{}；public:Animal（std:：string_view name）：m_name{name}{}常量std:：string&getName（）const{return m_name；}虚拟标准：：string_view speak（）const=0；//请注意，speak现在是一个纯虚拟函数virtual~Animal（）=default；}；class Cow:public Animal{public:Cow（std:：string_view-name）:Animal{name}{}//我们忘记重新定义speak}；int main（）{奶牛{“Betsy”}；标准：：cout<<cow.getName（）<<“说”<<cow.speak（）<<'\n'；返回0；}编译器将给出错误，因为Cow是抽象基类，并且我们无法创建抽象基类的实例：prog.cc:35:9:error:variable type'Cow'是抽象类35|Cow Cow{“Betsy”}；|^prog.cc:17:30:注意：“Cow”17中未实现纯虚拟方法“speak”|virtual std:：string_view speak（）const=0；//请注意，speak现在是一个纯虚拟函数|^这告诉我们，只有当Cow为speak（）提供实体时，我们才能实例化Cow。让我们继续这样做：#include<iostream>#incluse<string>#inclassAnimal//这个Animal是一个抽象基类{protected:std:：string m_name{}；public:Animal（std:：string_view name）：m_name{name}{}常量std:：string&getName（）const{return m_name；}虚拟标准：：string_view speak（）const=0；//请注意，speak现在是一个纯虚拟函数virtual~Animal（）=default；}；类Cow:public Animal{public:Cow（std:：string_view-name）：Animal（name）{}标准：：string_view-speak（）常量覆盖{return“Moo”；}}；int main（）{奶牛{“Betsy”}；标准：：cout<<cow.getName（）<<“说”<<cow.speak（）<<'\n'；返回0；}现在，这个程序将编译和打印：Betsy说，Moo当我们有一个要放入基类的函数时，纯虚函数是有用的，但只有派生类知道它应该返回什么。纯虚函数使其无法实例化基类，并且派生类在实例化之前必须定义这些函数。这有助于确保派生类不会忘记重新定义基类期望它们重新定义的函数。就像普通虚函数一样，可以使用基类的引用（或指针）来调用纯虚函数：int main（）{Cow Cow{“Betsy”}；动物&a{牛}；标准：：cout<<a.speak（）；//解析为Cow:：speak（），打印“Moo”返回0；}在上面的示例中，.speak（）通过虚拟函数解析解析为Cow:：speak（。具有纯虚函数的reminderAny类也应该具有虚析构函数。带定义的纯虚函数事实证明，我们可以创建具有定义的纯虚拟函数：#include<string>#incl包括<string_view>class Animal//该Animal是一个抽象基类{protected:std:：string m_name{}；public:Animal（std:：string_view name）：m_name{name}{}常量std:：string&getName（）{return m_name；}虚拟std::string_view speak（）const=0；//=0表示该函数是纯虚拟的~Animal（）=default；}；std:：string_view Animal:：speak（）const//，即使它有一个定义{return“buzz”；}在这种情况下，由于“=0”（即使它已经给出了一个定义），speak）仍然被认为是纯虚函数，Animal仍然被视为抽象基类（因此不能被实例化）。从Animal继承的任何类都需要为speak（）提供自己的定义，否则它也将被视为抽象基类。为纯虚函数提供定义时，必须单独提供定义（而不是内联）。对于Visual Studio用户，Visual Studio允许将纯虚拟函数声明作为定义，例如：virtual std:：string_view speak（）const=0{return“buzz”；}这与C++标准不一致，不能禁用。当您希望基类为函数提供默认实现，但仍然强制任何派生类提供自己的实现时，此范例可能很有用。然而，如果派生类对基类提供的默认实现满意，则它可以直接调用基类实现。例如：#include<iostream>#incluse<string>#in包括<string_view>class Animal//该Animal是抽象基类{protected:std:：string m_name{}；public:Animal（std:：string_view name）：m_name（name）{}常量std:：string&getName（）const{return m_name；}虚拟std::string_view speak（）const=0；//请注意，speak是一个纯虚拟函数virtual~Animal（）=default；}；std:：string_view Animal:：speak（）const{return“buzz”；//一些默认实现}类Dragonfly:public Animal{public:Dragonfly（std::string_view name）:Animal}{name}{}std:：string_view speak；int main（）{蜻蜓dfly{“Sally”}；标准：：cout<<dfly.getName（）<<“says”<<dfll.speak（）<<'\n'；返回0；}上面的代码打印：Sally说buzz这个功能并不常用。析构函数可以成为纯虚拟的，但必须给出定义，以便在派生对象被析构化时可以调用它。接口类接口类是一个没有成员变量的类，其中所有函数都是纯虚拟的！当您想要定义派生类必须实现的功能时，接口非常有用，但将派生类如何实现该功能的细节完全留给派生类。接口类通常以I开头命名。下面是一个示例接口类：#include<string_view>class IErrorLog{public:virtual bool openLog（std:：string_view filename）=0；virtual bool closeLog（）=0，virtual ool writeError（std:：string_view errorMessage）=0。virtual~IErrorLog（）{}//在删除IError对数指针时创建虚拟析构函数，因此调用适当的派生析构函数}；从IErrorLog继承的任何类都必须为所有三个函数提供实现，才能被实例化。您可以派生一个名为FileErrorLog的类，其中openLog（）在磁盘上打开一个文件，closeLog（）关闭该文件，writeError（）将消息写入该文件。您可以派生另一个名为ScreenErrorLog的类，其中openLog（）和closeLog（。现在，假设您需要编写一些使用错误日志的代码。如果您编写的代码直接包含FileErrorLog或ScreenErrorLog.那么实际上，您将无法使用这种错误日志（至少在不重新编写程序的情况下）。例如，下面的函数有效地强制mySqrt（）的调用方使用FileErrorLog，这可能是他们想要的，也可能不是他们想要的#include<cmath>//for sqrt（）double mySqrt（double value，FileErrorLog&log）{if（value<0.0）{log.writeError（“试图取小于0的值的平方根”）；返回0.0；}返回std:：sqrt实现该函数的一种更好的方法是使用IErrorLog:#include<cmath>//for sqrt（）double mySqrt（double value，IErrorLog&log）{if（value<0.0）{log.writeError（“试图取小于0的值的平方根”）；return 0.0；}return std:：sqrt现在，调用者可以传入符合IErrorLog接口的任何类。如果他们希望错误转到文件，则可以传入FileErrorLog的实例。如果他们希望它转到屏幕，则可以传入ScreenErrorLog的实例。或者，如果他们想做一些您甚至没有想到的事情，例如在出现错误时向某人发送电子邮件，他们可以从IErrorLog（例如EmailErrorLog）派生一个新类，并使用该类的实例！通过使用IErrorLog，您的函数变得更加独立和灵活。不要忘记为接口类包含虚拟析构函数，以便在删除接口指针时调用适当的派生析构函数。接口类变得非常流行，因为它们易于使用、易于扩展和易于维护。事实上，一些现代语言（如Java和C#）添加了“interface”关键字，允许程序员直接定义接口类，而不必将所有成员函数显式标记为抽象。此外，尽管Java和C#不允许在普通类上使用多重继承，但它们将允许您根据需要多重继承任意多个接口。因为接口并没有数据和函数体，所以它们避免了许多具有多重继承的传统问题，同时仍然提供了很大的灵活性。纯虚拟函数和虚拟表为了一致性，抽象类仍然具有虚拟表。抽象类的构造函数或析构函数可以调用虚函数，它需要解析为适当的函数（在同一个类中，因为派生类尚未构造或已被销毁）。具有纯虚拟函数的类的虚拟表条目通常要么包含空指针，要么指向打印错误的泛型函数（有时该函数名为__purecall）。下一个lesson25.8虚拟基类返回目录上一个leson25.6虚拟表

