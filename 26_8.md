---
title: "对象切片（Object slicing）"
date: 2024-11-04T13:14:53+08:00
---

让我们回到前面看到的示例：#include<iostream>#incluse<string_view>ClassBase{protected:intm_value{}；public:Base（int值）：m_value{value}{}virtual~Base（）=默认值；虚拟标准：：string_view getName（）const{return“Base”；}int getValue（）const{returnm_value；}}；派生类：public Base{public:Derived（int value）：Base{value}{}std:：string_view getName（）const override{return“Deriveed”；}}；int main（）{派生派生{5}；std:：cout<<“derived是”<<derived.getName（）<<“并且具有值”<<derived.getValue（）<<'\n'；基&ref{派生}；std:：cout<<“ref是”<<ref.getName（）<<“并且具有值”<<ref.getValue（）<<'\n'；基*ptr{&derived}；std:：cout<<“ptr是”<<ptr->getName（）<<“并且具有值”<<ptr->getValue（）<<'\n'；返回0；}在上面的示例中，ref引用和ptr指向衍生，衍生具有基础零件和衍生零件。因为ref和ptr的类型是Base，所以ref和ptr只能看到派生的Base部分——派生的derived部分仍然存在，但不能通过ref或ptr看到。然而，通过使用虚拟函数，我们可以访问函数的最派生版本。因此，上面的程序打印：derived是derived，值为5 ref是Derive，值为5ptr是Derivated，值为5.但是，如果我们不是设置Base引用或指向Derivative对象的指针，而是简单地将Deriveed对象分配给Base对象，会发生什么情况？int main（）{派生派生{5}；基{派生}；//这里发生了什么？std:：cout<<“base是”<<base.getName（）<<“并且具有值”<<base.getValue（）<<'\n'；返回0；}请记住，衍生零件有基础零件和衍生零件。将衍生对象指定给基础对象时，仅复制衍生对象的基础部分。派生部分不是。在上面的示例中，base接收派生的base部分的副本，但不接收派生部分的副本。该衍生部分已被有效地“切割”。因此，将派生类对象分配给基类对象被称为对象切片（或简称切片）。因为base过去是，现在仍然是base，所以base的虚拟指针仍然指向base。因此，base.getName（）解析为base:：getName（）。上面的示例打印：base是base，具有值5。认真使用，切片可以是良性的。然而，如果使用不当，切片可能会以许多不同的方式导致意外的结果。让我们来看看其中的一些情况。切片和函数现在，您可能会认为上面的示例有点傻。毕竟，为什么要这样将派生赋值给基数？您可能不会。然而，切片更可能在函数中意外发生。考虑以下函数：void printName（const Base Base）//注意：Base通过值传递，而不是引用{std:：cout<<“I am”<<Base.getName（）<<'\n'；}这是一个非常简单的函数，具有通过值传递的常量基对象参数。如果我们像这样调用这个函数：intmain（）{Derived{5}；打印名（d）；//oops，没有意识到这是调用端返回0时的传递值；}编写此程序时，您可能没有注意到base是一个值参数，而不是引用。因此，当被调用为printName（d）时，虽然我们可能期望base.getName（）调用虚拟化函数getName（）并打印“I am a Derived”，但事实并非如此。相反，将对衍生对象d进行切片，并且仅将基础部分复制到基础参数中。当base.getName（）执行时，即使getName（）函数是虚拟化的，也没有类的Derived部分可供其解析。因此，该程序打印：我是base在这种情况下，发生了什么是很明显的，但如果您的函数实际上没有打印这样的任何标识信息，则跟踪错误可能是一项挑战。当然，通过将函数参数设置为引用而不是传递值，可以很容易地避免这里的切片（这是通过引用传递类而不是通过值传递类的另一个原因）.void printName（const Base&Base）//注意：Base现在通过引用传递{std:：cout<<“I am”<<Base.getName（）<<'\n'；}int main（）{Derived d{5}；打印名（d）；返回0；}这打印出：我是派生切片向量。新程序员在切片方面遇到麻烦的另一个领域是尝试用std:：vector实现多态性。考虑以下程序：#include<vector>intmain（）{std:：vector<Base>v{}；v.push_back（基{5}）；//将Base对象添加到向量v.push_back（派生{6}）；//将派生对象添加到向量//打印（const auto&element:v）std:：cout<<“I am a”<<element.getName（）<<“with value”<<element.getValue（）<<'\n'；返回0；}这个程序编译得很好。但在运行时，它会打印：I am a Base with value 5 I am a Base with value 6类似于前面的示例，因为std:：vector被声明为Base类型的向量，当Derived（6）被添加到向量时，它被切片。解决这个问题有点困难。许多新程序员尝试创建对对象的引用的std:：vector，如下所示：std：：vector<Base&>v{}；不幸的是，这无法编译。std:：vector的元素必须是可赋值的，而不能重新分配引用（仅初始化）。解决此问题的一种方法是创建指针向量：#include<iostream>#incluse<vector>intmain（）{std:：vector<Base*>v{}；基b{5}；//b和d不能是匿名对象派生d{6}；v.push_back（&b）；//将Base对象添加到向量v.push_back（&d）；//将派生对象添加到向量//打印（const auto*element:v）std:：cout<<“I am a”<<element->getName（）<<“with value”<<element->getValue（）<<'\n'；返回0；}这打印：我是一个值为5的基础，我是一名值为6的派生，这很有效！关于这一点的一些评论。首先，nullptr现在是一个有效的选项，这可能是可取的，也可能是不可取的。其次，您现在必须处理指针语义，这可能会很尴尬。但好处是，使用指针允许我们将动态分配的对象放在向量中（只是不要忘记显式删除它们）。另一个选项是使用std:：reference_wrapper，这是一个模拟可重新分配引用的类：#include<functional>//for std::reference_ wrapper#incluse<iostream>#incl包括<string_view>#in包括<vector>class Base{protected:int m_value{}；public:Base（int值）：m_value{value}{}virtual~Base（）=默认值；虚拟标准：：string_view getName（）const{return“Base”；}int getValue（）const{returnm_value；}}；派生类：public Base{public:Derived（int value）：Base{value}{}std:：string_view getName（）const override{return“Deriveed”；}}；int main（）{std:：vector<std:：reference_wrapper<Base>>v{}；//基基b{5}的可重新分配引用的向量；//b和d不能是匿名对象派生d{6}；v.push_back（b）；//将Base对象添加到向量v.push_back（d）；//将派生对象添加到我们的向量//打印出向量中的所有元素//我们使用.get（）从（const auto&element:v）的std:：reference_wrapper中获取元素//元素的类型为const std：：reference _wrapper<Base>&std：:cout<<“I am a”<<element.get（（）.getName（）<<“with value”<<element.get（）.getValue（）<<'\n'；返回0；}Frankenobject在上面的例子中，我们看到了切片导致错误结果的情况，因为派生类已经被切片。现在，让我们来看另一个派生对象仍然存在的危险情况！考虑以下代码：intmain（）{Derived1{5}；导出d2{6}；基&b{d2}；b=d1；//此行有问题，返回0；}函数中的前三行非常简单。创建两个衍生对象，并将“Base”引用设置为第二个对象。第四行是事情误入歧途的地方。由于b指向d2，我们将d1赋给b，你可能会认为结果是d1会被复制到d2中-，如果b是Derived。但b是一个Base，C++为类提供的操作符=在默认情况下不是虚拟的。因此，将调用复制Base的赋值运算符，并且仅将d1的Base部分复制到d2中。因此，您将发现d2现在具有d1的基本部分和d2的派生部分。在这个特定的示例中，这不是问题（因为Derived类没有自己的数据），但在大多数情况下，您只需要创建一个Frankenobject——由多个对象的部分组成。更糟糕的是，没有简单的方法来防止这种情况发生（除了尽可能避免这样的任务）。Tip如果基类不是设计为自己实例化的（例如，它只是一个接口类），则可以通过使基类不可复制来避免切片（通过删除基类复制构造函数和基类赋值运算符）。结论尽管C++支持通过对象切片将派生对象分配给基础对象，但一般来说，这可能只会导致头痛，您通常应该尽量避免切片。确保函数参数是引用（或指针），并在涉及派生类时尝试避免任何类型的传递值。下一个lesson25.10动态强制转换返回目录上一个leson25.8虚拟基类

