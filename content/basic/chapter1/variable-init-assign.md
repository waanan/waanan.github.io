---
title: "变量初始化和赋值"
date: 2023-10-09T20:06:10+08:00
---

在上一节中，我们介绍了如何定义用于存储值的变量。在本课中，我们将探索如何将值实际放入变量中并使用。

这里有一段简短的代码，它首先分配一个名为x的整数变量，然后再分配两个名为y和z的整数变量：

```C++
int x;    // 定义一个类型为int的变量x
int y, z; // 定义两个类型为int的变量y与z
```

***
## 变量赋值

定义变量后，可以使用「=」运算符（在单独的语句中）为其赋值。这个写入的过程称为赋值，「=」运算符称为赋值运算符。

```C++
int width; // 定义一个类型为int的变量width
width = 5; // 将值5写入width中

// 变量width现在的值是5
```

默认情况下，赋值将=运算符右侧的值复制到运算符左侧的变量。这称为「拷贝赋值」。

下面是一个使用赋值两次的示例：

```C++
#include <iostream>

int main()
{
	int width;
	width = 5; // 将值 5 拷贝赋值到变量 width

	std::cout << width << std::endl; // 打印出 5

	width = 7; // 将width中的值改变为 7

	std::cout << width << std::endl; // 打印出 7

	return 0;
}
```

这将打印：

```C++
5
7
```

当我们将值7赋给变量width时，先前存在的值5将被覆盖。

{{< alert danger >}}
**警告**

新手程序员最常见的错误之一是混淆赋值运算符（=）和相等运算符（==）。赋值（=）用于将值赋值给变量。相等（==）用于测试两个操作数的值是否相等。

{{< /alert >}}

***
## 初始化

赋值的一个特点是它至少需要两个语句：赋值之前必须存在一条变量定义语句。

这两个步骤可以结合使用。定义变量时，还可以同时为变量提供初始值。这称为初始化。用于初始化变量的值称为初始值。

C++中的初始化非常复杂，这里进行简单说明。

在C++中有6种基本的变量初始化方法：

```C++
int a;         // 默认初始化
int b = 5;     // 拷贝初始化
int c( 6 );    // 直接初始化

// 列表初始化 (C++11引进)
int d { 7 };   // 直接列表初始化
int e = { 8 }; // 拷贝列表初始化
int f {};      // 值列表初始化
```

花括号以不同的间距编写。是否使用额外的空格来提高可读性，是个人偏好问题。

***
## 默认初始化

当没有提供初始化值时（例如上面的变量a），这称为默认初始化。在大多数情况下，默认初始化会使变量的值不确定。

***
## 拷贝初始化

当在等号之后提供初始值设定项时，这称为拷贝初始化。这种形式的初始化是从C继承的。

```C++
int width = 5; // 将 5 拷贝初始化，设置到变量 width
```

与赋值很相似，这会将等式右侧的值复制到在左侧创建的变量中。在上面的代码段中，变量 width 将用值5初始化。

拷贝初始化在现代C++中已不受欢迎，因为对于某些复杂类型，它的效率低于其他形式的初始化。您还会发现它用于较旧的代码（特别是从C移植的代码），或者有些开发人员认为它看起来更自然，更容易阅读。

{{< alert success >}}
**对于高级读者**

每当隐式复制或转换值时，也会使用拷贝初始化，例如按值将参数传递给函数、按值从函数返回或按值捕获异常。

{{< /alert >}}

***
## 直接初始化

当在括号内提供初始值设定项时，这称为直接初始化。

```C++
int width( 5 ); // 直接将值 5 设置到变量 width
```

最初引入直接初始化是为了更有效地初始化复杂对象（那些具有class类型的对象）。由于被列表初始化所取代，直接初始化在现代C++中已经不受欢迎，就像拷贝初始化一样。然而，列表初始化本身有一些奇怪的特性，因此直接初始化在某些情况下再次得到了应用。

{{< alert success >}}
**对于高级读者**

当值显式转换为另一类型时，也使用直接初始化。

直接初始化不受欢迎的原因之一是，它使得很难区分变量和函数定义。例如：

```C++
int x();  // 前向声明函数 x
int x(0); // 定义一个初始值为0的变量x
```

{{< /alert >}}

***
## 列表初始化

在C++中初始化对象的现代方法是使用一种利用花括号的初始化形式：列表初始化（也称为统一初始化或大括号初始化）。

列表初始化有三种形式：

```C++
int width { 5 };    // 直接列表初始化，将变量width设置为 5
int height = { 6 }; // 拷贝列表初始化，将变量height设置为6
int depth {};       // 值初始化
```

列表初始化还有一个好处：它不允许“缩小转换范围”。这意味着，如果尝试使用变量不能安全保存的值，编译器将产生错误。例如：

```C++
int width { 4.5 }; // error: int类型无法装下分数
```

如上，我们试图将具有小数部分（.5部分）的数字（4.5）分配给整数变量（它只能容纳没有小数部分的数字）。

拷贝和直接初始化只会删除小数部分，而将值4初始化到变量width（编译器会发出警告，因为很少需要丢失数据）。然而，使用列表初始化时，编译器将生成错误，迫使您纠正此问题。

列表初始化允许在不丢失潜在数据的情况下进行转换。

总之，与其他初始化形式相比，列表初始化目前更受欢迎，因为它在大多数情况下都可以工作，它不允许缩小转换范围，并且它支持使用值列表进行初始化（将在以后的课程中介绍）。

{{< alert success >}}
**旁白…**

在引入列表初始化之前，某些类型的初始化需要使用拷贝初始化，而其他类型的初始化则需要使用直接初始化。引入列表初始化是为了提供在大多数情况下都有效的更一致的初始化语法（这就是为什么它有时被称为“统一初始化”）。

此外，列表初始化提供了一种使用值列表初始化对象的方法（这就是为什么它被称为“列表初始化”）。

{{< /alert >}}

***
## 值初始化和零初始化

当使用空大括号对变量进行列表初始化时，将进行值初始化。在大多数情况下，值初始化将变量初始化为零（或空，如果这更适合给定类型）。在发生归零的这种情况下，这称为零初始化。

```C++
int width {}; // 值初始化 / 零初始化，将变量width设为 0
```

{{< alert info >}}
**Q： 应该何时用{0}vs{}？**

如果实际使用初始化的值，则显式的设置初始化值。

```C++
int x { 0 };    // 显示的将变量x设为 0
std::cout << x; // 这里会使用设置的值
```

如果值在使用前会被替换，请使用值初始化。

```C++
int x {};      // 值初始化 / 零初始化
std::cin >> x; // x直接被其它语句赋值
```

{{< /alert >}}

***
## 初始化变量

有些场景（比如为了关键代码性能的原因），在定义变量时，可能想不去初始化变量，这也是可允许的。

在第1.6课中，我们将探讨如果尝试使用没有明确定义值的变量会发生什么——未初始化的变量和未定义的行为。

{{< alert success >}}
**最佳做法**

创建变量时初始化变量。

{{< /alert >}}

***
## 初始化多个变量

在上一节中，我们注意到，通过用逗号分隔名称，可以在单个语句中定义相同类型的多个变量：

```C++
int a, b;
```

其实，最佳实践是完全避免这种语法。然而，由于可能会遇到使用这种风格的其他代码，再多谈谈它是有用的。

您可以初始化在同一行上定义的多个变量：

```C++
int a = 5, b = 6;          // 拷贝初始化
int c( 7 ), d( 8 );        // 直接初始化
int e { 9 }, f { 10 };     // 直接列表初始化
int g = { 9 }, h = { 10 }; // 拷贝列表初始化
int i {}, j {};            // 值初始化
```

当程序员尝试使用一个初始化语句来初始化两个变量时，可能会出现一个常见的陷阱：

```C++
int a, b = 5; // 错误 (a 没有被初始化!)

int a = 5, b = 5; // 正确
```

在顶部语句中，变量“a”将保持未初始化状态，编译器可能会告警，也可能不会告警。这是一种让程序间歇性崩溃的好方法。

考虑直接初始化或大括号初始化的情况：

```C++
int a, b( 5 );
int c, d{ 5 };
```

由于括号或大括号通常放在变量名的右边，这使得值5仅用于初始化变量b和d，而不是a或c，看起来更容易发现错误。

***

{{< prevnext prev="/basic/chapter1/variable/" next="/basic/chapter1/iostream/" >}}
1.2 对象与变量
<--->
1.4 iostream:cout、cin和endl简介
{{< /prevnext >}}
