---
title: "dynamic_cast"
date: 2024-11-04T13:14:53+08:00
---

早在第10.6课——显式类型转换（casting）和static_cast中，我们研究了casting的概念，以及使用static_cast将变量从一种类型转换为另一种类型。

在本课程中，我们将继续研究另一种类型的强制转换：dynamic_cast。

对dynamic_cast的需要

在处理多态性时，您经常会遇到这样的情况，即您有一个指向基类的指针，但您希望访问仅存在于派生类中的一些信息。考虑下面的（稍微有点做作的）程序：#include<iostream>#incluse<string>#in包括<string_view>ClassBase{protected:intm_value{}；public:Base（int值）：m_value{value}{}virtual~Base（）=默认值；}；派生类：public Base{protected:std:：string m_name{}；public：派生（int value，std:：string_view name）：基{value}，m_name{name}{}常量std:：string&getName（）常量{return m_name；}}；Base*getObject（bool returnDerived）{if（returnDetrived）return new Derived{1，“Apple”}；否则返回新的基{2}；}int main（）{Base*b{getObject（true）}；//我们如何在这里打印派生对象的名称，并且只有基指针？删除b；返回0；}在该程序中，函数getObject（）始终返回Base指针，但该指针可以指向Base或Derived对象。在Base指针实际指向Derived对象的情况下，如何调用Derived:：getName（）？一种方法是将一个名为getName（）的虚拟函数添加到Base中（因此我们可以使用Base指针/引用调用它，并将其动态解析为Derived:：getName（））。但如果使用实际指向Base对象的Base指针/引用调用它，该函数将返回什么？没有任何真正有意义的价值。此外，我们将用真正应该仅由派生类关注的东西来污染我们的基类。我们知道C++将隐式地允许您将Derived指针转换为Base指针（实际上，getObject（）就是这样做的）。该过程有时称为上播。然而，如果有一种方法可以将基本指针转换回派生指针，该怎么办？然后，我们可以使用该指针直接调用Derived:：getName（），而根本不必担心虚函数解析。dynamic_castC++提供了一个名为dynamic_cast的转换操作符，可以用于此目的。尽管动态强制转换具有一些不同的功能，但到目前为止，动态强制转换最常见的用途是将基类指针转换为派生类指针。这个过程被称为向下投射。使用dynamic_cast就像static_cast一样工作。下面是上面的示例main（），使用dynamic_cast将Base指针转换回Derived指针：int main（）{Base*b{getObject（true）}；派生*d{dynamic_cast<Derived*>（b）}；//使用动态转换将基指针转换为派生指针std:：cout<<“派生的名称是：”<<d->getName（）<<'\n'；删除b；返回0；}这会打印：Derived的名称是：Apple dynamic_cast failure.上面的示例之所以有效，是因为b实际上指向DerivedObject，因此将b转换为Derivedpointer是成功的。然而，我们做了一个相当危险的假设：b指向派生对象。如果b没有指向派生对象怎么办？通过将参数从true更改为false来轻松测试这一点。在这种情况下，getObject（）将返回指向Base对象的Base指针。当我们试图将其动态转换为Derived时，它将失败，因为无法进行转换。如果dynamic_cast失败，转换的结果将是空指针。因为我们没有检查空指针结果，所以访问d->getName（），它将尝试取消引用空指针，导致未定义的行为（可能是崩溃）。为了使该程序安全，我们需要确保dynamic_cast的结果实际成功：intmain（）{Base*b{getObject（true）}；派生*d{dynamic_cast<Derived*>（b）}；//如果（d）//确保d为非空std:：cout<<“派生的名称为：”<<d->getName（）<<'\n'；删除b；返回0；}RuleAlways通过检查空指针结果来确保动态强制转换实际成功。请注意，由于dynamic_cast在运行时执行一些一致性检查（以确保可以进行转换），因此使用dynamic_cast确实会导致性能损失。还要注意，在一些情况下，使用dynamic_cast进行向下转换将不起作用：使用受保护的继承或私有继承。对于不声明或继承任何虚拟函数（因此没有虚拟表）的类。在涉及虚拟基类的某些情况下（请参阅本页以获取其中一些情况的示例，以及如何解决它们）。使用static_cast进行向下转换原来，向下转换也可以使用static_cast完成。主要区别是static_cast不进行运行时类型检查，以确保所做的工作有意义。这使得使用static_cast更快，但更危险。如果将Base*强制转换为Derived*，则即使Base指针未指向Derived对象，它也将“成功”。当您尝试访问生成的Derived指针（它实际上指向Base对象）时，这将导致未定义的行为。如果您绝对确信正在向下转换的指针将成功，那么使用static_cast是可以接受的。确保您知道所指向的对象类型的一种方法是使用虚函数。这里有一种（不是很好的）方法：#include<iostream>#incluse<string>#in包括<string_view>//类标识符枚举类ClassID{base，derived//稍后可以在这里添加其他}；基类{protected:int m_value{}；public:Base（int值）：m_value{value}{}virtual~Base（）=默认值；虚拟ClassID getClassID（）常量{return ClassID:：base；}}；派生类：public Base{protected:std:：string m_name{}；public:Derived（int value，std:：string_view name）：基{value}，m_name{name}{}常量std:：string&getName（）常量{return m_name；}ClassID getClassID（）覆盖常量{retain ClassID:：Derived.}}；Base*getObject（bool bReturnDerived）{if（bReturn Derived）return new Derived{1，“Apple”}；否则返回新的基{2}；}int main（）{Base*b{getObject（true）}；如果（b->getClassID（）==ClassID:：derived）{//我们已经证明b指向derived对象，因此这应该总是在derived*d{static_cast<derived_>（b）}之后；std:：cout<<“派生的名称是：”<<d->getName（）<<'\n'；}删除b；返回0；}但如果您要经历所有的困难来实现这一点（并支付调用虚拟函数和处理结果的成本），那么您最好只使用dynamic_cast。还要考虑一下，如果我们的对象实际上是从derived派生的某个类（让我们称之为D2），会发生什么情况。上面的检查b->getClassID（）==ClassID:：derived将失败，因为getClassID（）将返回ClassID:：D2，它不等于ClassID:：derived。然而，将D2动态转换为Derived将成功，因为D2是派生的！dynamic_cast和references尽管上述所有示例都显示了指针的动态转换（这更常见），但dynamic_cast也可以与引用一起使用。这类似于dynamic_cast如何处理指针#include<iostream>#include<string>#inclass-Base{protected:int m_value；public:Base（int value）:m_value{value}{}virtual~Base（）=default；}；派生的类：public Base{protected:std:：string m_name；public：派生的（int value，std:：string_view name）：Base{value}，m_name{name}{}常量std:：string&getName（）const{return m_name，}}；int main（）{派生苹果{1，“苹果”}；//创建一个apple Base&b{apple}；//设置对象Derived&d的基引用{dynamic_cast<Derived（b）}；//使用引用而不是指针std:：cout<<“派生的名称是：”<<d.getName（）<<'\n'；//我们可以通过d return 0；}访问Derived:：getName由于C++没有“空引用”，因此dynamic_cast在失败时不能返回空引用。相反，如果引用的dynamic_cast失败，则抛出类型为std:：bad_cast的异常。在本教程的后面部分中，我们将讨论异常。dynamic_cast与static_cast新程序员有时会对何时使用static_cast与dynamic_cast感到困惑。答案很简单：使用static_cast，除非您是downcasting，在这种情况下，dynamic_cast通常是更好的选择。然而，您还应该考虑完全避免强制转换，只使用虚拟函数。Downcasting vs virtual Functions有些开发人员认为dynamic_cast是邪恶的，并且表示糟糕的类设计。相反，这些程序员说应该使用虚拟函数。通常，应优先使用虚拟函数而不是向下投射。然而，有时向下转换是更好的选择：当您不能修改基类以添加虚拟函数时（例如，因为基类是标准库的一部分）当您需要访问特定于派生类的内容（例如，仅存在于派生类中的访问函数）当将虚拟函数添加到基类中没有意义时（例如基类没有适当的返回值）。如果不需要实例化基类，则在这里可以选择使用纯虚函数。关于dynamic_cast和RTTI运行时类型信息（RTTI）的警告是C++的一项功能，它在运行时公开有关对象数据类型的信息。dynamic_cast利用了此功能。由于RTTI具有相当大的空间性能开销，因此一些编译器允许您将RTTI作为优化关闭。不用说，如果这样做，dynamic_cast将无法正常工作。

