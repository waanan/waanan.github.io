---
title: "第25章总结"
date: 2024-11-04T13:14:53+08:00
---

至此，我们对C++继承和虚函数的探索之旅到此结束。在我们前进的过程中，C++还有很多其他领域需要探索。

***
## 章节摘要

C++允许您设置基类对派生对象的指针或引用。当我们想编写一个可以处理从基类派生的任何类型的对象的函数或数组时，这很有用。

如果没有虚函数，基类对派生类的指针和引用只能访问基类版本的成员变量和函数。

虚函数是一种特殊类型的函数，它解析为存在于基类和派生类之间的函数的最底层派生版本（称为重写）。要被视为重写，派生类函数必须具有与虚基类函数相同的签名和返回类型。一个例外是，如果基类函数返回对基类的指针或引用，则允许重写返回对派生类的指针或引用。

一个旨在作为重写的函数应该使用override说明符来确保它实际上是一个重写。

final说明符可用于防止重写函数或类被继承。

如果你打算使用继承，你应该将析构函数设置为virtual，这样如果删除了指向基类的指针，就会调用正确的析构函数。

您可以通过使用域解析运算符直接指定所需函数的类版本来忽略虚函数解析：例如Base::getName()。

静态绑定发生在编译器遇到直接函数调用时。编译器或链接器可以直接解析这些函数调用。当使用函数指针时，会发生动态绑定。在这些情况下，直到运行时才能解析将调用哪个函数。虚函数使用动态绑定和虚函数表来确定要调用哪个版本的函数。

使用虚函数是有代价的：调用虚函数需要更长的时间，虚函数表的必要性使每个包含虚函数的对象的大小增加了一个指针。

通过在虚函数原型的末尾添加“=0”，可以使虚拟函数成为纯虚拟/抽象的。包含纯虚函数的类称为抽象类，不能被实例化。继承纯虚函数的类必须具体定义它们，否则也将被视为抽象类。纯虚函数可以有一个函数体，但它们仍然被认为是抽象的。

接口类是没有成员变量和所有函数都是纯虚函数的类。通常以大写字母I开头命名。

virtual基类是一个只被包含一次的基类，无论它被对象继承了多少次，这用于存在菱形继承的情况。

当将派生类分配给基类对象时，基类只会收到派生类基部分的副本。这被称为对象切片。

dynamic_cast可用于将指向基类对象的指针转换为指向派生类对象的指针。这被称为向下转换。转换失败将返回空指针。

为继承类重载 操作符<< 的最简单方法是为基类编写 操作符<<，然后调用虚拟成员函数进行打印。

***