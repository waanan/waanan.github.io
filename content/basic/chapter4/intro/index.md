---
title: "基本数据类型简介"
date: 2023-10-09T20:06:10+08:00
---

***
## 位、字节和内存寻址

在「对象和变量」中，我们讨论了这样一个事实，即变量是一段可用于存储信息的内存的名称。简单地回顾一下，计算机具有可供程序使用的随机存取存储器（RAM）。定义变量时，会为该变量预留一段内存。

存储器的最小单位是二进制数字（也称为比特，bit），它可以保存值0或1。您可以将其想象为一个传统的灯开关——要么灯关闭（0），要么灯打开（1）。没有中间状态。如果你看一个随机的片段，你会看到的只是「011010100101010」或它们的某种组合。

存储器被组织为称为存储器地址（或简称地址）的顺序单元。类似于街道地址如何用于查找街道上的给定房子，存储器地址允许我们在特定位置查找和访问存储器的内容。

也许令人惊讶的是，在现代计算机架构中，单独的「比特」没有自己唯一的内存地址。这是因为内存地址的数量有限，并且很少需要逐位访问数据。相反，每个存储器地址保存1个「字节」的数据。字节是作为一个单元进行操作的一组位。现代标准是一个字节由8个连续比特组成。

下图显示了一些顺序存储器地址以及相应的数据字节：

{{< img src="./MemoryAddresses.webp" title="存储示意">}}

由于计算机上的所有数据都只是一个比特序列，因此我们使用数据类型（通常简称为“类型”）来告诉编译器如何以某种有意义的方式解释内存的内容。您已经看到了数据类型的一个示例：整数。当我们将变量声明为整数时，我们告诉编译器“该变量使用的内存块将被解释为整数值”。

当您给对象一个值时，编译器和CPU负责将您的值编码为该数据类型的适当比特序列，然后将其存储在内存中（记住：内存只能存储比特）。例如，如果为整数对象赋值65，则该值被转换为比特0100 0001的序列，并存储在分配给该对象的存储器中。

相反，当对象被求值为产生值时，该比特序列被重新组合回原始值。这意味着0100 0001被转换回值65。

幸运的是，编译器和CPU在这里完成了所有的困难工作，因此您通常不需要担心值如何转换为比特序列并返回。

您所需要做的就是为对象选择一种最适合您所需用途的数据类型。

{{< alert success >}}
**关键点**

在C++中，我们通常使用“字节大小”的数据块。

{{< /alert >}}

{{< alert success >}}
**旁白**

一些较旧或非标准的机器可能具有不同大小的字节（从1到48位）——然而，我们通常不需要担心这些，因为现代事实上的标准是一个字节是8位。对于本教程，我们将假设一个字节是8位。

{{< /alert >}}

***
## 基本数据类型

C++内置了对许多不同数据类型的支持。这些称为基本数据类型，但通常非正式地称为基本类型或内置类型。

下面是基本数据类型的列表，其中一些您已经看到过：

|  类型 |  类别  |  含义 |  样例 |
|  ----  | ----  | ----  | ----  |
| float double long double | 浮点数 | 有分数部分的数字 | 3.1415926 |
| bool | bool 整型 | true 或 false | true |
| char  /  wchar_t  /  char8_t (C++20)  /   char16_t (C++11)   /  char32_t (C++11) | 字符 整型 | 一个单独的字符 | ‘c’ |
| short int /  int  /  long int  /  long long int (C++11) | 整数 整型 | 含0，正数或负数 | 42 |
| std::nullptr_t (C++11) | Null Pointer | 空指针 | nullptr |
| void | Void | 无类型 | n/a |

本章致力于详细研究这些基本数据类型（除了std:：nullptr_t，我们将在讨论指针时讨论它）。C++还支持许多其他更复杂的类型，称为复合类型。我们将在未来的一章中探索复合类型。


{{< alert success >}}
**旁白**

大多数现代编程语言都包含基本的字符串类型（字符串是一种数据类型，允许我们保存字符序列，通常用于表示文本）。在C++中，字符串不是基本类型（它们是复合类型）。但由于基本字符串的用法简单而有用，我们将在「std::string简介」小节中介绍它。

{{< /alert >}}

***
## 后缀（_t）

在较新版本的C++中定义的许多类型（例如，std::nullptr_t）使用_t后缀。这个后缀的意思是“类型”，它是应用于现代类型的一个常见术语。

如果您看到带_t后缀的东西，它可能是一种类型。但许多类型没有_t后缀，这是不同版本引入的不一致导致的。

***
