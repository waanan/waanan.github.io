---
title: "前向声明"
date: 2023-10-09T20:06:10+08:00
---

看看这个看似没有问题的示例程序：

```C++
#include <iostream>

int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n';
    return 0;
}

int add(int x, int y)
{
    return x + y;
}
```

您希望该程序产生以下结果：

```C++
The sum of 3 and 4 is: 7
```

但事实上，它根本无法编译通过！Visual Studio生成以下编译错误：

```C++
add.cpp(5) : error C3861: 'add': identifier not found
```

该程序编译失败的原因是编译器按顺序编译代码文件的内容。因为我们直到第9行才定义add，当编译器在main的第5行到达add的函数调用时，它不知道add是什么。

有两种常见的方法来解决这个问题。

***
## 选项1：重新排序函数定义

解决该问题的一种方法是重新排序函数定义，以便在main之前定义add：

```C++
#include <iostream>

int add(int x, int y)
{
    return x + y;
}

int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n';
    return 0;
}
```

这样，到main调用add时，编译器将已经知道什么是add。因为这是一个如此简单的程序，所以这种更改相对容易做。然而，在较大的程序中，试图弄清楚哪些函数调用哪些其他函数（以及以什么顺序），以便可以按顺序声明它们，可能会很繁琐。

此外，这种方法并不总是可行的。假设我们正在编写一个有两个函数A和B的程序。如果函数A调用函数B，函数B调用函数A，那么就没有办法对函数进行排序。如果首先定义A，编译器将告警它不知道B是什么。如果首先定义B，编译器将告警它不知道A是什么。

***
## 选项2：使用前向声明

我们还可以通过使用前向声明来修复此问题。

前向声明允许我们在实际定义标识符之前告诉编译器标识符的存在。

对于函数，这允许我们在定义函数体之前告诉编译器函数的存在。这样，当编译器遇到函数调用时，它就能理解正在进行的函数调用，并可以检查并确保我们正确调用了函数，即使它还不知道函数的实际定义。

为了编写函数的前向声明，我们使用函数声明语句（也称为函数原型）。函数声明由函数的返回类型、名称和参数类型组成，以分号结尾。参数名称是可选的，声明中不包括函数体。

下面是add函数的函数声明：

```C++
int add(int x, int y); // 函数声明包含返回值，函数名，参数，分号，没有函数体
```

下面是修改后能通过编译的程序，使用了函数add的前向声明：

```C++
#include <iostream>

int add(int x, int y); // 函数add()的前向声明

int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n'; // 可以通过编译
    return 0;
}

int add(int x, int y) // 函数add()在这里定义
{
    return x + y;
}
```

现在，当编译器到达main中对add的调用时，它将知道add函数是什么样子的（接受两个整数参数并返回一个整数），所以不会编译报错。

值得注意的是，函数声明不需要指定参数的名称（因为它们不被视为函数声明的一部分）。在上面的代码中，您还可以如下的函数前向声明：

```C++
int add(int, int); // 有效的前向声明语句
```

当然，我们更喜欢带参数名的声明（使用与实际函数相同的名称），因为它允许我们通过查看声明来理解函数参数的含义。

{{< alert success >}}
**最佳实践**

在函数声明中保留参数名。

{{< /alert >}}

{{< alert success >}}
**提示**

通过复制/粘贴函数头并添加分号，可以轻松创建函数声明。

{{< /alert >}}

***
## 为什么需要前向声明？

如果我们可以重新排序函数的顺序以使程序工作，为什么要使用前向声明？

大多数情况下，前向声明用于告诉编译器在其它代码文件中定义的函数。在这种情况下，无法重新排序，因为调用者和被调用者位于完全不同的文件中！我们将在下一节中更详细地讨论这一点。

前向声明也可以用于以不确定顺序的方式定义函数。这允许我们以最容易阅读理解的任何顺序来定义函数。

不太常见的是，有时我们有两个函数相互调用。在这种情况下，也不可能重新排序，因为没有办法重新排序函数，使每个函数都在另一个之前。前向声明为我们提供了一种解决这种循环依赖的方法。

***
## 缺少函数定义的情形

新程序员经常想知道，如果他们前向声明一个函数，但不定义它会发生什么。

答案是：视情况而定。如果进行了前向声明，但从未调用函数，则程序将编译并正常运行。然而，如果进行了前向声明并调用了函数，但程序从未定义函数，则程序将编译正常，但链接器将告警，它无法找到对应的函数。

考虑以下程序：

```C++
#include <iostream>

int add(int x, int y); // 前向声明 add()

int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n';
    return 0;
}

// 未定义函数 add
```

在这个程序中，我们向前声明add，并调用add，但我们从未在任何地方定义add。尝试编译此程序时，Visual Studio会生成以下消息：

```C++
Compiling...
add.cpp
Linking...
add.obj : error LNK2001: unresolved external symbol "int __cdecl add(int,int)" (?add@@YAHHH@Z)
add.exe : fatal error LNK1120: 1 unresolved externals
```

正如您所看到的，程序编译正常，但它在链接阶段失败，因为从未定义int add(int, int)。

***
## 其他类型的前向声明

前向声明最常用于函数。然而，前向声明也可以与C++中的其他标识符一起使用，例如变量和类型。变量和类型具有不同的前向声明语法，将在以后的课程中介绍这些。

***
## 声明与定义

在C++中，您会经常听到使用“声明”和“定义”两个词，并且通常可以互换。它们是什么意思？你现在有了足够的基础知识来理解两者之间的区别。

声明告诉编译器标识符的存在及其关联的类型信息。下面是一些声明示例：

```C++
int add(int x, int y); // 告诉编译器函数add的存在，参数是2个int，返回值是int，无函数体
int x;                 // 告诉编译器变量x的存在，类型是int
```

定义是一个声明，它实际实现（对于函数和类型）或实例化（对于变量）标识符。

下面是一些定义示例：

```C++
int add(int x, int y) // 函数add()的实现
{
    int z{ x + y };   // 实例化变量 z

    return z;
}

int x;                // 实例化变量 x
```

在C++中，所有定义都是声明。因此为int x; 既是定义又是声明。

相反，并不是所有的声明都是定义。不是定义的声明称为纯声明。纯声明的类型包括函数、变量和类型的前向声明。

当编译器遇到标识符时，它将进行检查以确保该标识符的使用有效（例如，该标识符在作用域内，语法有效，等等）。

在大多数情况下，声明足以允许编译器确保正确使用标识符。例如，当编译器遇到函数调用add(5, 6)时，如果它已经看到add(int, int)的声明，那么它可以验证add实际上是一个接受两个int参数的函数。它不需要实际看到函数add的定义（可能存在于其他文件中）。

然而，在一些情况下，编译器必须能够看到完整的定义才能使用标识符（例如，对于模板定义和类型定义，我们将在以后的课程中讨论这两种定义）。

下面是一个摘要表：

|  术语 |  含义  |  样例 |
|  ----  | ----  | ----  |
| 定义 | 实现函数，或者实例化变量，定义也是声明 | int x;  void foo() { } |
| 声明 | 告诉编译器标识符的信息 | void foo(); int x; |
| 纯声明 | 非定义的声明 | void foo(); |
| 初始化 | 给一个对象初始值 | int x { 2 }; |

{{< alert success >}}
**注**

通常，术语“声明”通常用于表示“纯声明”，“定义”用于表示“也用作声明的定义”。因此，我们通常称为int x; 为定义，即使它既是定义又是声明。

{{< /alert >}}

***
## 单定义规则

单定义规则（简称ODR，The one definition rule）是C++中众所周知的规则。ODR由三部分组成：
1. 同一文件中的同一作用域内，函数，变量，类型，模版只能有一个定义。不同作用域的同名定义不违反此规则。（例如不同函数中的同名变量，不同命名空间内的同名函数）
2. 同一程序中，函数或者变量只能有一个定义。因为程序可能有多个文件，发生冲突时无法处理。不被链接器可见的定义不受此规则限制。
3. 类型，模版，内联函数，内联变量可以在多个文件中同时定义。只有它们的定义是一致的。

这里的情形，大多数还未讲到，后面在对应的知识点时会再次讲解。

违反ODR的第1部分将导致编译器发出重新定义错误。违反ODR第2部分将导致链接器发出重新定义错误或导致未定义的行为。违反ODR第3部分将导致未定义的行为。

下面是违反规则一的示例：

```C++
int add(int x, int y)
{
     return x + y;
}

int add(int x, int y) // 违反了规则一
{
     return x + y;
}

int main()
{
    int x;
    int x; // 违反了规则一
}
```

由于上述程序违反ODR规则一，这导致Visual Studio编译器发出以下编译错误：

```C++
project3.cpp(9): error C2084: function 'int add(int,int)' already has a body
project3.cpp(3): note: see previous definition of 'add'
project3.cpp(16): error C2086: 'int x': redefinition
project3.cpp(15): note: see declaration of 'x'
```

ODR不适用于纯声明（它是一个描述定义的规则，而不是一个关于声明的规则），因此可以根据需要为标识符提供任意多的纯声明（尽管有多个纯声明是多余的）。

{{< alert success >}}
**对于高级读者**

有不同参数的同名函数被认为是不同的函数。将在函数重载章节进行讨论。

{{< /alert >}}

***

{{< prevnext prev="/basic/chapter2/why-func/" next="/" >}}
2.5 为什么需要函数
<--->
主页
{{< /prevnext >}}
