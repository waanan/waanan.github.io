---
title: "头文件"
date: 2023-10-09T20:06:10+08:00
---

***
## 头文件及其用途

随着程序变得越来越大（并使用更多的文件），在不同cpp文件中需要使用大量重复的向前声明。如果可以将所有的前向声明放在一个地方，然后在需要时导入它们，这样就会很方便。

C++代码文件（扩展名为.cpp）并不是C++程序中常见的唯一文件类型。另一种类型的文件称为头文件。头文件通常具有.h扩展名，但您偶尔会看到它们具有.hpp扩展名或根本没有扩展名。头文件的主要目的是将声明传播到代码（.cpp）文件。

{{< alert success >}}
**关键点**

头文件允许我们将声明放在一个位置，然后在需要的地方导入它们。这可以节省多文件程序中的大量冗余单调的工作。

{{< /alert >}}

***
## 使用标准库头文件

考虑以下程序：

```C++
#include <iostream>

int main()
{
    std::cout << "Hello, world!";
    return 0;
}
```

该程序使用std::cout将“Hello，world！”打印到控制台。然而，该程序从未提供std::cout的定义或声明，那么编译器如何知道什么是std::cout？

答案是std::cout已在“iostream”头文件中向前声明。当我们#include<iostream>时，预处理器将所有内容（包括std::cout的前向声明）从名为“iostream”的文件复制到#include<iostream> 的位置。

考虑如果iostream头文件不存在会发生什么？无论在哪里使用std::cout，都必须手动将与std::cout相关的所有声明复制到使用std::cout的地方。这将需要大量关于std::cout的知识，并且将是一项繁重的工作。更糟糕的是，如果添加或更改了对应的函数或变量原型，我们就必须手动更新所有的前向声明。

只使用#include<iostream>要容易得多！

{{< alert success >}}
**关键点**

当您#include引用文件时，所引用的文件的内容将替换到#include的点。这提供了一种从另一个文件中拉入声明的有用方法。

{{< /alert >}}

***
## 使用头文件传播前向声明

现在，让我们回到上一课中讨论的示例。有两个文件，add.cpp和main.cpp，如下所示：

add.cpp：

```C++
int add(int x, int y)
{
    return x + y;
}
```

main.cpp：

```C++
#include <iostream>

int add(int x, int y); // 前向声明函数原型

int main()
{
    std::cout << "The sum of 3 and 4 is " << add(3, 4) << '\n';
    return 0;
}
```

（如果从头开始重新创建此示例，请不要忘记将add.cpp添加到项目中，以便进行编译）。

在本例中，我们使用了前向声明，以便编译器在编译main.cpp时知道添加的标识符是什么。如前所述，为想要使用的位于另一个文件中的每个函数手动添加前向声明可能会很快变得乏味。

让我们编写一个头文件来减轻我们的负担。编写头文件非常容易，因为头文件仅由两部分组成：

1. 头文件保护，下一节中讨论。
2. 头文件的实际内容。包含其它文件想要使用的所有前向声明。

将头文件添加到项目中的工作方式类似于添加源文件。

如果使用IDE，请执行相同的步骤，并选择“头文件”而不是“源文件”。头文件应作为项目的一部分出现。

如果使用命令行，只需在您喜爱的编辑器中创建一个新文件，该文件与源（.cpp）文件位于同一目录中。与源文件不同，头文件不应添加到编译命令中（它们被#include语句隐式包含并编译为源文件的一部分）。

头文件通常与代码文件配对，头文件为相应的代码文件提供前向声明。由于头文件将包含add.cpp中定义的函数的前向声明，因此我们将新建头文件add.h。

这是对应的头文件：

add.h：

```C++
// 1) 这里需要一个头文件保护，但暂时不影响程序编译，下一节讨论对应细节。

// 2) 这里是 .h 文件内容
int add(int x, int y); // add的函数声明，这里不要忘记分号
```

为了在main.cpp中使用此头文件，我们必须#include引用它（使用引号，而不是尖括号）。

main.cpp：

```C++
#include "add.h" // add.h 的内容会被插入这里。需要使用双引号
#include <iostream>

int main()
{
    std::cout << "The sum of 3 and 4 is " << add(3, 4) << '\n';
    return 0;
}
```

add.cpp：

```C++
#include "add.h" // add.h 的内容会被插入这里。需要使用双引号

int add(int x, int y)
{
    return x + y;
}
```

当预处理器处理#include "add.h" 时，它会在该点将add.h的内容复制到当前文件中。因为我们的add.h包含函数add() 的前向声明，所以该前向声明将被复制到main.cpp。最终结果是一个程序，其功能与我们在main.cpp顶部手动添加前向声明的程序相同。

因此，我们的程序将正确编译和链接。

{{< img src="./IncludeHeader.webp" title="引用关系示意图">}}

{{< alert success >}}
**最佳实践**

命名头文件时首选.h后缀（除非您的项目已经遵循其他约定）。

这是C++头文件的一个长期约定，大多数IDE仍然默认为.h而不是其他选项。

{{< /alert >}}

{{< alert success >}}
**最佳实践**

如果头文件与代码文件成对出现（例如，add.h与add.cpp），则它们都应该具有相同的基本名称（add）。

{{< /alert >}}

***
## 在头文件中包含定义如何导致违反单定义规则

应该避免将函数或变量定义放在头文件中。在头文件被多个源文件使用的情况下，这样做通常会导致违反单定义规则（ODR）。

让我们来说明这是如何发生的：

add.h：

```C++
// 这里需要一个头文件保护，下一节讨论对应细节。

// add() 函数定义 -- 不要这样做!
int add(int x, int y)
{
    return x + y;
}
```

main.cpp：

```C++
#include "add.h" // add.h 的内容会被插入这里
#include <iostream>

int main()
{
    std::cout << "The sum of 3 and 4 is " << add(3, 4) << '\n';

    return 0;
}
```

add.cpp：

```C++
#include "add.h" // add.h 的内容会被插入这里
```

编译main.cpp时，#include "add.h" 将替换为add.h的内容，然后进行编译。因此，编译器将编译如下所示的内容：

main.cpp（预处理后）：

```C++
int add(int x, int y)
{
    return x + y;
}
include <iostream>

int main()
{
    std::cout << "The sum of 3 and 4 is " << add(3, 4) << '\n';

    return 0;
}
```

这可以编译通过。

编译器编译add.cpp时，#include "add.h" 将替换为add.h的内容，然后进行编译。因此，编译器将编译如下：

add.cpp（预处理后）：

```C++
int add(int x, int y)
{
    return x + y;
}
```

这也可以很好地编译。

最后，链接器将运行。链接器将看到函数add() 现在有两个定义：一个在main.cpp中，另一个在add.cpp。这违反了ODR第2部分的规定，该部分指出，“在给定的程序中，变量或普通函数只能有一个定义。”

{{< alert success >}}
**最佳实践**

不要将函数和变量定义放在头文件中。

如果随后将头文件包含在多个源（.cpp）文件中，则在头文件中定义其中之一可能会导致违反单定义规则（ODR）。

{{< /alert >}}

{{< alert success >}}
**注**

在以后的课程中，我们将遇到可以在头文件中安全定义的其他类型的定义（因为它们不受ODR的限制）。这包括内联函数、内联变量、类型和模板的定义。我们将在介绍其中的每一个时进一步讨论这一点。

{{< /alert >}}

***
## 代码中.h与.cpp应该成对

在C++中，代码文件的最佳实践是#include成对的头文件（如果存在）。在上面的示例中，add.cpp引用add.h。

这允许编译器在编译时而不是链接时捕获某些类型的错误。例如：

something.h：

```C++
int something(int); // 返回值是int的前向声明
```

something.cpp：

```C++
#include "something.h"

void something(int) // 编译失败，返回值类型不一致
{
}
```

由于something.cpp引用了somethine.h，编译器将注意到函数something() 的返回类型不匹配，并给出编译错误。如果something.cpp没有#include somethine.h，我们必须等待链接器发现差异，这会浪费时间。

在未来的课程中，我们还将看到许多示例，其中源文件所需的内容在成对的头文件中定义。在这种情况下，包括头文件是必要的。

{{< alert success >}}
**最佳实践**

源文件应#include 其成对的头文件（如果存在的话）。

{{< /alert >}}

***
## 不#include .cpp文件

尽管预处理器可以这样处理，但通常不应该#include .cpp文件。这些应该添加到项目中并进行编译。

这有许多原因：

1. 这样做可能会导致源文件之间的命名冲突。
2. 在大型项目中，很难避免违反单定义规则（ODR）的问题。
3. 对这样的.cpp文件的任何更改都将导致.cpp文件和包含它的任何其他.cpp 文件重新编译，这可能需要很长时间。与源文件相比，头文件的更改频率较低。
4. 这样做是非常规的。


{{< alert success >}}
**最佳时间**

避免#include .cpp文件。

{{< /alert >}}

***
## 故障排除

如果出现编译器错误，指示找不到add.h，请确保该文件实际命名为add.h。根据您创建和命名该文件的方式，该文件可能被命名为add（无扩展名）或add.h.txt或add.hpp。此外，请确保它与其余代码文件位于同一目录中。

如果收到关于未定义函数add的链接器错误，请确保已在项目中包含add.cpp，以便可以将函数add定义链接到程序中。

***
## 尖括号与双引号

您可能很好奇为什么我们对iostream使用尖括号，对add.h使用双引号。有可能在多个目录中存在具有相同文件名的头文件。我们对尖括号和双引号的使用有助于给预处理器一个线索，告诉它应该在哪里查找头文件。

当我们使用尖括号时，我们告诉预处理器，这是一个不是我们自己编写的头文件。预处理器将仅在系统目录指定的目录中搜索头文件。include系统目录配置为项目/IDE设置/编译器设置的一部分，通常默认为包含编译器和/或操作系统附带的头文件的目录。预处理器不会在项目的源代码目录中搜索对应的头文件。

当我们使用双引号时，我们告诉预处理器这是我们编写的头文件。预处理器将首先在当前目录中搜索头文件。如果它在那里找不到匹配的头文件，那么它将搜索系统目录。

{{< alert success >}}
**规则**

使用双引号来include您编写的或预期在当前目录中找到的头文件。使用尖括号来引用编译器、操作系统或系统上其他地方安装的第三方库附带的头文件。

{{< /alert >}}

***
## 为什么iostream没有.h扩展名？

另一个常见的问题是“为什么iostream（或任何其他标准库头文件）没有.h扩展名？”。答案是iostream.h与iostream是不同的头文件！解释需要上一堂简短的历史课。

首次创建C++时，标准库中的所有文件都以.h后缀结尾。如果生活是始终如一的，那么这是美好的。cout和cin的原始版本在iostream.h中声明。当ANSI委员会标准化C++语言时，他们决定将标准库中使用的所有名称移到std命名空间中，以避免与用户声明的标识符发生命名冲突。然而，这会导致一个问题：如果他们将所有名称移到std命名空间中，则旧程序（include iostream.h）都将无法再工作！

为了解决这个问题，引入了一组新的头文件，它们没有.h扩展名。这些新的头文件声明std命名空间中的所有名称。这样，使用#include <iostream.h>的旧程序不需要重写，而新的程序可以#incluse <iostream>。

此外，从C继承的许多在C++中仍然有用的库都被赋予了C前缀（例如，stdlib.h变为cstdlib）。


{{< alert success >}}
**最佳实践**

使用标准库中的头文件时，如果存在不带.h扩展名的版本，请使用该版本。用户定义的头文件仍应使用.h扩展名。

使用标准库时，首选在std命名空间中声明的名称。

{{< /alert >}}

***
## 包括来自其他目录的头文件

另一个常见的问题涉及如何包括来自其他目录的头文件。

这样做的一种（错误的）方法是#include头文件的相对路径。例如：

```C++
#include "headers/myHeader.h"
#include "../moreHeaders/myOtherHeader.h"
```

虽然这能够编译成功（假设文件存在于这些相对目录中），但这种方法的缺点是它需要您在代码中反映目录结构。如果您更新了目录结构，则代码将不再工作。

一个更好的方法是告诉编译器或IDE，您在其他位置有一组头文件，这样当它在当前目录中找不到它们时，它就会在那里查找。这通常可以通过在IDE项目设置中设置头文件路径或搜索目录来完成。

这种方法的好处是，如果您更改了目录结构，则只需更改单个编译器或IDE设置，而不是每个代码文件。

{{< alert success >}}
**对于Visual Studio用户**

在解决方案资源管理器中右键单击项目，然后选择属性，然后选择VC++目录选项卡。从这里，您将看到一行，名为头文件目录。添加希望编译器在其中搜索其它头文件的目录。

{{< /alert >}}


{{< alert success >}}
**对于GCC/G++用户**

使用g++，可以使用-I选项指定其它头文件目录：g++ -o main -I/source/includes main.cpp

-I后面没有空格。

{{< /alert >}}

{{< alert success >}}
**对于VS代码用户**

在tasks.json配置文件中，在“Args”部分添加新行：“-I/source/includes”，

{{< /alert >}}

***
## 头文件可以include其他头文件

头文件通常需要使用存在于其它头文件中的声明或定义。因此，头文件通常#include其他头文件。

当您的代码文件#include一个头文件时，您还将获得一个头文件#include的任何其他头文件（以及递归#include的任何头文件，等等）。它们是隐式包含的，而不是显式包含的。

这些递归包含的内容可在代码文件中使用。然而，通常不应依赖递归包含的头文件的内容（除非参考文档指示需要这些递归#include的内容）。头文件的实现可能会随着时间的推移而变化，或者在不同的系统中有所不同。如果发生这种情况，您的代码可能只能在某些系统上编译，或者可以现在编译，但不能在将来编译。通过显式#include代码文件内容所需的所有头文件，可以很容易地避免这种情况。

不幸的是，当您的代码文件意外地依赖于另一个头文件所包含的头文件的内容时，并没有简单的方法来检测。

{{< alert success >}}
**最佳实践**

每个文件都应该显式地#include它需要编译的所有头文件。不要依赖于从其他头文件传递包含的头文件。

{{< /alert >}}

***
## 头文件的#include顺序

如果头文件编写正确，并且#include了它们需要的所有内容，那么包含的顺序应该无关紧要。

现在考虑以下场景：假设头文件A需要来自头文件B的声明，但忘记包含它。在我们的代码文件中，如果在头文件A之前包含头文件B，我们的代码仍然会编译！这是因为编译器将在编译A时，已经获得了B的全部信息。

然而，如果我们首先包含头文件A，那么编译器将报错，因为来自A的代码将在编译器看到来自B的声明之前编译。这实际上是更好的使用方式，因为错误已经出现，我们可以修复它。


{{< alert success >}}
**最佳做法**

要最大限度地提高编译器发现缺失的include的机会，请按以下顺序排列#includes：

1. 与当前cpp文件对应的h文件
2. 本项目中的其它头文件
3. 第三方库的头文件
4. 标准库的头文件

每个分组的头文件应按字母顺序排序（除非第三方库的文档有明确指示）。

{{< /alert >}}

***
## 头文件最佳实践

下面是关于创建和使用头文件的更多建议。

1. 始终使用头文件保护（我们将在下一课中介绍这些）。
2. 不要在头文件中定义变量和函数（目前）。
3. 为头文件提供与其关联的源文件相同的名称（例如，grades.h与grades.cpp成对出现）。
4. 每个头文件都应该有一个特定的功能，并且尽可能独立。例如，您可以将与功能A相关的所有声明放在A.h中，将与功能B相关的所有宣言放在B.h中。这样，如果您稍后只关心A，则可以只包含A.h，而不获取与B相关的任何内容。
5. 请注意需要为代码文件中使用的功能显式包含对应的头文件。
6. 您编写的每个标头都应该单独编译通过（它应该#include 它需要的每个依赖项）。
7. 仅#include 您需要的内容（不要仅因为可以而包含所有内容）。
8. 不要#include .cpp文件。
9. 在头文件中放置关于某事的作用或如何使用它的文档。它更可能在那里被看到。描述某些内容如何工作的文档应保留在源文件中。

***

{{< prevnext prev="/basic/chapter2/preprocess/" next="/basic/chapter2/header-guard/" >}}
2.9 预处理器简介
<--->
2.11 头文件保护
{{< /prevnext >}}
