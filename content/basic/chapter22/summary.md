---
title: "第22章总结"
date: 2024-08-23T14:54:42+08:00
---

智能指针类是一个组合类，旨在管理动态分配的内存，并确保当智能指针对象超出作用域时删除内存。

复制语义允许复制我们的类。这主要是通过拷贝构造函数和拷贝赋值操作符来完成的。

移动语义意味着类将转移对象的所有权，而不是制作副本。这主要是通过移动构造函数和移动赋值操作符来完成的。

std::auto_ptr已弃用，应避免使用。

右值引用是设计为使用右值初始化的引用。使用"双&"符号创建右值引用。编写采用右值引用参数的函数是可以的，但您几乎不应该返回右值引用。

如果我们构造一个对象或进行赋值，其中参数是左值，那么我们唯一可以合理地做的事情就是复制左值。我们不能假设更改左值是安全的，因为它可能会在以后的程序中再次使用。如果我们有一个表达式“a=b”，b是左值，不应期望b以任何方式改变。

然而，如果我们构造一个对象或进行赋值，其中参数是右值，则我们知道右值只是某种临时对象。我们可以简单地将其资源（代价很低）转移到正在构建或赋值的对象，而不是复制它（这可能很昂贵）。这样做是安全的，因为临时变量无论如何都将在表达式末尾被销毁，所以我们知道它将永远不会被再次使用！

可以使用delete关键字通过删除拷贝构造函数和拷贝赋值运算符来禁用类的复制语义。

std::move允许您将左值视为右值。当我们想在左值上调用移动语义而不是复制语义时，这很有用。

std::unique_ptr是您最可能使用的智能指针类。它管理单个不可共享的资源。应首选std::make_unique()（自C++14起）来创建新的std::unique_ptr。std::unique_ptr禁用复制语义。

std::shared_ptr是当需要多个对象访问同一资源时使用的智能指针类。在销毁管理资源的最后一个std::shared_ptr之前，不会销毁该资源。应首选 std::make_shared() 来创建新的std::shared_ptr。对于std::shared_ptr，应该使用复制语义来创建指向同一对象的其他std::shared_ptr。

std::weak_ptr是当您需要一个或多个能够查看和访问由std:∶shared_ptr管理资源的对象时使用的智能指针类，但与std::shared_ptr不同的是，在确定是否应销毁资源时，不考虑std::weak_ptr。

***

{{< prevnext prev="/basic/chapter22/circle-ref/" next="/basic/chapter23/object-relation/" >}}
22.6 std::shared_ptr的循环依赖性问题和std::weak_ptr
<--->
23.0 对象关系
{{< /prevnext >}}
