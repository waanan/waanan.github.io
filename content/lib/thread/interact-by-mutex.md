---
title: "多线程间交互-mutex（施工中）"
date: 2025-03-15T16:25:41+08:00
---

## 竞态情况（race condition）

进程中的所有线程，共享这个进程中的所有资源。这意味着，一个对象可能被所有的线程看见并进行操作。

参考如下的例子：

```C++
#include <iostream>
#include <thread>

int i = 0;

void t1()
{
    // 线程一执行这个函数
    i++;
}

void t2()
{
    // 线程二执行这个函数
    i++;
}
```

假设线程一执行t1()，线程二执行t2()。线程一与线程二同时执行。当这两个线程都执行结束时，i的值会是多少？结果难道不是显而易见的“2”么。

这在单线程的场景下确实如此，但是在多线程的情况下，事情就会变得复杂起来。

“i++”实际在物理机器上执行时，会拆分为三段：

```C++
从 内存 加载 i 到 寄存器r
寄存器r 的值加一
将 寄存器r 的值 写回 i 对应的内存
```

对于线程t1和t2，可能会有多种执行情况：

```C++
// 情形1
t1：从 内存 加载 i 到 寄存器r1         // 寄存器r1 = 0
t2：从 内存 加载 i 到 寄存器r1         // 寄存器r2 = 0
t1：寄存器r1 的值加一                  // 寄存器r1 = 1
t2：寄存器r2 的值加一                  // 寄存器r2 = 1
t1：将 寄存器r1 的值 写回 i 对应的内存  // i = 1
t2：将 寄存器r2 的值 写回 i 对应的内存  // i = 1
```

又或者是这种执行情况：

```C++
// 情形2
t1：从 内存 加载 i 到 寄存器r1         // 寄存器r1 = 0
t1：寄存器r1 的值加一                  // 寄存器r1 = 1
t1：将 寄存器r1 的值 写回 i 对应的内存  // i = 1
t2：从 内存 加载 i 到 寄存器r1         // 寄存器r2 = 1
t2：寄存器r2 的值加一                  // 寄存器r2 = 2
t2：将 寄存器r2 的值 写回 i 对应的内存  // i = 2
```

或者可能是其它交错的执行情形。但是，当发生大概率执行的结果，不是预期的“2”。

当多线程同时访问同一资源，但又没有合理的进行同步，从而可能导致非预期的执行结果。我们说，这时处于「竞态情况」（race condition）。

***
## 临界区（Critical Section）

为了解决上面提到的问题，多线程对于共享资源操作的代码，必须同一时间，只能被一个线程进行执行。只有这样的特殊操作手段，以及合理的代码逻辑，才能完成多线程间的信息同步。

这块特殊的代码段，被称作「临界区」（Critical Section）。

***
## 锁（mutex）

锁（mutex）是用来实现临界区的最常用的手段。可以想象有一间同时只能容纳一个人进入的房子，

***

{{< prevnext prev="/lib/thread/thread-life/" next="/lib/thread/dead-lock/" >}}
0.1 线程的生命周期
<--->
0.3 死锁，以及如何避免
{{< /prevnext >}}
