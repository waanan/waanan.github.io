---
title: "多线程间交互-mutex（施工中）"
date: 2025-03-15T16:25:41+08:00
---

进程中的所有线程，共享这个进程中的所有资源。这意味着，一个对象可能被所有的线程看见并进行操作。

参考如下的例子：

```C++
#include <iostream>
#include <thread>

int i = 0;

void t1()
{
    // 线程一执行这个函数
    i++;
}

void t2()
{
    // 线程二执行这个函数
    i++;
}
```

假设线程一执行t1()，线程二执行t2()。线程一与线程二同时执行。当这两个线程都执行结束时，i的值会是多少？结果难道不是显而易见的“2”么。

这在单线程的场景下确实如此，但是在多线程的情况下，事情就会变得复杂起来。

“i++”实际在物理机器上执行时，会拆分为三段：

```C++
从 内存 加载 i 到 寄存器r
寄存器r 的值加一
将 寄存器r 的值 写回 i 对应的内存
```

对于线程t1和t2，可能会有多种执行情况：

```C++
// 情形1
t1: 从 内存 加载 i 到 寄存器r1         // 寄存器r1 = 0
t2：从 内存 加载 i 到 寄存器r1         // 寄存器r2 = 0
t1：寄存器r1 的值加一                  // 寄存器r1 = 1
t2：寄存器r2 的值加一                  // 寄存器r2 = 1
t1：将 寄存器r1 的值 写回 i 对应的内存  // i = 1
t2：将 寄存器r2 的值 写回 i 对应的内存  // i = 1
```

又或者是这种执行情况：

```C++
// 情形2
t1: 从 内存 加载 i 到 寄存器r1         // 寄存器r1 = 0
t1：寄存器r1 的值加一                  // 寄存器r1 = 1
t1：将 寄存器r1 的值 写回 i 对应的内存  // i = 1
t2：从 内存 加载 i 到 寄存器r1         // 寄存器r2 = 1
t2：寄存器r2 的值加一                  // 寄存器r2 = 2
t2：将 寄存器r2 的值 写回 i 对应的内存  // i = 2
```

***

{{< prevnext prev="/lib/thread/thread-life/" next="/lib/thread/dead-lock/" >}}
0.1 线程的生命周期
<--->
0.3 死锁，以及如何避免
{{< /prevnext >}}
